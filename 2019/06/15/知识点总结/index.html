<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="基础班知识点总结Day 01 【前言、入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商  2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加  3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单">
<meta property="og:type" content="article">
<meta property="og:title" content="基础班知识点总结">
<meta property="og:url" content="http://yoursite.com/2019/06/15/知识点总结/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="基础班知识点总结Day 01 【前言、入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商  2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加  3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-06-15T13:03:42.894Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="基础班知识点总结">
<meta name="twitter:description" content="基础班知识点总结Day 01 【前言、入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商  2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加  3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/15/知识点总结/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>基础班知识点总结 | Hexo</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>Startseite</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>Archiv</a>

  </li>

      
      
    </ul>
  

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/15/知识点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="John Doe">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">基础班知识点总结

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-15 21:02:46 / Geändert am: 21:03:42" itemprop="dateCreated datePublished" datetime="2019-06-15T21:02:46+08:00">2019-06-15</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="基础班知识点总结"><a href="#基础班知识点总结" class="headerlink" title="基础班知识点总结"></a>基础班知识点总结</h1><h2 id="Day-01-【前言、入门程序、常量、变量】"><a href="#Day-01-【前言、入门程序、常量、变量】" class="headerlink" title="Day 01 【前言、入门程序、常量、变量】"></a>Day 01 【前言、入门程序、常量、变量】</h2><h4 id="1-Java语言用途"><a href="#1-Java语言用途" class="headerlink" title="1. Java语言用途"></a>1. Java语言用途</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发网站的后台业务逻辑，例如：传统行业和电商</span><br></pre></td></tr></table></figure>

<h4 id="2-十进制和二进制的转换规则"><a href="#2-十进制和二进制的转换规则" class="headerlink" title="2. 十进制和二进制的转换规则"></a>2. 十进制和二进制的转换规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制</span><br><span class="line"></span><br><span class="line">二进制转十进制：位权乘以二进制数，再相加</span><br></pre></td></tr></table></figure>

<h4 id="3-计算机存储单元"><a href="#3-计算机存储单元" class="headerlink" title="3.计算机存储单元"></a>3.计算机存储单元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s</span><br><span class="line"></span><br><span class="line">进制单位是1024</span><br></pre></td></tr></table></figure>

<h4 id="4-Java的跨平台性？"><a href="#4-Java的跨平台性？" class="headerlink" title="4. Java的跨平台性？"></a>4. Java的跨平台性？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为Java运行在虚拟机上，不同的系统对应不同版本的虚拟机（JVM）</span><br></pre></td></tr></table></figure>

<h4 id="5-JDK、JRE和JVM"><a href="#5-JDK、JRE和JVM" class="headerlink" title="5. JDK、JRE和JVM"></a>5. JDK、JRE和JVM</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JDK：是开发工具包，能进行开发，运行环境</span><br><span class="line"></span><br><span class="line">JRE：是java的运行环境</span><br><span class="line"></span><br><span class="line">JVM：是java的核心，虚拟机</span><br><span class="line"></span><br><span class="line">包含关系: jdk --&gt; jre --&gt; jvm</span><br></pre></td></tr></table></figure>

<h4 id="6-环境变量配置的意义"><a href="#6-环境变量配置的意义" class="headerlink" title="6. 环境变量配置的意义"></a>6. 环境变量配置的意义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量的意义是让操作系统知道去哪里找java命令，使计算机能够在任意目录下运行java和javac这两个命令</span><br></pre></td></tr></table></figure>

<h4 id="7-Java程序编写的三个步骤"><a href="#7-Java程序编写的三个步骤" class="headerlink" title="7. Java程序编写的三个步骤"></a>7. Java程序编写的三个步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编写：程序员编写代码</span><br><span class="line"></span><br><span class="line">编译：将我们编写的代码编程计算机能识别的代码</span><br><span class="line"></span><br><span class="line">运行：运行字节码文件，.class文件，显示效果</span><br></pre></td></tr></table></figure>

<h4 id="8-常用命令提示符"><a href="#8-常用命令提示符" class="headerlink" title="8. 常用命令提示符"></a>8. 常用命令提示符</h4><table>
<thead>
<tr>
<th>功能</th>
<th>输入</th>
</tr>
</thead>
<tbody><tr>
<td>切换盘符</td>
<td>盘符名称：</td>
</tr>
<tr>
<td>进入文件夹</td>
<td>cd  文件夹1\文件夹2\文件夹3</td>
</tr>
<tr>
<td>返回上一级</td>
<td>cd ..</td>
</tr>
<tr>
<td>直接回根路径</td>
<td>cd \</td>
</tr>
<tr>
<td>查看当前文件夹内容</td>
<td>dir</td>
</tr>
<tr>
<td>清屏</td>
<td>cls</td>
</tr>
<tr>
<td>退出</td>
<td>exit</td>
</tr>
</tbody></table>
<h4 id="9-注释及其格式"><a href="#9-注释及其格式" class="headerlink" title="9. 注释及其格式"></a>9. 注释及其格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注释是对代码进行解释说明的文字，提高代码的可读性</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>java中的注释分三种：</strong></p>
<ul>
<li>单行注释:        // 文字</li>
<li>多行注释:        /*  文字 */</li>
<li>文档注释:        /** 文字 */</li>
</ul>
</blockquote>
<h4 id="10-关键字"><a href="#10-关键字" class="headerlink" title="10. 关键字"></a>10. 关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键字：被java语言赋予了特殊的含义的单词，Java一共定义了50个关键字。</span><br><span class="line"></span><br><span class="line">特点：（1）全部小写；（2）在不同的编辑器下关键字的颜色是不一样的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前已学的关键字可分为4类：（更新至Day05课程）</p>
<p><strong>定义数据类型</strong>：class  byte  short  int  long  float  double  char  boolean  void</p>
<p><strong>定义数据值类型</strong>：true  false  null</p>
<p><strong>定义流程控制</strong>：if  else  switch  case  default  while  do  for  break  continue  return</p>
<p><strong>其他类型</strong>：public  static  new  package  import </p>
</blockquote>
<h4 id="11-标识符及其定义规范"><a href="#11-标识符及其定义规范" class="headerlink" title="11. 标识符及其定义规范"></a>11. 标识符及其定义规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标识符：自己定义的单词</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>硬性要求：</strong></p>
<ol>
<li>标识符包含英文26字母（大小写）、数字0-9、$、_</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
</ol>
</blockquote>
<blockquote>
<p><strong>软性建议：</strong></p>
<ol>
<li>类名：大驼峰（单词的首字母全部大写）</li>
<li>变量名：小驼峰（如果有多个单词，那么第一个单词首字母小写，后面单词首字母大写）</li>
<li>方法名：小驼峰</li>
</ol>
</blockquote>
<h4 id="12-数据类型"><a href="#12-数据类型" class="headerlink" title="12. 数据类型"></a>12. 数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java是强类型语言, 对于每一种数据类型都规定了明确的取值范围。</span><br><span class="line"></span><br><span class="line">数据类型分为两种：基本数据类型（四类八种）、引用数据类型（目前有String和数组）</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">四类</th>
<th align="center">八种</th>
<th align="center">字节数</th>
<th align="center">表示范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整型</td>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">正负3万多</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">*<em>int *</em></td>
<td align="center">4</td>
<td align="center">正负21亿多</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">正负19位数</td>
</tr>
<tr>
<td align="center">布尔型</td>
<td align="center">boolean</td>
<td align="center">1</td>
<td align="center">true, false</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">一个字符’A’，’a’</td>
</tr>
<tr>
<td align="center">浮点型</td>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">正负38位数</td>
</tr>
<tr>
<td align="center">浮点型</td>
<td align="center"><strong>double</strong></td>
<td align="center">8</td>
<td align="center">正负308位数</td>
</tr>
</tbody></table>
<h4 id="13-常量及其分类"><a href="#13-常量及其分类" class="headerlink" title="13. 常量及其分类"></a>13. 常量及其分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量：在程序的执行过程中, 其值不可以发生改变的量</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>整数常量：所有整数</li>
<li>浮点数常量：所有小数</li>
<li>字符常量：被单引号括起来的内容, 里面只能装单个字</li>
<li>字符串常量：被双引号括起来的内容</li>
<li>布尔常量：true、false</li>
<li>空常量：null</li>
</ol>
</blockquote>
<h4 id="14-变量及其定义格式"><a href="#14-变量及其定义格式" class="headerlink" title="14. 变量及其定义格式"></a>14. 变量及其定义格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量：在程序的执行过程中, 其值在某个范围内可以发生改变的量。变量就像一个容器，可以不断修改其中的内容。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>三种定义格式：</strong></p>
<ol>
<li>一步到位 ： <code>int a = 10；</code></li>
<li>分开定义，赋值： <code>int a；</code>   <code>a = 10；</code></li>
<li>简便格式： <code>int a = 10, b = 20, c = 30;</code></li>
</ol>
</blockquote>
<blockquote>
<p><strong>变量需注意的细节：</strong></p>
<ol>
<li>变量不赋值，不能使用</li>
<li>变量名不能重复定义</li>
<li>变量赋值的范围，不能超过数据类型的最大表示范围</li>
<li>变量有作用域，作用域是一对大括号</li>
<li>long类型数据需加上标识L，float类型数据需加上标识F</li>
</ol>
</blockquote>
<h2 id="Day-02-【数据类型转换、运算符、方法入门】"><a href="#Day-02-【数据类型转换、运算符、方法入门】" class="headerlink" title="Day 02 【数据类型转换、运算符、方法入门】"></a>Day 02 【数据类型转换、运算符、方法入门】</h2><h4 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1. 数据类型转换"></a>1. 数据类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换：是程序自动完成的，将小的数据类型转换成大的数据类型</span><br><span class="line"></span><br><span class="line">强制类型转换：需要手动进行转换，将大的数据类型转换成小的数据类型  格式：<span class="keyword">int</span> a = (<span class="keyword">int</span>) <span class="number">10.5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-精度损失和数据溢出"><a href="#2-精度损失和数据溢出" class="headerlink" title="2. 精度损失和数据溢出"></a>2. 精度损失和数据溢出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">精度损失：当一个浮点数转为整数的时候，会发生精度损失，精度损失是直接舍弃小数部分</span><br><span class="line"></span><br><span class="line">数据溢出：当一个表示范围大的数据类型强转为范围小的数据类型的时候，会发生数据溢出，造成部分数据丢失</span><br></pre></td></tr></table></figure>

<h4 id="3-运算时数据类型的转换规则"><a href="#3-运算时数据类型的转换规则" class="headerlink" title="3.  运算时数据类型的转换规则"></a>3.  运算时数据类型的转换规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范围小的类型向范围大的类型提升，<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span> 运算时直接提升为<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span>--&gt;<span class="keyword">int</span>--&gt;<span class="keyword">long</span>--&gt;<span class="keyword">float</span>--&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure>

<h4 id="4-编译器的两点优化"><a href="#4-编译器的两点优化" class="headerlink" title="4.  编译器的两点优化"></a>4.  编译器的两点优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优化一：对于<span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">char</span>三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为</span><br><span class="line">我们补上一个(<span class="keyword">byte</span>)(<span class="keyword">short</span>)(<span class="keyword">char</span>)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> num1 = <span class="comment">/*(byte)*/</span> <span class="number">30</span>; <span class="comment">// 右侧没有超过左侧的范围</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优化二：在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> result = <span class="number">5</span> + <span class="number">8</span>;  <span class="comment">//编译通过</span></span><br><span class="line"><span class="keyword">short</span> result2 = a + <span class="number">8</span>; <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<h4 id="5-加号的三种用法"><a href="#5-加号的三种用法" class="headerlink" title="5. 加号的三种用法"></a>5. 加号的三种用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.数值运算</span><br><span class="line"></span><br><span class="line">2.和char类型参数运算的时候，会将char类型按照ASCII码表，查表找到对应的ASCII值，进行计算</span><br><span class="line"></span><br><span class="line">3.用于字符串拼接，所有的数据类型和字符串进行拼接，都会变成字符串，也要看运算顺序</span><br></pre></td></tr></table></figure>

<h4 id="6-ASCII码表"><a href="#6-ASCII码表" class="headerlink" title="6. ASCII码表"></a>6. ASCII码表</h4><p>美国标准信息交换码(American Standard Code for Information Interchange ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人类定义的一个字符和计算机中二进制存储的对照关系表，是所有编码表的核心。</span><br><span class="line"></span><br><span class="line">编码表本身是字符和一个十进制数进行对应起来组成一张表格，需要记住：&apos;0&apos;-48，&apos;A&apos;-65，&apos;a&apos;-97</span><br></pre></td></tr></table></figure>

<h4 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7. 运算符"></a>7. 运算符</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">算数运算符</td>
<td align="left"><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>++</code>  <code>--</code></td>
</tr>
<tr>
<td align="left">赋值运算符</td>
<td align="left"><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td>
</tr>
<tr>
<td align="left">比较运算符</td>
<td align="left"><code>&gt;</code> <code>&lt;</code> <code>==</code> <code>&gt;=</code> <code>&lt;=</code> <code>!=</code></td>
</tr>
<tr>
<td align="left">逻辑运算符</td>
<td align="left"><code>&amp;</code> `</td>
</tr>
<tr>
<td align="left">三元运算符</td>
<td align="left"><code>数据类型 变量名 = 条件判断？表达式A：表达式B</code></td>
</tr>
</tbody></table>
<blockquote>
<p>运算符注意事项：</p>
<ol>
<li>除法，不会出现小数，会将小数部分舍弃</li>
<li><code>+</code> 符号在遇到字符串的时候，表示<strong>连接、拼接</strong>的含义</li>
<li>比较运算符返回的一定是布尔值true、false</li>
<li>逻辑运算符符号两边一定是布尔值</li>
<li>短路效果：如果已经得到结果，那么不会进行后面的操作（双写<code>&amp;</code> <code>|</code> 得到短路效果）</li>
<li>三元运算符的结果<strong>必须被使用</strong>，必须同时保证表达式A和表达式B都<strong>符合左侧数据类型</strong>的要求。</li>
</ol>
</blockquote>
<h4 id="8-、–的使用场景"><a href="#8-、–的使用场景" class="headerlink" title="8. ++、–的使用场景"></a>8. ++、–的使用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单独操作: 就是自身完成+1或者是-1的动作;</span><br><span class="line"></span><br><span class="line">参数运算：++在前, 先自增, 再赋值；++在后, 先赋值, 再自增。</span><br></pre></td></tr></table></figure>

<h4 id="9-a-1和a-a-1的区别"><a href="#9-a-1和a-a-1的区别" class="headerlink" title="9. a += 1和a = a + 1的区别"></a>9. a += 1和a = a + 1的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += 1 等价于 a = (a的数据类型)(a+1)，当中存在隐含了一个强制类型转换的过程</span><br></pre></td></tr></table></figure>

<h4 id="10-定义方法的好处"><a href="#10-定义方法的好处" class="headerlink" title="10. 定义方法的好处"></a>10. 定义方法的好处</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将代码按照功能进行划分，提高代码的可读性</span><br><span class="line"></span><br><span class="line">2. 提高代码的复用性</span><br></pre></td></tr></table></figure>

<h4 id="11-方法定义和调用的注意事项"><a href="#11-方法定义和调用的注意事项" class="headerlink" title="11. 方法定义和调用的注意事项"></a>11. 方法定义和调用的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 不能嵌套定义，方法中不能定义方法</span><br><span class="line"></span><br><span class="line">2. 方法的执行顺序和定义顺序无关，和调用顺序有关</span><br><span class="line"></span><br><span class="line">3. 方法不调用就不执行,main方法不能人为调用</span><br><span class="line"></span><br><span class="line">4. 在定义方法形式参数的时候,参数需要用逗号隔开</span><br></pre></td></tr></table></figure>

<h2 id="Day-03-【流程控制语句】"><a href="#Day-03-【流程控制语句】" class="headerlink" title="Day 03 【流程控制语句】"></a>Day 03 【流程控制语句】</h2><h4 id="1-if语句的三种格式"><a href="#1-if语句的三种格式" class="headerlink" title="1. if语句的三种格式"></a>1. if语句的三种格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.if--一种情况的判断</span><br><span class="line"></span><br><span class="line">2.if...else两种情况的判断</span><br><span class="line"></span><br><span class="line">3.if...else if...else多种情况判断</span><br></pre></td></tr></table></figure>

<h4 id="2-程序的健壮性"><a href="#2-程序的健壮性" class="headerlink" title="2. 程序的健壮性"></a>2. 程序的健壮性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">健壮性：我们需要尽可能多的考虑程序出现的情况，并给出解决方案</span><br></pre></td></tr></table></figure>

<h4 id="3-switch语句的格式"><a href="#3-switch语句的格式" class="headerlink" title="3. switch语句的格式"></a>3. switch语句的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">"春天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">"夏天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">"秋天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">"冬天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"输入数据超出范围"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>switch语句的注意事项：</strong></p>
<ol>
<li>switch可以接受的4+2种数据类型：4种基本：byte/short/char/int ；  2种引用：String/enum</li>
<li>case后面的表达式不能重复</li>
<li>case语句的穿透效果：没有break会往下穿透</li>
<li>switch语句很灵活，前后顺序可颠倒</li>
</ol>
</blockquote>
<h4 id="4-三种循环语句的格式"><a href="#4-三种循环语句的格式" class="headerlink" title="4. 三种循环语句的格式"></a>4. 三种循环语句的格式</h4><h5 id="（1）for循环"><a href="#（1）for循环" class="headerlink" title="（1）for循环"></a>（1）for循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式： <span class="keyword">for</span>(初始化语句;条件判断语句;步进语句)&#123;</span><br><span class="line">		循环体;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">示例：	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">		sop(i);	</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）while循环"><a href="#（2）while循环" class="headerlink" title="（2）while循环"></a>（2）while循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：   初始化语句;</span><br><span class="line">		<span class="keyword">while</span>(条件判断语句)&#123;</span><br><span class="line">		循环体;</span><br><span class="line">		步进语句;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">示例：	  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">  		  sop(i);</span><br><span class="line">          i++;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（3）do-while循环"><a href="#（3）do-while循环" class="headerlink" title="（3）do..while循环"></a>（3）do..while循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：	  初始化语句;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			循环体;</span><br><span class="line">			步进语句;</span><br><span class="line">		&#125;<span class="keyword">while</span>(条件判断语句);</span><br><span class="line"></span><br><span class="line">示例：   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">   			 sop(i);</span><br><span class="line">    		 i++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(i &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="5-三种循环语句的区别"><a href="#5-三种循环语句的区别" class="headerlink" title="5. 三种循环语句的区别"></a>5. 三种循环语句的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. for循环的初始化表达式出了循环不能使用，while循环可以使用</span><br><span class="line"></span><br><span class="line">2. for循环和while循环条件不满足，一次不会执行；do...while循环无论如何执行一次</span><br><span class="line"></span><br><span class="line">3. 当已知循环次数的情况下，建议使用for循环，不知道次数建议使用while循环</span><br></pre></td></tr></table></figure>

<h4 id="6-break和continue"><a href="#6-break和continue" class="headerlink" title="6. break和continue"></a>6. break和continue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">break：在switch语句中，表示遇到break，switch语句结束；在循环语句中，表示跳出循环，继续往下执行代码</span><br><span class="line"></span><br><span class="line">continue：结束本次循环，进入下一次循环</span><br></pre></td></tr></table></figure>

<h4 id="7-死循环的格式"><a href="#7-死循环的格式" class="headerlink" title="7. 死循环的格式"></a>7. 死循环的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;);</span><br></pre></td></tr></table></figure>

<h2 id="Day-04-【Idea、方法】"><a href="#Day-04-【Idea、方法】" class="headerlink" title="Day 04 【Idea、方法】"></a>Day 04 【Idea、方法】</h2><h4 id="1-什么是方法"><a href="#1-什么是方法" class="headerlink" title="1. 什么是方法"></a>1. 什么是方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法就是经常使用的一部分代码抽取成的代码块</span><br><span class="line"></span><br><span class="line">方法可以理解为工厂，给方法一些参数，方法换给我们一个结果</span><br><span class="line"></span><br><span class="line">方法可以理解为模板，方法是写的通用的逻辑，可以重复调用多次，根据传入的参数不同，返回的结果也不同</span><br></pre></td></tr></table></figure>

<h4 id="2-方法的定义格式"><a href="#2-方法的定义格式" class="headerlink" title="2. 方法的定义格式"></a>2. 方法的定义格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符  返回值类型  方法名（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">	方法体；</span><br><span class="line"></span><br><span class="line">	return  (返回值）；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-return的作用"><a href="#3-return的作用" class="headerlink" title="3. return的作用"></a>3. return的作用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将返回值返回给方法的调用处</span><br><span class="line"></span><br><span class="line">2. 结束方法</span><br></pre></td></tr></table></figure>

<h4 id="4-方法的调用的方式"><a href="#4-方法的调用的方式" class="headerlink" title="4.方法的调用的方式"></a>4.方法的调用的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 单独调用：适用于有返回值的和无返回值的方法，有返回值的方法单独调用没有意义</span><br><span class="line"></span><br><span class="line">2. 打印调用：只适用于有返回值的方法，打印调用返回值结果只能使用一次</span><br><span class="line"></span><br><span class="line">3. 赋值调用：只适用于有返回值的方法，返回值使用变量接收，可以使用多次</span><br></pre></td></tr></table></figure>

<h4 id="5-方法的执行流程"><a href="#5-方法的执行流程" class="headerlink" title="5. 方法的执行流程"></a>5. 方法的执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 以main方法为起点，虚拟机调用main方法，main方法中调用其他方法</span><br><span class="line"></span><br><span class="line">2. 调用方法，传递参数</span><br><span class="line"></span><br><span class="line">3. 将传递的实参给方法中定义的形参进行赋值 ，执行方法体</span><br><span class="line"></span><br><span class="line">4. 使用return语句将返回值，返回给方法的调用处</span><br></pre></td></tr></table></figure>

<h4 id="6-方法的三要素"><a href="#6-方法的三要素" class="headerlink" title="6. 方法的三要素"></a>6. 方法的三要素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 返回值类型：看需求，说是想让你给出结果，还是直接在方法中打印</span><br><span class="line"></span><br><span class="line">2. 参数列表：看该方法完成任务，需不需要外部提供的参数</span><br><span class="line"></span><br><span class="line">3. 方法名：小驼峰命名规则，见名知意</span><br></pre></td></tr></table></figure>

<h4 id="7-方法的重载"><a href="#7-方法的重载" class="headerlink" title="7. 方法的重载"></a>7. 方法的重载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法的重载：是指方法名称相同，但参数列表不同的一组方法。用户希望相似的功能，只需要记一个方法名称。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法重载的三个相关</strong>：</p>
<ol>
<li>参数列表的个数</li>
<li>参数列表的数据类型</li>
<li>参数列表的参数顺序</li>
</ol>
</blockquote>
<blockquote>
<p><strong>方法重载的三个无关：</strong></p>
<ol>
<li>和参数的变量名称无关</li>
<li>和方法的返回值类型无关</li>
<li>和方法的修饰符无关</li>
</ol>
</blockquote>
<h4 id="8-IDEA-常用快捷键"><a href="#8-IDEA-常用快捷键" class="headerlink" title="8. IDEA 常用快捷键"></a>8. IDEA 常用快捷键</h4><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>调出结果窗口</td>
<td>Alt + 4</td>
</tr>
<tr>
<td>自动导包+修正代码</td>
<td>Alt + Enter</td>
</tr>
<tr>
<td>删除光标所在行</td>
<td>Ctrl + Y</td>
</tr>
<tr>
<td>往下复制一行</td>
<td>Ctrl + D</td>
</tr>
<tr>
<td>格式化代码</td>
<td>Ctrl + Alt + L</td>
</tr>
<tr>
<td>自动生成常用方法</td>
<td>Alt + Insert</td>
</tr>
<tr>
<td>移动当前代码行</td>
<td>Alt + Shift + 上下箭头</td>
</tr>
<tr>
<td>选中一个变量的所有使用处</td>
<td>Shift + F6</td>
</tr>
<tr>
<td>快速生成for循环</td>
<td>XXX.fori</td>
</tr>
</tbody></table>
<h2 id="Day-05-【数组】"><a href="#Day-05-【数组】" class="headerlink" title="Day 05 【数组】"></a>Day 05 【数组】</h2><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1. 什么是数组"></a>1. 什么是数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是Java中的一种容器，用于存储数据</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>数组中存储的数据类型一致</li>
<li>数组是引用数据类型</li>
<li>数组的长度一旦确定，不可改变</li>
</ol>
</blockquote>
<h4 id="2-数组的初始化"><a href="#2-数组的初始化" class="headerlink" title="2. 数组的初始化"></a>2. 数组的初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">动态初始化：<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">静态初始化：<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">静态初始化的省略格式：<span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">动态初始化的拆分：</span><br><span class="line"><span class="keyword">int</span>[] array;  </span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">静态初始化拆分：</span><br><span class="line"><span class="keyword">int</span>[] array;  </span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">(拆分后不能使用省略格式进行初始化：array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引就是数组元素的编号，从0开始，到length-1为止</span><br></pre></td></tr></table></figure>

<blockquote>
<p>赋值：数组名[索引值] = 值；</p>
<p>访问：数据类型 变量名 = 数组名[索引值]；</p>
</blockquote>
<h4 id="4-Java内存的5个组成部分"><a href="#4-Java内存的5个组成部分" class="headerlink" title="4. Java内存的5个组成部分"></a>4. Java内存的5个组成部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.栈(Stack)：方法运行时使用的内存，比如main方法运行，进入方法栈中执行，存放方法中的局部变量。</span><br><span class="line">2.堆(Heap)：存储对象或者数组，new来创建的，都存储在堆内存</span><br><span class="line">3.方法区(Method Area)：存储可以运行的class文件</span><br><span class="line">4.本地方法栈(Native Method Stack)：JVM在使用操作系统功能的时候使用，和开发无关</span><br><span class="line">5.寄存器(pc Register)：与CPU相关，性能极高，和开发无关</span><br></pre></td></tr></table></figure>

<h4 id="5-数组越界索引异常"><a href="#5-数组越界索引异常" class="headerlink" title="5. 数组越界索引异常"></a>5. 数组越界索引异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统访问了数组中不存在的索引，将抛出数组越界索引异常。</span><br><span class="line">(ArrayIndexOutOfBoundsException)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-数组空指针异常"><a href="#6-数组空指针异常" class="headerlink" title="6. 数组空指针异常"></a>6. 数组空指针异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给数组赋值null之后，数组将不会保存数组的内存地址，也不允许再操作数组了，运行时会抛出空指针异常。</span><br><span class="line">(NullPointerException)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	arr = <span class="keyword">null</span>;</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h4 id="7-方法的参数类型区别"><a href="#7-方法的参数类型区别" class="headerlink" title="7. 方法的参数类型区别"></a>7. 方法的参数类型区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法的参数为基本类型时,传递的是数据值，值不会受到影响；方法的参数为引用类型时,传递的是地址值，所以在方法中</span><br><span class="line"></span><br><span class="line">将引用数据类型中的值进行修改，那么会永久性的修改</span><br></pre></td></tr></table></figure>

<h4 id="8-数组的直接打印"><a href="#8-数组的直接打印" class="headerlink" title="8. 数组的直接打印"></a>8. 数组的直接打印</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接打印数组名称，得到的是数组对应的内存地址哈希值</span><br><span class="line">[I@7575412c2f  </span><br><span class="line">其中[代表数组，I代表int</span><br></pre></td></tr></table></figure>

<h4 id="9-数组的内存执行流程"><a href="#9-数组的内存执行流程" class="headerlink" title="9. 数组的内存执行流程"></a>9. 数组的内存执行流程</h4><blockquote>
<ol>
<li>编写代码，编译代码，生成.class字节码文件</li>
<li>字节码文件，将信息加载到方法区中，方法区中有类的方法信息</li>
<li>JVM虚拟机去找程序的入口——main方法</li>
<li>main方法进栈执行</li>
<li>main方法中定义的变量，会在栈内存中生成</li>
<li>在堆内存中，开辟了一块空间，将空间中的数值赋默认值，JVM将数组的内存地址赋值给引用类型变量</li>
<li>打印数组名称，找到堆内存中的地址值.</li>
<li>先通过数组名找到堆内存中的地址值，然后通过索引值找到对应的数据值，在数据值进行修改</li>
<li>main方法会出栈/弹栈</li>
<li>堆内存中的两块区域，没有变量去引用了，堆内存中的内容会被JVM垃圾回收机制回收</li>
</ol>
</blockquote>
<h4 id="10-数组的反转"><a href="#10-数组的反转" class="headerlink" title="10. 数组的反转"></a>10. 数组的反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">	<span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">		<span class="keyword">int</span> temp = arr[min];</span><br><span class="line">		arr[min] = arr[max];</span><br><span class="line">		arr[max] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 反转后，遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		System.out.println(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day-06-【类与对象、封装、构造方法】"><a href="#Day-06-【类与对象、封装、构造方法】" class="headerlink" title="Day 06 【类与对象、封装、构造方法】"></a>Day 06 【类与对象、封装、构造方法】</h2><h4 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就是当我们需要做一件事情的时候，不是去自己亲力亲为的考虑每一个细节，而是找到能做这件事情的人，帮我们做事</span><br><span class="line"></span><br><span class="line">在代码中，就是找到能完成这个功能的类，并调用这个类中的方法。</span><br></pre></td></tr></table></figure>

<h4 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2. 类与对象"></a>2. 类与对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类：是一个模板，描述了现实事物的信息</span><br><span class="line"></span><br><span class="line">对象：是根据类这个模板生成的一个实体，会在堆内存中开辟空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类是对象的模板，对象是类的实体</p>
</blockquote>
<h4 id="3-类描述的信息"><a href="#3-类描述的信息" class="headerlink" title="3. 类描述的信息"></a>3. 类描述的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性：事物具备什么特征，在代码中叫做成员变量</span><br><span class="line"></span><br><span class="line">行为：事物能做什么事情，在代码中叫做成员方法</span><br></pre></td></tr></table></figure>

<h4 id="4-对象的使用方式"><a href="#4-对象的使用方式" class="headerlink" title="4. 对象的使用方式"></a>4. 对象的使用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">导包：通常不用考虑，IDEA会进行自动导包</span><br><span class="line"></span><br><span class="line">创建对象：根据类生成一个对象实例</span><br><span class="line"></span><br><span class="line">使用：给对象中的成员变量进行赋值，调用方法</span><br></pre></td></tr></table></figure>

<h4 id="5-成员变量和局部变量区别"><a href="#5-成员变量和局部变量区别" class="headerlink" title="5. 成员变量和局部变量区别"></a>5. 成员变量和局部变量区别</h4><table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中位置</td>
<td>类中，方法外</td>
<td>方法内</td>
</tr>
<tr>
<td>作用范围</td>
<td>类中</td>
<td>方法中</td>
</tr>
<tr>
<td>初始化值</td>
<td>有默认值</td>
<td>无默认值</td>
</tr>
<tr>
<td>内存中位置</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期</td>
<td>随着对象存在</td>
<td>随着方法存在</td>
</tr>
</tbody></table>
<h4 id="6-封装"><a href="#6-封装" class="headerlink" title="6. 封装"></a>6. 封装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就是将细节隐藏起来，对外只暴露实现方式</span><br><span class="line"></span><br><span class="line">（1）方法是一种封装</span><br><span class="line"></span><br><span class="line">（2）private关键字也是一种封装</span><br></pre></td></tr></table></figure>

<h4 id="7-private关键字"><a href="#7-private关键字" class="headerlink" title="7. private关键字"></a>7. private关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将成员变量私有，只允许本类访问，不允许外界访问，对外提供Getter/Setter方法</span><br></pre></td></tr></table></figure>

<h4 id="8-this关键字"><a href="#8-this关键字" class="headerlink" title="8. this关键字"></a>8. this关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this代表所在类的当前对象的引用（地址值），即对象自己的引用。</span><br><span class="line"></span><br><span class="line">方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</span><br></pre></td></tr></table></figure>

<h4 id="9-成员变量的默认值"><a href="#9-成员变量的默认值" class="headerlink" title="9. 成员变量的默认值"></a>9. 成员变量的默认值</h4><table>
<thead>
<tr>
<th></th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>整数</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>浮点数</td>
<td>0.0</td>
</tr>
<tr>
<td></td>
<td>字符</td>
<td>‘/u0000’</td>
</tr>
<tr>
<td></td>
<td>布尔</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>数组，类，接口</td>
<td>null</td>
</tr>
</tbody></table>
<h4 id="10-构造方法注意事项"><a href="#10-构造方法注意事项" class="headerlink" title="10. 构造方法注意事项"></a>10. 构造方法注意事项</h4><blockquote>
<ol>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果你不提供构造方法，系统会给出无参数构造方法。</li>
<li>如果你提供了构造方法，系统将不再提供无参数构造方法。</li>
<li>构造方法是可以重载的，既可以定义参数，也可以不定义参数。</li>
</ol>
</blockquote>
<h4 id="11-标准代码——JavaBean"><a href="#11-标准代码——JavaBean" class="headerlink" title="11. 标准代码——JavaBean"></a>11. 标准代码——JavaBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-对象的内存图流程"><a href="#12-对象的内存图流程" class="headerlink" title="12. 对象的内存图流程"></a>12. 对象的内存图流程</h4><blockquote>
<ol>
<li>方法区加载类的方法信息</li>
<li>JVM去找main方法，main方法进栈执行</li>
<li>在栈内存中生成一个变量Phone one，在堆内存中开辟一块空间，内含成员变量和成员方法</li>
<li>对成员变量进行赋值</li>
<li>调用成员方法，方法进栈执行，执行完毕之后，方法出栈</li>
<li>最后main方法出栈</li>
<li>垃圾回收机制回收堆内存中的两块区域</li>
</ol>
</blockquote>
<h2 id="Day-07【Scanner类、Random类、ArrayList类】"><a href="#Day-07【Scanner类、Random类、ArrayList类】" class="headerlink" title="Day 07【Scanner类、Random类、ArrayList类】"></a>Day 07【Scanner类、Random类、ArrayList类】</h2><h4 id="1-API的使用方式"><a href="#1-API的使用方式" class="headerlink" title="1. API的使用方式"></a>1. API的使用方式</h4><blockquote>
<p>（Application Programming Interface） 应用程序编程接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）看包路径 --&gt;导包</span><br><span class="line"></span><br><span class="line">（2）构造方法--&gt;创建</span><br><span class="line"></span><br><span class="line">（3）成员方法--&gt;使用</span><br></pre></td></tr></table></figure>

<h4 id="2-Scanner类使用步骤"><a href="#2-Scanner类使用步骤" class="headerlink" title="2. Scanner类使用步骤"></a>2. Scanner类使用步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">sc.nextInt();录入整数</span><br><span class="line"></span><br><span class="line">sc.next();录入字符串，不含空格，Tab。有效字符之前的空格、Tab被视为无效；之后的空格、Tab视为结束符号</span><br><span class="line"></span><br><span class="line">sc.nextLine();可以包含空格和Tab,只以回车为结束符号</span><br></pre></td></tr></table></figure>

<h4 id="3-Random类使用步骤"><a href="#3-Random类使用步骤" class="headerlink" title="3. Random类使用步骤"></a>3. Random类使用步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random ran = new Random();</span><br><span class="line"></span><br><span class="line">ran.nextInt()；生成一个int范围的随机数</span><br><span class="line"></span><br><span class="line">生成(a~b)范围的随机数: ran.nextInt(b-a+1)+a</span><br></pre></td></tr></table></figure>

<h4 id="4-匿名对象"><a href="#4-匿名对象" class="headerlink" title="4. 匿名对象"></a>4. 匿名对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匿名对象就是没有变量名接受的对象，new  类名（）；</span><br><span class="line"></span><br><span class="line">优点：省略变量名，减少代码的编写</span><br><span class="line"></span><br><span class="line">缺点：对象只能使用一次</span><br></pre></td></tr></table></figure>

<h4 id="5-数组与集合的不同"><a href="#5-数组与集合的不同" class="headerlink" title="5. 数组与集合的不同"></a>5. 数组与集合的不同</h4><table>
<thead>
<tr>
<th align="left"></th>
<th>数组</th>
<th align="left">集合</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行期间长度</td>
<td>不可变</td>
<td align="left">可变</td>
</tr>
<tr>
<td align="left">存储数据类型</td>
<td>基本+引用数据类型</td>
<td align="left">引用数据类型</td>
</tr>
<tr>
<td align="left">直接打印</td>
<td>地址值</td>
<td align="left">集合的内容</td>
</tr>
<tr>
<td align="left">可操作方法</td>
<td>查、改</td>
<td align="left">增、删、改、查</td>
</tr>
<tr>
<td align="left">获取长度</td>
<td>数组名.length</td>
<td align="left">集合名称.size()</td>
</tr>
</tbody></table>
<h4 id="6-ArrayList类"><a href="#6-ArrayList类" class="headerlink" title="6. ArrayList类"></a>6. ArrayList类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList集合是Java中的一种容器，底层是数组，默认初始长度是10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<ol>
<li>长度是可变的</li>
<li>只能存储引用数据类型，如果想存储基本数据类型，要使用其包装类</li>
<li>直接打印显示的是集合的内容</li>
</ol>
</blockquote>
<h4 id="7-ArrayList中的常用方法"><a href="#7-ArrayList中的常用方法" class="headerlink" title="7. ArrayList中的常用方法"></a>7. ArrayList中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>：向集合当中添加元素，参数的类型和泛型一致，返回值是<span class="title">boolean</span><span class="params">(Always <span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>: 用指定的元素替代此列表中指定位置上的元素,返回被替代的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 获取集合的尺寸长度，返回值就是集合中包含的元素个数</span></span><br></pre></td></tr></table></figure>

<h4 id="8-包装类"><a href="#8-包装类" class="headerlink" title="8. 包装类"></a>8. 包装类</h4><table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">基本类型包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<blockquote>
<p>自动装箱：基本类型 –&gt;包装类型<br>自动拆箱：包装类型 –&gt;基本类型</p>
</blockquote>
<h2 id="Day-08【String类、static关键字、Arrays类、Math类】"><a href="#Day-08【String类、static关键字、Arrays类、Math类】" class="headerlink" title="Day 08【String类、static关键字、Arrays类、Math类】"></a>Day 08【String类、static关键字、Arrays类、Math类】</h2><h4 id="1-String类的三个特点"><a href="#1-String类的三个特点" class="headerlink" title="1. String类的三个特点"></a>1. String类的三个特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 字符串不变：字符串的值在创建后不能被更改。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 因为String对象是不可变的，所以它们可以被共享。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. <span class="string">"abc"</span> 等效于 <span class="keyword">char</span>[] data=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;，底层原理是<span class="keyword">byte</span>[]字节数组。</span><br></pre></td></tr></table></figure>

<h4 id="2-创建字符串的1-3种方法"><a href="#2-创建字符串的1-3种方法" class="headerlink" title="2. 创建字符串的1+3种方法"></a>2. 创建字符串的1+3种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一种直接创建：直接写上双引号，就是字符串对象</span><br><span class="line"></span><br><span class="line">三种构造方法：</span><br><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>：初始化新创建的 String对象，以使其表示空字符序列</span></span><br><span class="line"><span class="function">2. <span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] array)</span>：根据字符数组的内容，来创建对应的字符串</span></span><br><span class="line"><span class="function">3. <span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] array)</span>：根据字节数组的内容，来创建对应的字符串</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串常量池：直接写“ ”的字符串，在常量池中，如果常量池中有相同的字符串，那么不会创建新的，而是使用以前的。双引号直接写的字符串在常量池当中，new出来的不在池当中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Java"</span>;</span><br><span class="line">        String s2 = <span class="string">"Java"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'J'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(chars);</span><br><span class="line">        System.out.println(<span class="string">"s1和s2是否直接相等"</span> + (s1 == s2));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">"s1和s3是否直接相等"</span> + (s1 == s3));	 <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-String常用方法"><a href="#3-String常用方法" class="headerlink" title="3.String常用方法"></a>3.String常用方法</h4><h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span>：将此字符串与指定对象进行比较。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：将此字符串与指定对象进行比较，忽略大小写。</span></span><br></pre></td></tr></table></figure>

<h5 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span> ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span> ：将指定的字符串连接到该字符串的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span> <span class="params">(<span class="keyword">int</span> index)</span> ：返回指定索引处的 <span class="keyword">char</span>值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span> ：返回指定子字符串第一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> begin)</span> ：返回一个子字符串，从begin开始截取字符串到字符串结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> ：返回一个子字符串，从[begin,end)截取字符串。</span></span><br></pre></td></tr></table></figure>

<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray () ：将此字符串转换为新的字符数组。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span> ：将与target匹配的字符串使用replacement字符串替换。</span></span><br></pre></td></tr></table></figure>

<h5 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String可以比，接，截，割，替，从内容获取索引，从索引获取内容</p>
<p>equal, concat, substring, split, replace, indexof, charAt</p>
</blockquote>
<h4 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4. 正则表达式"></a>4. 正则表达式</h4><blockquote>
<p>正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">字符 x</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">反斜线字符</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="center">a、b 或 c（简单类）</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="center">任何字符，除了 a、b 或 c（否定）</td>
</tr>
<tr>
<td align="center">[a-zA-Z]</td>
<td align="center">a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">单词字符：[a-zA-Z_0-9]</td>
</tr>
<tr>
<td align="center">X?</td>
<td align="center">X，一次或一次也没有</td>
</tr>
<tr>
<td align="center">X*</td>
<td align="center">X，零次或多次</td>
</tr>
<tr>
<td align="center">X+</td>
<td align="center">X，一次或多次</td>
</tr>
<tr>
<td align="center">X{n}</td>
<td align="center">X，恰好 n 次</td>
</tr>
<tr>
<td align="center">X{n,}</td>
<td align="center">X，至少 n 次</td>
</tr>
<tr>
<td align="center">X{n,m}</td>
<td align="center">X，至少 n 次，但是不超过 m 次</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">匹配输入的行首</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">匹配输入的行尾</td>
</tr>
</tbody></table>
<h4 id="5-static关键字"><a href="#5-static关键字" class="headerlink" title="5. static关键字"></a>5. static关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>关键字可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。</span><br><span class="line"></span><br><span class="line">也就是说，既然属于类，就可以不靠创建对象来调用了。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态存储在方法区中，既不在堆中，也不在栈中（方法中有一块独立的静态区）</p>
</blockquote>
<h5 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。</span><br><span class="line"></span><br><span class="line">任何对象都可以更改该类变量的值，也可以在不创建该类的对象的情况下对类变量进行操作。</span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当static修饰成员方法时，该方法称为类方法,习惯称为静态方法。建议使用类名来调用，而不需要创建类的对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>静态方法调用的注意事项：</strong></p>
<ol>
<li>静态方法可以直接访问类变量和静态方法。</li>
<li>静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。</li>
<li>静态方法中，不能使用this关键字。</li>
</ol>
</blockquote>
<h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类中方法外，使用static修饰的代码块&#123; &#125;。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当第一次用到本类时，静态代码块执行唯一的一次，优先于main方法和构造方法的执行。</p>
<p>作用：给类变量进行初始化赋值。</p>
</blockquote>
<h4 id="6-Arrays类"><a href="#6-Arrays类" class="headerlink" title="6. Arrays类"></a>6. Arrays类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> ：返回指定数组内容的字符串表示形式。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> ：对指定的 <span class="keyword">int</span> 型数组按数字升序进行排序。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[2, 4, 8, 9, 34, 35, 69, 657]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：如果是数值，sort方法默认按照升序从小到大<br>如果是字符串，sort方法默认按照字母升序<br>如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序法代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>] ; j--) &#123;</span><br><span class="line">                 <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">       			 arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">      			 arr[j-<span class="number">1</span>] = temp;&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-Math类"><a href="#7-Math类" class="headerlink" title="7. Math类"></a>7. Math类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span>：获取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span>：向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span>：向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span>：四舍五入</span></span><br></pre></td></tr></table></figure>

<h2 id="Day-09【继承、super、this、抽象类】"><a href="#Day-09【继承、super、this、抽象类】" class="headerlink" title="Day 09【继承、super、this、抽象类】"></a>Day 09【继承、super、this、抽象类】</h2><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。</span><br><span class="line"></span><br><span class="line">子类可以直接访问父类中的非私有的属性和行为。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>语法格式</strong>：子类 extends 父类</p>
<p><strong>继承的作用</strong>：提高代码复用性，类与类之间产生了关系，是多态的前提。</p>
<p><strong>继承的特点：</strong></p>
<ol>
<li>一个子类只能有一个直接父类，不能有多个直接父类</li>
<li>继承可以支持多级继承，一个子类只能有一个直接父类，但可以有多个间接父类</li>
<li>一个父类可以有多个子类</li>
</ol>
</blockquote>
<h4 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对子类共性的内容进行抽取，有可能包含抽象方法的类</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>语法格式：</strong>abstract关键字</p>
<p><strong>抽象类的作用：</strong></p>
<ol>
<li>为子类提供便利：抽象类中可以定义一些方法，子类继承之后可以直接使用</li>
<li>对子类进行约束：抽象类中的抽象方法，子类继承之后，必须重写，否则子类也是一个抽象类</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>抽象类不能创建对象，如果要创建，需要创建的是子类（抽象类的对象调用方法无方法体，无意义）</li>
<li>抽象类中可以包含构造方法，用于初始化父类成员</li>
<li>抽象类中可以没有抽象方法，但是只要类中有抽象方法，那这个类一定是一个抽象类</li>
<li>子类继承抽象类必须重写全部抽象方法，否则该子类也是一个抽象类</li>
</ol>
</blockquote>
<h4 id="3-继承后的特点"><a href="#3-继承后的特点" class="headerlink" title="3. 继承后的特点"></a>3. 继承后的特点</h4><h5 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用super关键字区分</span><br></pre></td></tr></table></figure>

<h5 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法重写的注意事项：</strong></p>
<ol>
<li>必须保证父子类之间方法的名称相同，参数列表也相同。</li>
<li>@Override:写在方法前面，用来检测是不是有效的正确覆盖重写，也可以不写。</li>
<li>子类方法的返回值必须【小于等于】父类方法返回值的范围。</li>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符。</li>
</ol>
<p>备注：public &gt; protected &gt;(default) &gt; private，（default）不是关键字，是什么都不写，留空。</p>
</blockquote>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><blockquote>
<p><strong>构造方法注意事项：</strong></p>
<ol>
<li>子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。</li>
<li>子类构造可以通过super关键字来调用父类重载构造。</li>
<li>super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li>
</ol>
</blockquote>
<h4 id="4-super关键字的三种用法"><a href="#4-super关键字的三种用法" class="headerlink" title="4. super关键字的三种用法"></a>4. super关键字的三种用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）在子类的成员方法中，访问父类的成员变量</span><br><span class="line"></span><br><span class="line">（2）在子类的成员方法中，访问父类的成员方法</span><br><span class="line"></span><br><span class="line">（3）在子类的构造方法中，访问父类的构造方法</span><br></pre></td></tr></table></figure>

<h4 id="5-this关键字的三种用法"><a href="#5-this关键字的三种用法" class="headerlink" title="5. this关键字的三种用法"></a>5. this关键字的三种用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）在本类的成员方法中，访问本类的成员变量</span><br><span class="line"></span><br><span class="line">（2）在本类的成员方法中，访问本类的成员方法</span><br><span class="line"></span><br><span class="line">（3）在本类的构造方法中，访问本类的另一种重载的构造方法</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</p>
</blockquote>
<h2 id="Day-10【接口、多态】"><a href="#Day-10【接口、多态】" class="headerlink" title="Day 10【接口、多态】"></a>Day 10【接口、多态】</h2><h4 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1. 接口的定义"></a>1. 接口的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口，是Java语言中一种引用类型，是方法的集合，使用<span class="class"><span class="keyword">interface</span>关键字，是一种公共的规范标准。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用：（1）提供功能的拓展（2）提出约束</p>
<p>定义格式：public interface   接口名称{接口内容}</p>
<p>注意：接口也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
</blockquote>
<h4 id="2-接口包含的内容"><a href="#2-接口包含的内容" class="headerlink" title="2. 接口包含的内容"></a>2. 接口包含的内容</h4><h5 id="常量（Java-7）"><a href="#常量（Java-7）" class="headerlink" title="常量（Java 7）"></a>常量（Java 7）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口当中也可以定义“成员变量”，但是必须使用<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>三个关键字进行修饰。</span><br><span class="line"></span><br><span class="line">一旦赋值，不可以修改，从效果上看，这其实就是接口的【常量】。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<ol>
<li>三个修饰符可以省略，但是不写也默认有</li>
<li>接口当中的常量，必须进行赋值；不能不赋值。</li>
<li>接口中常量的名称，使用完全大写的字母，用下划线进行分割：</li>
</ol>
<p><code>public static final int NUM_OF_PEOPLE = 10</code>;</p>
</blockquote>
<h5 id="抽象方法（Java-7）"><a href="#抽象方法（Java-7）" class="headerlink" title="抽象方法（Java 7）"></a>抽象方法（Java 7）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  返回值  方法名称（参数列表）;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>public abstract 可以省略不写</p>
</blockquote>
<h5 id="默认方法-Java-8"><a href="#默认方法-Java-8" class="headerlink" title="默认方法(Java 8)"></a>默认方法(Java 8)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口中的默认方法用于接口的升级和修改，可以保证所有的实现类不必被强制要求重写抽象方法。</p>
<p>如果重写使用重写的方法，如果不重写使用默认方法。</p>
</blockquote>
<h5 id="静态方法-Java-8"><a href="#静态方法-Java-8" class="headerlink" title="静态方法(Java 8)"></a>静态方法(Java 8)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不能通过接口实现类的对象来调用接口当中的静态方法！因为一个实现类可能实现多个接口，通过对象调用接口的静态方法有可能方法名重复导致冲突。正确用法：通过接口名称，直接调用其中的静态方法。</p>
</blockquote>
<h5 id="私有方法-Java-9"><a href="#私有方法-Java-9" class="headerlink" title="私有方法(Java 9)"></a>私有方法(Java 9)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）普通私有方法：<span class="keyword">private</span>  返回值  方法名称（参数列表）&#123;&#125;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）静态私有方法：<span class="keyword">private</span> <span class="keyword">static</span>   返回值  方法名称（参数列表）&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决多个默认方法和静态方法代码重复度过高问题，同时避免该方法被接口的实现类使用。</p>
<p>从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。</p>
</blockquote>
<h4 id="3-接口的多实现"><a href="#3-接口的多实现" class="headerlink" title="3. 接口的多实现"></a>3. 接口的多实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个类可以实现多个接口</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li>有多个<strong>抽象方法</strong>时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</li>
<li>有多个<strong>默认方法</strong>时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。</li>
<li>存在同名的<strong>静态方法</strong>并不会冲突，原因是只能通过各自接口名访问静态方法。</li>
<li>当一个类既继承一个父类，又实现若干个接口时，<strong>父类中的成员方法</strong>与接口中的默认方法重名，子类就近</li>
</ol>
<p>选择执行父类的成员方法。</p>
</blockquote>
<h4 id="4-接口的特点"><a href="#4-接口的特点" class="headerlink" title="4. 接口的特点"></a>4. 接口的特点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 一个接口能继承另一个或者多个接口，使用 extends 关键字，子接口继承父接口的方法。</span><br><span class="line"></span><br><span class="line">2. 如果父接口中的默认方法有重名的，那么子接口需要重写一次。</span><br><span class="line"></span><br><span class="line">3. 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</span><br><span class="line"></span><br><span class="line">4. 接口中，没有构造方法，不能创建对象。</span><br><span class="line"></span><br><span class="line">5. 接口中，没有静态代码块。</span><br></pre></td></tr></table></figure>

<h4 id="5-多态"><a href="#5-多态" class="headerlink" title="5. 多态"></a>5. 多态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类引用指向子类对象，一个对象的多种形态</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>多态使用的前提条件</strong>：必须以继承或者实现为前提条件（用父类或者接口去接收对象都行）</p>
<p><strong>多态的表现形式：</strong>父类类型  变量名 = new  子类（）;     接口类型  变量名 = new 实现类（）;</p>
</blockquote>
<h4 id="6-多态成员的访问"><a href="#6-多态成员的访问" class="headerlink" title="6. 多态成员的访问"></a>6. 多态成员的访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">多态成员变量的访问方式：编译看左边，运行也看左边</span><br><span class="line"></span><br><span class="line">（1）直接访问：看等号左边是谁就优先用谁，没有向上找</span><br><span class="line"></span><br><span class="line">（2）间接访问：方法属于谁，就优先用谁，没有向上找</span><br><span class="line"></span><br><span class="line">多态成员方法的访问方式：编译看左边，运行看右边</span><br><span class="line"></span><br><span class="line">看等号右边对象创建的是谁，就优先用谁，没有向上找</span><br></pre></td></tr></table></figure>

<h4 id="7-多态的好处和弊端"><a href="#7-多态的好处和弊端" class="headerlink" title="7. 多态的好处和弊端"></a>7. 多态的好处和弊端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好处：提高代码复用性</span><br><span class="line"></span><br><span class="line">弊端：不能使用子类独有的方法</span><br></pre></td></tr></table></figure>

<h4 id="8-引用、对象、对象名称的区分"><a href="#8-引用、对象、对象名称的区分" class="headerlink" title="8. 引用、对象、对象名称的区分"></a>8. 引用、对象、对象名称的区分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Animal a = new Cat();</span><br><span class="line"></span><br><span class="line">引用：等号左侧的数据类型叫引用（Animal）</span><br><span class="line"></span><br><span class="line">对象：等号右边new的就是对象（new Cat()）</span><br><span class="line"></span><br><span class="line">对象名称：变量名称就叫对象名称（a）</span><br></pre></td></tr></table></figure>

<h4 id="9-向上转型和向下转型"><a href="#9-向上转型和向下转型" class="headerlink" title="9. 向上转型和向下转型"></a>9. 向上转型和向下转型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">向上转型：向上转型一定是安全的，因为左父右子，从小范围转向了大范围 </span><br><span class="line"></span><br><span class="line">向下转型：子类类型  变量名 = （子类类型）父类对象；不安全</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的向下转型，其实是一个【还原】的动作。由哪个子类转成的父类类型，再转回去要注意，不能转为其</p>
<p>他子类类型，否则会报错。(ClassCastException)</p>
</blockquote>
<h4 id="10-instanceof-关键字"><a href="#10-instanceof-关键字" class="headerlink" title="10. instanceof 关键字"></a>10. instanceof 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line"></span><br><span class="line">如果变量属于该数据类型，返回<span class="keyword">true</span>；如果变量不属于该数据类型，返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>instanceof 可用于判断对象属于哪一个实例，一般都在方法中使用。</p>
<p>对传入的父类类型的对象进行实例判断，强转回子类，目的是调用子类特有的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 向上转型</span></span><br><span class="line">		Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">		<span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">			Cat c = (Cat)a;</span><br><span class="line">			c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">			Dog d = (Dog)a;</span><br><span class="line">			d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br></pre></td></tr></table></figure>

<h2 id="Day-11【final、权限、内部类、引用类型】"><a href="#Day-11【final、权限、内部类、引用类型】" class="headerlink" title="Day 11【final、权限、内部类、引用类型】"></a>Day 11【final、权限、内部类、引用类型】</h2><h4 id="1-final-关键字"><a href="#1-final-关键字" class="headerlink" title="1. final 关键字"></a>1. final 关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被final关键字修饰的类、方法和变量不可改变。有以下四种主要用法：</span><br></pre></td></tr></table></figure>

<h5 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">	<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为局部变量无初始化默认值，可以先定义后赋值。&#123;<span class="keyword">final</span> <span class="keyword">int</span> a; a = <span class="number">10</span>;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 由于成员变量具有默认值，所以用了<span class="keyword">final</span>之后必须手动赋值，不会再给默认值了。&#123;<span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 对于<span class="keyword">final</span>的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 必须保证类当中所有重载的构造方法，都最终会对<span class="keyword">final</span>的成员变量进行赋值。</span><br></pre></td></tr></table></figure>

<h4 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">(default)</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一类中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">同一包中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包的子类</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包的无关类</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3. 成员内部类"></a>3. 成员内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义在类中方法外的类。</span><br><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>访问特点</strong>：</p>
<ol>
<li>内部类可以直接访问外部类的成员，包括私有成员。</li>
<li>外部类要访问内部类的成员，必须要建立内部类的对象。</li>
<li>创建内部类对象格式：<code>外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；</code></li>
</ol>
</blockquote>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Outer$Heart.class</li>
<li>如果内部类和外部类的变量出现了重名现象，那么在内部类调用外部类变量的格式是：</li>
</ol>
<p><code>外部类名称.this.对象名</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 外部类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 内部类的成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>; <span class="comment">// 内部类方法的局部变量</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 30 局部变量，就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 20 内部类的成员变量</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num); <span class="comment">// 10 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-类的权限修饰符"><a href="#4-类的权限修饰符" class="headerlink" title="4. 类的权限修饰符"></a>4. 类的权限修饰符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义一个类的时候，权限修饰符规则：</span><br><span class="line"></span><br><span class="line">1. 外部类：public/(default)</span><br><span class="line"></span><br><span class="line">2. 成员内部类：四个都行</span><br><span class="line"></span><br><span class="line">3. 局部内部类：什么都不能写</span><br></pre></td></tr></table></figure>

<h4 id="5-局部内部类的final问题"><a href="#5-局部内部类的final问题" class="headerlink" title="5. 局部内部类的final问题"></a>5. 局部内部类的final问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 所在方法的局部变量,从Java 8+开始,只要局部变量事实不变,那么final关键字可以省略			</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyInner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>原因：</strong></p>
<ol>
<li>new出来的对象在堆内存当中。</li>
<li>局部变量是跟着方法走的，在栈内存当中。</li>
<li>方法运行结束之后，立刻出栈，局部变量就会立刻消失。</li>
<li>但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。</li>
</ol>
</blockquote>
<h4 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6. 匿名内部类"></a>6. 匿名内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是内部类的简化写法。它的本质是一个带具体实现的【父类或者父接口的】匿名的子类对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">	<span class="comment">// 方法重写</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行语句</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>匿名内部类特点：</p>
<p>匿名内部类的好处：不用编写实现类，就能创建实现类对象。</p>
<p>匿名内部类的弊端：创建的这个实现类对象，模板只能使用一次。</p>
<p>匿名内部类和匿名对象不是一回事，但是可以【匿名内部类】+【匿名对象】组合使用</p>
</blockquote>
<h1 id="就业班知识点总结"><a href="#就业班知识点总结" class="headerlink" title="就业班知识点总结"></a>就业班知识点总结</h1><h2 id="Day01【Object类、常用API】"><a href="#Day01【Object类、常用API】" class="headerlink" title="Day01【Object类、常用API】"></a>Day01【Object类、常用API】</h2><h4 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1. Object类"></a>1. Object类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。如果一个类没有特别指定父类， 那么默认则继承自Object类。</span><br></pre></td></tr></table></figure>

<h4 id="2-toString方法"><a href="#2-toString方法" class="headerlink" title="2. toString方法"></a>2. toString方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</span><br><span class="line">直接打印对象的名字，其实就是调用对象的toString方法。toString方法可以通过快捷键快速覆盖重写。</span><br></pre></td></tr></table></figure>

<h4 id="3-equals方法"><a href="#3-equals方法" class="headerlink" title="3. equals方法"></a>3. equals方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。</span><br><span class="line">默认进行的比较是 == 运算符的对象地址比较，只要不是同一个对象，结果必然为<span class="keyword">false</span>。</span><br><span class="line">希望进行对象内容的比较时，可以通过重写进行对象内容的比较：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//向下转型</span></span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Objects类"><a href="#4-Objects类" class="headerlink" title="4. Objects类"></a>4. Objects类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JDK7添加了一个Objects工具类，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>public static boolean equals(Object a, Object b)</code> :判断两个对象是否相等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//短路与，若a为null，则避免了a.equals(b)的执行</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Date类"><a href="#5-Date类" class="headerlink" title="5. Date类"></a>5. Date类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示特定的瞬间，精确到毫秒。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>时间原点：1970年1月1日 00:00:00（英国格林威治时间）</li>
<li>中国属于东八区，会把时间增加8个小时</li>
</ol>
</blockquote>
<blockquote>
<p>两个构造方法：</p>
<ol>
<li>Date():返回当前时间的日期对象</li>
<li>Date(long date):返回一个从1970年1月1日 0点0分0秒 + 毫秒值 所对应的日期对象</li>
</ol>
<p>一个成员方法：</p>
<ol>
<li>getTime():将一个日期对象，转为对象的毫秒值表示</li>
</ol>
</blockquote>
<h4 id="6-DateFormat类"><a href="#6-DateFormat类" class="headerlink" title="6. DateFormat类"></a>6. DateFormat类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateFormat用于将日期对象格式化成指定的字符串表示，或者将一个字符串解析成Date对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造方法：public SimpleDateFormat(String pattern)</p>
<p>格式化：按照指定的格式，从Date对象转换为String对象： <code>public String format(Date date)</code></p>
<p>解析：按照指定的格式，从String对象转换为Date对象： <code>public Date parse(String source)</code></p>
</blockquote>
<p><strong>格式规则</strong></p>
<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">日期或时间元素</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">年中的月份</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">年中的天数</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">月份中的天数</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">星期中的天数</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">一天中的小时数（0-23）</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">小时中的分钟数</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">分钟中的秒数</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">毫秒数</td>
</tr>
</tbody></table>
<h4 id="7-Calendar类"><a href="#7-Calendar类" class="headerlink" title="7. Calendar类"></a>7. Calendar类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常用方法：</strong></p>
<ol>
<li><code>public static Calendar getInstance()</code>： 通过静态方法创建对象</li>
<li><code>public int get(int field)</code>：返回给定日历字段的值</li>
<li><code>public abstract void add(int field, int amount)</code> ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。 （也可以同时设置年月日：<code>set(int year, int month, int day)</code>）</li>
</ol>
</blockquote>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th align="center">字段值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">MONTH</td>
<td align="center">月（月份特殊，西方是0-11表示12个月，可以+1使用）</td>
</tr>
<tr>
<td align="center">DAY_OF_MONTH</td>
<td align="center">月中的天（几号）</td>
</tr>
<tr>
<td align="center">HOUR</td>
<td align="center">时（12小时制）</td>
</tr>
<tr>
<td align="center">HOUR_OF_DAY</td>
<td align="center">时（24小时制）</td>
</tr>
<tr>
<td align="center">MINUTE</td>
<td align="center">分</td>
</tr>
<tr>
<td align="center">SECOND</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">DAY_OF_WEEK</td>
<td align="center">周中的天（西方是从星期日开始每周的第一天，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="8-日期、字符串、毫秒值和日历的相互转换"><a href="#8-日期、字符串、毫秒值和日历的相互转换" class="headerlink" title="8. 日期、字符串、毫秒值和日历的相互转换"></a>8. 日期、字符串、毫秒值和日历的相互转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             SimpleDateFormat.parse(s)                 Date.getTime(d)    </span><br><span class="line">字符串		------------------------&gt;	  日期	-----------------------&gt;   毫秒值</span><br><span class="line">  (String)   &lt;------------------------    (Date)  &lt;-----------------------   (<span class="keyword">long</span>)</span><br><span class="line">            SimpleDateFormat.format(d)   /|\   |          <span class="keyword">new</span> Date(l)</span><br><span class="line">                                          |    |</span><br><span class="line">                               getTime()  |	|  setTime(Date date)</span><br><span class="line">                                          |	|   </span><br><span class="line">                                          |   \|/</span><br><span class="line">                                      日历（Calendar）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Date类是另外三种时间格式连接的桥梁，相互之间转换时都需要通过Date类。</strong></p>
</blockquote>
<h4 id="9-System类"><a href="#9-System类" class="headerlink" title="9. System类"></a>9. System类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> ：返回以毫秒为单位的当前时间，经常用来测试程序性能。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> ：将源数组中指定的数据拷贝到目标数组中。数组的拷贝动作是系统级的，性能很高。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h4 id="10-StringBuilder类"><a href="#10-StringBuilder类" class="headerlink" title="10. StringBuilder类"></a>10. StringBuilder类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder又称为可变字符序列，它是一个类似于String的字符串缓冲区，支持可变的字符串，可以提高字符串的操作效率。底层也是一个数组，但是没有被final修饰，可以改变长度在数组中加入新内容。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造方法：</p>
<ol>
<li><code>public StringBuilder()</code> ：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。  </li>
</ol>
<p>常用方法：</p>
<ol>
<li>public StringBuilder append(…) ：添加任意类型数据的字符串形式，并返回当前对象自身。 </li>
<li>public String toString() ：将当前StringBuilder对象转换为String对象。 </li>
</ol>
</blockquote>
<h4 id="11-基本类型与字符串之间的转换"><a href="#11-基本类型与字符串之间的转换" class="headerlink" title="11. 基本类型与字符串之间的转换"></a>11. 基本类型与字符串之间的转换</h4><blockquote>
<p><strong>基本类型转换为String</strong></p>
<ol>
<li>基本类型的值 + “”  (推荐方法）</li>
<li><code>static String toString(基本数据类型):String s = Integer.toString(int i)</code></li>
<li><code>static String valueOf(基本数据类型):String s = String.valueOf(int i)</code></li>
</ol>
<p><strong>String转换为基本类型</strong></p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型。</p>
<p>例如：Integer类: <code>static int parseInt(String s)</code></p>
</blockquote>
<h2 id="Day02【Collection、泛型】"><a href="#Day02【Collection、泛型】" class="headerlink" title="Day02【Collection、泛型】"></a>Day02【Collection、泛型】</h2><h4 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单列集合类的根接口，有两个重要的子接口，分别是java.util.List和java.util.Set</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>List</strong></p>
<p>特点：元素有序、元素可重复</p>
<p>主要实现类：<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code></p>
</blockquote>
<blockquote>
<p><strong>Set</strong></p>
<p>特点：元素无序，而且不可重复</p>
<p>主要实现类：<code>java.util.HashSet</code>和<code>java.util.LinkedHashSet</code></p>
</blockquote>
<h4 id="2-集合和数组的区别"><a href="#2-集合和数组的区别" class="headerlink" title="2. 集合和数组的区别"></a>2. 集合和数组的区别</h4><blockquote>
<p><strong>长度不同</strong></p>
<ul>
<li>集合：集合的长度是可变的，因为集合的底层就是数组，当增删元素的时候，会进行数组的扩容</li>
<li>数组：数组的长度在运行期间不可变，一旦创建，就固定</li>
</ul>
</blockquote>
<blockquote>
<p><strong>存储的数据类型不同</strong></p>
<ul>
<li>集合：只能存储引用数据类型，如果想存储基本数据类型，需要存储对应的包装类</li>
<li>数组：基本数据类型和引用数据类型都可以存储</li>
</ul>
</blockquote>
<h4 id="3-Collection-常用功能"><a href="#3-Collection-常用功能" class="headerlink" title="3. Collection 常用功能"></a>3. Collection 常用功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<h4 id="4-Iterator接口"><a href="#4-Iterator接口" class="headerlink" title="4.  Iterator接口"></a>4.  Iterator接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【迭代器】Iterator是一种通用的Collection集合元素的获取方式，通过判断集合中是否有元素，有则取出，继续判断，直到把集合中的元素全部取出为止。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取迭代器的方法：</p>
<ul>
<li><code>collection.iterator()</code>:由于接口不能直接实例化，使用集合的Iterator方法获取</li>
</ul>
<p>常用的两个方法：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p><strong>并发修改异常</strong>：迭代器的底层实现原理，运用到指针。在使用迭代器的过程中，修改了集合的长度，就会抛出该异常。使用Iterator接口的一个子接口ListIterator接口可以解决这个问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	Iterator&lt;String&gt; it = coll.iterator(); <span class="comment">//通过集合获取迭代器</span></span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">		String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">		System.out.println(s);&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-ListIterator接口"><a href="#5-ListIterator接口" class="headerlink" title="5. ListIterator接口"></a>5. ListIterator接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator接口有一个子接口ListIterator接口，其中定义了add方法和remove方法，可以对集合添加\删除元素。由迭代器自己添加\删除的不会抛出异常。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用步骤：</p>
<ol>
<li>创建的集合首先不能使用Collection，因为Collection获取不了ListIterator接口，需要使用List接口获取ListIterator接口实现类</li>
<li>调用listIterator（）方法，获取listIterator接口实现类</li>
<li>使用hasNext和next方法进行迭代</li>
<li>使用接口实现类的add方法进行添加，remove方法进行删除元素。注意：不要使用集合进行添加删除</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"黑马"</span>);</span><br><span class="line">	ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line">	<span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">		String s = lit.next();</span><br><span class="line">		System.out.println(s);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"黑马"</span>.equals(s)) &#123;</span><br><span class="line">			lit.add(<span class="string">"金马"</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-增强for"><a href="#6-增强for" class="headerlink" title="6. 增强for"></a>6. 增强for</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">增强<span class="keyword">for</span>循环是基于迭代器设计的一种高级<span class="keyword">for</span>循环，专门用于遍历数组和集合。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式：</span><br><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7. 泛型"></a>7. 泛型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在定义类或方法时，对于未知类型的数据进行占位，用于后期接收数据类型，以便预支使用的一种未知的数据类型。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>泛型的好处：</p>
<ol>
<li>避免了类型转换的麻烦，使用API时更加直观简洁。</li>
<li>把运行期异常，提升到了编译期</li>
</ol>
</blockquote>
<h5 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h5><blockquote>
<p>定义格式：<code>修饰符 class 类名&lt;代表泛型的变量&gt; {}</code></p>
<p>确定泛型：在创建对象的时候</p>
</blockquote>
<h5 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h5><blockquote>
<p>定义格式：<code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){}</code></p>
<p>确定泛型：调用方法时</p>
</blockquote>
<h5 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h5><blockquote>
<p>定义格式：<code>修饰符 interface 接口名&lt;代表泛型的变量&gt; {}</code></p>
<p>确定泛型：1、定义类时确定泛型的类型； 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</p>
</blockquote>
<h4 id="8-泛型通配符"><a href="#8-泛型通配符" class="headerlink" title="8. 泛型通配符"></a>8. 泛型通配符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不知道使用什么类型来接收的时候,此时泛型可以使用“?”表示,“?”表示未知通配符。</span><br><span class="line">但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>受限泛型</strong>：泛型没有继承概念，JAVA的泛型中可以指定一个泛型的上限和下限。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其父类型</code></li>
</ul>
</blockquote>
<h2 id="Day03【List、Set、数据结构、Collections】"><a href="#Day03【List、Set、数据结构、Collections】" class="headerlink" title="Day03【List、Set、数据结构、Collections】"></a>Day03【List、Set、数据结构、Collections】</h2><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：先进后出</strong></p>
<ul>
<li>压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li>弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
</blockquote>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：先进先出</strong></p>
</blockquote>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是有序的元素序列，在内存中开辟一段连续的空间，并在此空间存放元素</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：有索引值，查询快，增删慢</strong></p>
</blockquote>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链表中的每一个元素也称之为一个节点，一个节点包含了一个数据源，两个指针域（存储地址）：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：查询慢，增删快</strong></p>
<ul>
<li>单项链表：链表中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）</li>
<li>双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合</li>
</ul>
</blockquote>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是一种比较平衡的二叉树</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：速度特别快，</strong>趋近平衡树，查询叶子节点最大次数和最小次数不能超过2倍</p>
<p>约束：</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
<li>根节点是黑色的</li>
<li>叶子节点(特指空节点)是黑色的</li>
<li>每个红色节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ol>
</blockquote>
<h4 id="2-List-接口"><a href="#2-List-接口" class="headerlink" title="2. List 接口"></a>2. List 接口</h4><blockquote>
<p>特点：</p>
<ol>
<li>有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123)</li>
<li>有索引,包含了一些带索引的方法</li>
<li>允许存储重复的元素</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用方法：</span><br><span class="line">    - <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span>: 将指定的元素，添加到该集合中的指定位置上。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:返回集合中指定位置的元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>: 移除列表中指定位置的元素, 返回的是被移除的元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-LinkedList-集合"><a href="#3-LinkedList-集合" class="headerlink" title="3. LinkedList 集合"></a>3. LinkedList 集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList是一个双向链表，查询慢，增删快，包含了大量操作首尾元素的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span>:从此列表所表示的堆栈处弹出一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span>:将元素推入此列表所表示的堆栈。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：如果列表不包含元素，则返回<span class="keyword">true</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-HashSet-集合"><a href="#4-HashSet-集合" class="headerlink" title="4. HashSet 集合"></a>4. HashSet 集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是Set接口的一个实现类，存储的元素不可重复，并且元素都是无序的(即存取顺序不一致),没有索引,不能使用普通的for循环遍历。HashSet根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>HashSet集合存储数据的结构（哈希表）</strong>：</p>
<ul>
<li>jdk1.8版本之前：哈希表 = 数组 + 链表</li>
<li>jdk1.8版本之后：哈希表 = 数组 +链表/红黑树；</li>
</ul>
<p>（当链表长度超过阈值（8）时，将链表转换为红黑树提高查询的速度）</p>
</blockquote>
<h4 id="5-LinkedHashSet-集合"><a href="#5-LinkedHashSet-集合" class="headerlink" title="5. LinkedHashSet 集合"></a>5. LinkedHashSet 集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet是无序的，LinkedHashSet是有序的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：底层是一个哈希表（数组+链表/红黑树）+ 链表：多了一条链表(记录元素的存储顺序)，保证元素有序</p>
</blockquote>
<h4 id="6-重写HashCode-方法"><a href="#6-重写HashCode-方法" class="headerlink" title="6. 重写HashCode()方法"></a>6. 重写HashCode()方法</h4><blockquote>
<p><strong>为什么需要重写HashCode()方法？</strong></p>
<p>如果两个对象需要判断是否内容相同，可以调用equals方法进行比较，但如果一个对象的字段过多，那就会偏频繁的进行字段的比较，非常的耗费性能。我们可以对Object类继承过来的hashCode方法进行覆盖重写，不让他生成地址值，而是<strong>根据我们对象的内容</strong>，生成hash值进行比较。因为比较hash值比equals方法容易得多。如果hash值相同，再调用equals方法进行内容比较。</p>
</blockquote>
<blockquote>
<p><strong>哈希值：</strong>是一个十进制的整数，由系统随机给出(就是对象的地址值，是一个逻辑地址，是模拟出来得到地址，不是数据实际存储的物理地址)</p>
</blockquote>
<blockquote>
<p><strong>重写HashCode()进行比较的步骤：</strong></p>
<ol>
<li>重写Object类中继承过来的HashCode()方法，自定义，根据对象的内容生成的哈希值</li>
<li>我们在进行集合元素存储的时候，比如向HashSet集合添加元素的时候，会先调用HashCode()方法，生成哈希值，不同对象生成的哈希值可能相同（虽然概率比较低）</li>
<li>哈希值不同，对象的内容肯定不同；哈希值相同，对象的内容有可能相同，有可能不同</li>
<li>比较哈希值，如果不同，直接存；如果相同，再调用equals方法进行内容比较</li>
</ol>
</blockquote>
<h4 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数</span><br><span class="line">格式：修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理：可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个（不传递），1,2,…多个</p>
</blockquote>
<blockquote>
<p>注意事项：</p>
<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</li>
<li>可变参数的终极写法：Object…obj </li>
</ol>
</blockquote>
<h4 id="8-Collections-工具类"><a href="#8-Collections-工具类" class="headerlink" title="8. Collections 工具类"></a>8. Collections 工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; c, T... elements)</span>：</span></span><br><span class="line"><span class="function">往集合中添加一些元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span>：打乱集合顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span>（&lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;）：</span></span><br><span class="line"><span class="function">根据元素的自然顺序对指定列表按升序进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span>：</span></span><br><span class="line"><span class="function">根据指定比较器产生的顺序对指定列表进行排序</span></span><br></pre></td></tr></table></figure>

<h4 id="9-Comparable-Comparator-接口"><a href="#9-Comparable-Comparator-接口" class="headerlink" title="9. Comparable/Comparator 接口"></a>9. Comparable/Comparator 接口</h4><blockquote>
<p><strong>Comparable和Comparator的区别：</strong></p>
<ul>
<li>Comparable：自己(this)和别人(参数)比较,在源代码类中需要实现Comparable接口，重写比较的规则compareTo方法，耦合度太高</li>
<li>Comparator：在需要做排序的时候去选择的Comparator，相当于找一个第三方的裁判</li>
<li>排序规则：this - 参数：升序；参数 - this：降序</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparable使用示例，在源码类中实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">People</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(People o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator使用示例，在Collections.sort方法中实现Comparator接口的匿名内部类</span></span><br><span class="line"> Collections.sort(list, <span class="keyword">new</span> Comparator&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(People o1, People o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator如果想实现更多规则，示例如下：</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(People o1, People o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result =  o1.age - o2.age;</span><br><span class="line">                <span class="keyword">if</span> (o1.age - o2.age == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = o1.name.charAt(<span class="number">0</span>) - o2.name.charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="Day04【Map、Debug】"><a href="#Day04【Map、Debug】" class="headerlink" title="Day04【Map、Debug】"></a>Day04【Map、Debug】</h2><h4 id="1-Map接口"><a href="#1-Map接口" class="headerlink" title="1. Map接口"></a>1. Map接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection 中的集合称为单列集合， Map 中的集合称为双列集合。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<ol>
<li>是一个双列集合，一个元素包含两个值（一个key，一个value）</li>
<li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li>
<li>Map集合中的元素，key是不允许重复的，value是可以重复的</li>
<li>Map集合中的元素，key和value是一一对应的</li>
</ol>
</blockquote>
<h4 id="2-Map的常用子类"><a href="#2-Map的常用子类" class="headerlink" title="2. Map的常用子类"></a>2. Map的常用子类</h4><blockquote>
<p><strong>HashMap：</strong>存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需<br>要重写键的hashCode()方法、equals()方法。</p>
<p><strong>LinkedHashMap：</strong>存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p>
<p><strong>HashTable：</strong>底层也是一个哈希表，是一个线程安全的集合，单线程集合，速度慢。不能存储空值，空键。Hashtable和Vector集合一样，在jdk1.2版本之后被更先进的集合取代了。</p>
</blockquote>
<h4 id="3-Map的常用方法"><a href="#3-Map的常用方法" class="headerlink" title="3. Map的常用方法"></a>3. Map的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> : 把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="function"><span class="comment">//返回值V的说明：存储键值对的时候，key不重复，返回值V是null;key重复，会使用新的value替换map中重复的value，返回被替换的value值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> : 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。如果不存在指定的键，则返回空。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> 根据指定的键，在Map集合中获取对应的值。如果不存在指定的键，则返回空。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>: 集合中是否包含指定的键</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> : 获取Map集合中所有的键，存储到Set集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span> : 获取到Map集合中所有的键值对对象的集合<span class="params">(Set集合)</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Entry键值对对象"><a href="#4-Entry键值对对象" class="headerlink" title="4. Entry键值对对象"></a>4. Entry键值对对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一对key(键)+value(值)称做Map中的一个Entry(项)，Entry将键值对的对应关系封装成了对象，即键值对对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entry相关方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> ：获取Entry对象中的键。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> ：获取Entry对象中的值。</span></span><br><span class="line"><span class="function">在Map集合中也提供了获取所有Entry对象的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span> : 获取到Map集合中所有的键值对对象的集合<span class="params">(Set集合)</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="5-Map的两种遍历方式"><a href="#5-Map的两种遍历方式" class="headerlink" title="5. Map的两种遍历方式"></a>5. Map的两种遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"thr"</span>);</span><br><span class="line">		<span class="comment">//keySet遍历方式</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">" = "</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//entrySet遍历方式（更快）</span></span><br><span class="line">  		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-JDK9对集合添加的优化"><a href="#6-JDK9对集合添加的优化" class="headerlink" title="6. JDK9对集合添加的优化"></a>6. JDK9对集合添加的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 9给List接口，Set接口和Map接口增加了一个静态的方法of，可以给集合一次性添加多个元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">		<span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合</span></span><br><span class="line">		System.out.println(str1);</span><br><span class="line">		Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(str2);</span><br><span class="line">		List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);</span><br><span class="line">		System.out.println(str3);</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如<br>HashSet，ArrayList等；</li>
<li>of方法的返回值时一个不能改变的集合，集合不能再使用add,put方法添加元素，会抛出异常；</li>
<li>Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常</li>
</ol>
</blockquote>
<h4 id="7-Debug追踪"><a href="#7-Debug追踪" class="headerlink" title="7. Debug追踪"></a>7. Debug追踪</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用IDEA的断点调试功能，可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用方式：</strong></p>
<ol>
<li>在行号的右边，鼠标左键单击，添加断点（哪里有bug添加到哪里）</li>
<li>右键选择Debug执行程序</li>
<li>程序就会停留在添加的第一个断点处</li>
</ol>
<p><strong>执行程序：</strong></p>
<ul>
<li>F7：逐句执行程序（进入到方法中）</li>
<li>F8：逐行执行程序（不进入方法中）</li>
<li>Shift + F8：跳出方法</li>
<li>F9：跳到下一个断点，如果没有下一个断点，那么就结束程序</li>
<li>Ctrl + F2：退出Debug模式，停止程序</li>
</ul>
</blockquote>
<h2 id="Day05【异常、线程】"><a href="#Day05【异常、线程】" class="headerlink" title="Day05【异常、线程】"></a>Day05【异常、线程】</h2><h4 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处</span><br><span class="line">理异常的方式是中断处理。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行。</p>
</blockquote>
<h4 id="2-Throwable体系"><a href="#2-Throwable体系" class="headerlink" title="2. Throwable体系"></a>2. Throwable体系</h4><blockquote>
<ul>
<li><strong>Error</strong>：严重错误，无法通过处理的错误，只能事先避免，好比绝症。（内存不够用或和系统相关）</li>
<li><strong>Exception</strong>：异常，产生后程序员可以通过代码的方式纠正，使程序继续运行，好比感冒。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Throwable常用方法：</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span>：返回此throwable的简短描述,一般用于提示给用户</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span>：返回此throwable的详细消息字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>:JVM打印异常对象，默认此方法，信息是最全面的，用于开发和调试阶段</span></span><br></pre></td></tr></table></figure>

<h4 id="3-异常的分类"><a href="#3-异常的分类" class="headerlink" title="3. 异常的分类"></a>3. 异常的分类</h4><blockquote>
<ul>
<li>编译时期异常：必须要处理。在编译时期就会检查，如果没有处理异常，则编译失败。</li>
<li>运行时期异常：可以不处理。在运行时期检查异常，在编译时期，运行异常不会被编译器报错。</li>
</ul>
</blockquote>
<h4 id="4-异常产生过程解析"><a href="#4-异常产生过程解析" class="headerlink" title="4. 异常产生过程解析"></a>4. 异常产生过程解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对给定的数组通过给定的索引获取元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> element = arr[index];</span><br><span class="line">	<span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在主方法中调用getElement方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>过程解析：getElement方法由于没有找到4索引，导致运行发生了异常，接下来JVM会：</p>
<ol>
<li>Jvm会根据异常产生的原因创建一个异常对象，这个对象包含了异常产生的（内容，原因，位置） new ArrayIndexOutOfBoundsException(“4”);</li>
<li>在getElement方法中，没有异常的处理逻辑（try…catch），那么JVM就会把异常对象抛出给方法的调用者main方法来处理这个异常</li>
<li>main方法接受后也没有处理异常的逻辑，继续把对象抛给main方法的调用者JVM处理</li>
<li>JVM收到这个异常对象，做了两件事：<ul>
<li>把异常对象（内容、原因、位置）以红色的字体打印在控制台</li>
<li>JVM会终止当前正在执行的Java程序—&gt;中断处理</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="5-throw关键字"><a href="#5-throw关键字" class="headerlink" title="5. throw关键字"></a>5. throw关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。例如：</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>throw将异常抛出，也就是将问题返回给该方法的调用者。对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用<strong>throws</strong>声明处理。</p>
</blockquote>
<blockquote>
<p>注意：</p>
<ol>
<li>throw关键字必须写在方法的内部</li>
<li>throw关键字后边new的对象必须是Exception或者Exception的子类对象</li>
<li>throw关键字抛出RuntimeException或者是其子类对象，我们可以不处理，默认交给JVM处理</li>
<li>throw关键字后边创建的是编译异常，我们就必须处理这个异常（try…catch）</li>
</ol>
</blockquote>
<h4 id="6-Objects非空判断"><a href="#6-Objects非空判断" class="headerlink" title="6. Objects非空判断"></a>6. Objects非空判断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> :查看指定引用对象不是<span class="keyword">null</span></span></span><br><span class="line"><span class="function"><span class="comment">//源码：</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(obj == <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">		throw new <span class="title">NullPointerException</span><span class="params">()</span>  </span>;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure>

<h4 id="7-throws声明异常"><a href="#7-throws声明异常" class="headerlink" title="7. throws声明异常"></a>7. throws声明异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">声明异常：如果方法内通过throw抛出编译时异常，而没有捕获处理，那么必须通过throws进行声明，将问题标识出来。</span><br><span class="line">抛出异常：关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	read(<span class="string">"a.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!path.equals(<span class="string">"b.txt"</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子父类的异常：子类抛出的异常在数量和继承关系上不能超出父类</p>
</blockquote>
<h4 id="8-try…catch捕获异常"><a href="#8-try…catch捕获异常" class="headerlink" title="8. try…catch捕获异常"></a>8. try…catch捕获异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">	处理异常的代码</span><br><span class="line">	<span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		read(<span class="string">"b.txt"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-finally代码块"><a href="#9-finally代码块" class="headerlink" title="9. finally代码块"></a>9. finally代码块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为异常会引发程序跳转，导致有些语句执行不到。但有一些特定的代码必须执行，将这些代码放在finally代码块中是一定会被执行的。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		read(<span class="string">"a.txt"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"不管程序怎样，这里都将会被执行。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>finally不能单独使用。</li>
<li>如果finally有return语句,永远返回finally中的结果,避免该情况。</li>
<li>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</li>
</ul>
</blockquote>
<h4 id="10-多个异常使用捕获"><a href="#10-多个异常使用捕获" class="headerlink" title="10. 多个异常使用捕获"></a>10. 多个异常使用捕获</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般多个异常一次捕获，多次处理。</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A e)&#123; 当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">	处理异常的代码</span><br><span class="line">	<span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B e)&#123; 当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">	处理异常的代码</span><br><span class="line">	<span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异<br>常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
<h4 id="11-自定义异常"><a href="#11-自定义异常" class="headerlink" title="11. 自定义异常"></a>11. 自定义异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXException</span> <span class="keyword">extends</span> <span class="title">Exception</span>/<span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">	<span class="comment">//空参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XXXException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XXXException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>自定义异常类一般都是以Exception结尾，说明该类是一个异常类</li>
<li>所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法</li>
<li>自定义异常类，必须继承Exception/RuntimeException<ul>
<li>继承RuntimeException：那么就是一个运行期异常，无需处理，交给虚拟机</li>
<li>继承Exception：那么就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="12-并发与并行"><a href="#12-并发与并行" class="headerlink" title="12. 并发与并行"></a>12. 并发与并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发：指两个或多个事件在同一个时间段内发生（交替执行）。</span><br><span class="line">并行：指两个或多个事件在同一时刻发生（同时执行）。</span><br></pre></td></tr></table></figure>

<h4 id="13-线程与进程"><a href="#13-线程与进程" class="headerlink" title="13. 线程与进程"></a>13. 线程与进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程：一个应用程序可以同时运行多个进程，每个进程都有一个独立的内存空间，是系统运行程序的基本单位。</span><br><span class="line">线程：是CPU和任务之间的执行通道，是任务的执行单元，一个进程中可以有多个线程。</span><br><span class="line">一个应用程序可以有多个进程，一个进程可以有多个线程。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程调度：</p>
<ul>
<li>分时调度：<br>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</li>
<li>抢占式调度：<br>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</li>
</ul>
</blockquote>
<h2 id="Day06【线程、同步】"><a href="#Day06【线程、同步】" class="headerlink" title="Day06【线程、同步】"></a>Day06【线程、同步】</h2><h4 id="1-Thread类"><a href="#1-Thread类" class="headerlink" title="1. Thread类"></a>1. Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> :分配一个新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> :分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> :分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span> :分配一个带有指定目标新的线程对象并指定名字。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> :获取当前线程名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> :导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> :此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> :返回对当前正在执行的线程对象的引用。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建线程-继承Thread类"><a href="#2-创建线程-继承Thread类" class="headerlink" title="2. 创建线程-继承Thread类"></a>2. 创建线程-继承Thread类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建多线程的第一种方式：创建Thread类的子类</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现步骤：</p>
<ol>
<li>创建一个Thread类的子类，并重写Thread类中的run方法，设置线程任务</li>
<li>创建Thread类的子类对象</li>
<li>调用线程对象的start()方法，开启新的线程，执行run方法</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//创建Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">	mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建线程-Runnable接口"><a href="#3-创建线程-Runnable接口" class="headerlink" title="3. 创建线程-Runnable接口"></a>3. 创建线程-Runnable接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建多线程的第二种方式：Thread构造器实现Runnable接口</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现步骤：</p>
<ol>
<li>创建一个Runnable接口的实现类</li>
<li>在实现类中重写Runnable接口的run方法，设置线程任务</li>
<li>创建一个Runnable接口的实现类对象</li>
<li>创建Thread类对象，构造方法中传递Runnable接口的实现类对象</li>
<li>调用Thread类中的start方法，开启新的线程执行run方法</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//创建Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">	t.start();</span><br><span class="line">&#125;<span class="comment">//也可以使用匿名内部类方式实现线程的创建</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Runnable接口具有的优势"><a href="#4-Runnable接口具有的优势" class="headerlink" title="4. Runnable接口具有的优势"></a>4. Runnable接口具有的优势</h4><ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>
<h4 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5. 线程安全"></a>5. 线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当多个线程对象访问同一个资源，并且多个线程中对资源有写的操作，就容易产生线程安全问题。</span><br></pre></td></tr></table></figure>

<h4 id="6-同步代码块"><a href="#6-同步代码块" class="headerlink" title="6. 同步代码块"></a>6. 同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 关键字可以用于方法中的某个区块中，表示对这个区块的资源实行互斥访问。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (lock) &#123;  <span class="comment">//对卖票的操作进行锁</span></span><br><span class="line">				<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					String name = Thread.currentThread().getName();</span><br><span class="line">					System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>同步锁：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁</strong></p>
<ol>
<li>锁对象可以是任意类型。</li>
<li>多个线程对象要使用同一把锁。</li>
<li>在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着。</li>
</ol>
</blockquote>
<h4 id="7-同步方法"><a href="#7-同步方法" class="headerlink" title="7. 同步方法"></a>7. 同步方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用synchronized修饰的方法，就叫做同步方法，保证一个线程执行该方法的时候，其他线程只能在方法外等着。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		sellTicket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			String name = Thread.currentThread().getName();</span><br><span class="line">			System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>同步锁是谁?</strong></p>
<p>对于非static方法，同步锁就是<strong>this</strong>。</p>
<p>对于static方法，我们使用当前方法所在类的<strong>字节码对象</strong>(类名.class)。</p>
</blockquote>
<h4 id="8-Lock锁"><a href="#8-Lock锁" class="headerlink" title="8. Lock锁"></a>8. Lock锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外Lock更强大,更体现面向对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();	<span class="comment">//1.创建锁对象</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			lock.lock();	<span class="comment">//2.加同步锁</span></span><br><span class="line">			<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				String name = Thread.currentThread().getName();</span><br><span class="line">				System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">			&#125;</span><br><span class="line">			lock.unlock();	<span class="comment">//3.释放同步锁</span></span><br></pre></td></tr></table></figure>

<h4 id="9-六种线程状态"><a href="#9-六种线程状态" class="headerlink" title="9. 六种线程状态"></a>9. 六种线程状态</h4><table>
<thead>
<tr>
<th align="left">线程状态</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新建状态(New)</td>
<td align="left">线程刚被创建，但是还没调用start方法启动。</td>
</tr>
<tr>
<td align="left">运行状态(Runnable)</td>
<td align="left">线程可以在java虚拟机中运行的状态。</td>
</tr>
<tr>
<td align="left">阻塞状态(Blockd)</td>
<td align="left">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态。</td>
</tr>
<tr>
<td align="left">计时等待状态(Timed waiting)</td>
<td align="left">一个线程在等待另一个线程调用notify或者notifyAll方法（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的。</td>
</tr>
<tr>
<td align="left">无限等待状态(Waiting)</td>
<td align="left">同waiting状态，这一状态将一直保持到超时期满或者接收到唤醒通知。</td>
</tr>
<tr>
<td align="left">死亡状态(Terminated)</td>
<td align="left">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<h4 id="10-等待与唤醒方法"><a href="#10-等待与唤醒方法" class="headerlink" title="10. 等待与唤醒方法"></a>10. 等待与唤醒方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进入到TimeWaiting(计时等待)有两种方式：</span><br><span class="line">    <span class="number">1</span>. sleep(<span class="keyword">long</span> m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态。sleep方法使用后线程失</span><br><span class="line">    去CPU执行权，但仍然拥有锁对象。</span><br><span class="line">    <span class="number">2</span>. wait(<span class="keyword">long</span> m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到</span><br><span class="line">    Runnable/Blocked状态。wait方法同时释放锁对象和cpu执行权。</span><br><span class="line">唤醒的两种方式:</span><br><span class="line">	<span class="number">1</span>. <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> 唤醒在此对象监视器上等待的单个线程。</span></span><br><span class="line"><span class="function">	2. <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span> 唤醒在此对象监视器上等待的所有线程。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wait和notify方法是来源于Object类，不是Thread类，等待和唤醒都是Object的方法</p>
</blockquote>
<h2 id="Day07【线程池、Lambda表达式】"><a href="#Day07【线程池、Lambda表达式】" class="headerlink" title="Day07【线程池、Lambda表达式】"></a>Day07【线程池、Lambda表达式】</h2><h4 id="1-等待唤醒机制"><a href="#1-等待唤醒机制" class="headerlink" title="1. 等待唤醒机制"></a>1. 等待唤醒机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程进行了规定操作后，通过wait()方法进入等待状态，等待其他线程执行完他们的指定代码过后再通过notify()方法将其唤醒，是线程间的一种协作机制。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用，因为要通过锁对象调用这2个方法。</li>
<li>被唤醒的线程不一定能立即恢复执行，需要再次获取锁后才能在从 wait() 方法之后的地方恢复执行。</li>
</ol>
</blockquote>
<h4 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>线程池的好处：</strong></p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>线程池使用步骤：</strong></p>
<ol>
<li>用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</li>
<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>
<li>调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法</li>
<li>调用ExecutorService中的方法shutdown销毁线程池(不建议执行)</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        es.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">    	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda表达式的标准格式为：(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用前提：</p>
<ol>
<li>必须有<strong>函数式接口</strong>——只包含一个抽象方法的接口</li>
<li>必须有上下文引用（必须有接口作为数据类型接收）</li>
</ol>
</blockquote>
<blockquote>
<p>省略格式（<strong>可推导,可省略</strong>）：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内有且仅有一个参，则小括号可以省略；</li>
<li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写Runnable接口    </span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"创建并执行线程"</span>)).start(); </span><br><span class="line">    <span class="comment">//重写Comparator接口，降序排序	</span></span><br><span class="line">    Collections.sort(list,(o1, o2) -&gt; o2 - o1);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Day08【File类、递归】"><a href="#Day08【File类、递归】" class="headerlink" title="Day08【File类、递归】"></a>Day08【File类、递归】</h2><h4 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</span><br><span class="line">File类的实例是不可变的，一旦创建，File对象表示的抽象路径名将永不改变</span><br></pre></td></tr></table></figure>

<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span> ：通过将给定的路径名字符串创建新的 File实例。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span> ：父路径名字符串+子路径名字符串创建新的File实例。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent, String child)</span> ：从父File实例路径名+子路径名字符串创建新的File实例。</span></span><br></pre></td></tr></table></figure>

<h5 id="获取的方法"><a href="#获取的方法" class="headerlink" title="获取的方法"></a>获取的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span> ：返回此File的绝对路径名字符串。</span></span><br><span class="line"><span class="function"><span class="comment">//File对象的toString方法调用的就是getPath()方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> ：将此File转换为路径名字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> ：返回由此File表示的文件或目录的名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> ：返回由此File表示的文件的长度。</span></span><br></pre></td></tr></table></figure>

<h5 id="判断的方法"><a href="#判断的方法" class="headerlink" title="判断的方法"></a>判断的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> ：此File表示的文件或目录是否实际存在。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> ：此File表示的是否为目录。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> ：此File表示的是否为文件。</span></span><br></pre></td></tr></table></figure>

<h5 id="创建删除的方法"><a href="#创建删除的方法" class="headerlink" title="创建删除的方法"></a>创建删除的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> ：删除由此File表示的文件或目录，目录项下有内容的话无法删除。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> ：创建由此File表示的目录。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历的方法"><a href="#遍历的方法" class="headerlink" title="遍历的方法"></a>遍历的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span><br><span class="line"><span class="keyword">public</span> File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
<h4 id="2-绝对路径和相对路径"><a href="#2-绝对路径和相对路径" class="headerlink" title="2. 绝对路径和相对路径"></a>2. 绝对路径和相对路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">绝对路径：从盘符开始的路径，这是一个完整的路径。</span><br><span class="line">相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>File.pathSeparator</code>：获取当前系统路径分隔符；（Windows用” <strong>;</strong> “    Linux用” <strong>:</strong> “）<br><code>File.separator</code>：获取当前系统文件名称分隔符；（Windows用”<strong>反斜杠\</strong>“    Linux用”<strong>正斜杠/</strong>“）</p>
</blockquote>
<h4 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归：指在当前方法内调用自己的这种现象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<ol>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。(StackOverflowError)</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。(StackOverflowError)</li>
<li>构造方法,禁止递归。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 #暴力删除#</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : f.listFiles()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                        file.delete();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        deleteAll(file);</span><br><span class="line">                    &#125;&#125;&#125;</span><br><span class="line">            f.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该路径不是有效路径"</span>);</span><br><span class="line">        &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 #阶乘#</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码演示 #内存容量测试#</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        b(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        b(++i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-文件过滤器"><a href="#4-文件过滤器" class="headerlink" title="4. 文件过滤器"></a>4. 文件过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles():返回指定目录中的子目录和文件。</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter):返回指定目录中符合自定义规则的子目录和文件。</span><br><span class="line">FileFilter接口中抽象方法：</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> 测试指定格式路径名是否包含在某个路径名列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">(FilenameFilter filter)</span>:返回指定目录中指定文件。</span></span><br><span class="line"><span class="function">FilenameFilter接口中抽象方法：</span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> 测试指定文件是否应该包含在某一文件列表中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法，输出文件夹里的所有的java文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showJava</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        File[] files = f.listFiles(pathname-&gt;pathname.isDirectory()||</span><br><span class="line">                                   pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>));</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                showJava(file);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(file.getAbsolutePath());</span><br><span class="line">            &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day09【字节流、字符流】"><a href="#Day09【字节流、字符流】" class="headerlink" title="Day09【字节流、字符流】"></a>Day09【字节流、字符流】</h2><h4 id="1-IO流"><a href="#1-IO流" class="headerlink" title="1. IO流"></a>1. IO流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入流 ：把数据从其他设备上读取到【内存中】的流。</span><br><span class="line">输出流 ：把数据从【内存中】写出到其他设备上的流。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">顶级父类们</th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">字节输入流【InputStream】</td>
<td align="center">字节输出流【OutputStream】</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">字符输入流【Reader】</td>
<td align="center">字符输出流【Writer】</td>
</tr>
</tbody></table>
<h4 id="2-字节输出流【OutputStream】"><a href="#2-字节输出流【OutputStream】" class="headerlink" title="2. 字节输出流【OutputStream】"></a>2. 字节输出流【OutputStream】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OutputStream 基本方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此输出流并释放与此流相关联的任何系统资源。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> ：刷新此输出流并强制任何缓冲的输出字节被写出。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> ：将 b.length字节从指定的字节数组写入此输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：true 表示追加数据， false 表示清空原有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> ： 创建文件输出流以指定的名称写入文件。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> ：创建文件输出流以写入由指定的File对象表示的文件。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-字节输入流【InputStream】"><a href="#3-字节输入流【InputStream】" class="headerlink" title="3. 字节输入流【InputStream】"></a>3. 字节输入流【InputStream】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputStream 基本方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此输入流并释放与此流相关联的任何系统资源。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ： 从输入流读取数据的下一个字节。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> ： 从输入流中读取一些字节数，并将它们存储到字节数组b中，返回读取的字节数。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileInputStream (File file)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的File对象file命名。</span><br><span class="line">FileInputStream (String name)：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名name命名。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件复制代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入输出流对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"des.jpg"</span>);</span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//读取源文件</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//输出文件</span></span><br><span class="line">            fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br></pre></td></tr></table></figure>

<h4 id="4-字符输入流【Reader】"><a href="#4-字符输入流【Reader】" class="headerlink" title="4. 字符输入流【Reader】"></a>4. 字符输入流【Reader】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reader 基本方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此流并释放与此流相关联的任何系统资源。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ： 从输入流读取一个字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> ： 从输入流中读取一些字符，并将它们存储到字符数组cbuf中 。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileReader(File file)：创建一个新的 FileReader，给定要读取的File对象。</span><br><span class="line">FileReader(String fileName)：创建一个新的 FileReader，给定要读取的文件的名称。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-字符输出流【Writer】"><a href="#5-字符输出流【Writer】" class="headerlink" title="5. 字符输出流【Writer】"></a>5. 字符输出流【Writer】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Writer 基本方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> 刷新该流的缓冲。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此流，但会自动先刷新它。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> 写入单个字符。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> 写入字符数组。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 写入字符数组的某一部分,off数组的开始索引,len字符个数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> 写入字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 写入字符串的某一部分,off字符串的开始索引,len字符个数。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileWriter(File file)：创建一个新的 FileWriter，给定要读取的File对象。</span><br><span class="line">FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>使用FileWriter中的方法write，是把数据写入到内存缓冲区中，需要刷新缓冲区，才能将数据保存到文件中。</p>
<ul>
<li>flush ：刷新缓冲区，流对象可以继续使用。</li>
<li>close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
</blockquote>
<h4 id="6-IO异常的处理"><a href="#6-IO异常的处理" class="headerlink" title="6. IO异常的处理"></a>6. IO异常的处理</h4><h5 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK7的处理"><a href="#JDK7的处理" class="headerlink" title="JDK7的处理"></a>JDK7的处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7优化后用()包裹流对象语句，确保每个流对象在结束使用后关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>); ) &#123;</span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK9的改进"><a href="#JDK9的改进" class="headerlink" title="JDK9的改进"></a>JDK9的改进</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK9中使用引入对象的方式，同样可以确保每个流对象在结束使用后自动关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> (fw) &#123;</span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-Properties类"><a href="#7-Properties类" class="headerlink" title="7. Properties类"></a>7. Properties类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.Properties继承于Hashtable，使用键值结构存储数据，每个键及其对应值都是一个字符串。</span><br><span class="line">可以方便地在双列集合和数据文件之间转换。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Properties</span><span class="params">()</span> :创建一个空的属性列表。</span></span><br><span class="line"><span class="function"><span class="comment">//存储方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setProperty</span><span class="params">(String key, String value)</span>：添加一个键值对。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span>：通过键获取对应的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">stringPropertyNames</span><span class="params">()</span>：获取所有键名称的集合。</span></span><br><span class="line"><span class="function"><span class="comment">//流相关方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span>：从字节输入流中读取键值对,生成Properties集合。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out,String comments)</span>：从Properties集合中获取键值对，输出到字节输出流的文件中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    Properties pro = <span class="keyword">new</span> Properties();	<span class="comment">//创建Properties对象</span></span><br><span class="line">    pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>));	<span class="comment">//从read.txt中读取数据</span></span><br><span class="line">    pro.setProperty(<span class="string">"one"</span>, <span class="string">"111"</span>);	<span class="comment">//往对象中添加数据</span></span><br><span class="line">    Set&lt;String&gt; strings = pro.stringPropertyNames();	<span class="comment">//获取对象所有键名称的集合</span></span><br><span class="line">	<span class="keyword">for</span> (String key : strings ) &#123;	<span class="comment">//遍历集合并打印</span></span><br><span class="line">		System.out.println(key+<span class="string">" ‐‐ "</span>+pro.getProperty(key));</span><br><span class="line">	&#125;</span><br><span class="line">    pro.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"write.txt"</span>),<span class="string">"Saving"</span>);	<span class="comment">//将对象的信息输出到文件中</span></span><br></pre></td></tr></table></figure>

<h2 id="Day10【缓冲流、转换流、序列化流】"><a href="#Day10【缓冲流、转换流、序列化流】" class="headerlink" title="Day10【缓冲流、转换流、序列化流】"></a>Day10【缓冲流、转换流、序列化流】</h2><h4 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1. 缓冲流"></a>1. 缓冲流</h4><h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> ：创建一个 新的缓冲输入流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> ： 创建一个新的缓冲输出流。</span></span><br></pre></td></tr></table></figure>

<h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> ：创建一个 新的缓冲输入流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out)</span> ： 创建一个新的缓冲输出流。</span></span><br><span class="line"><span class="function"><span class="comment">//特有方法</span></span></span><br><span class="line"><span class="function">BufferedReader： <span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> : 读一行文字。</span></span><br><span class="line"><span class="function">BufferedWriter： <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> : 写一行行分隔符,由系统属性定义符号。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过缓冲流复制文件，代码演示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedOutputStream bos = </span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"des.jpg"</span>));</span><br><span class="line">        BufferedInputStream bis = </span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src.jpg"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close(); &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-字符集"><a href="#2-字符集" class="headerlink" title="2. 字符集"></a>2. 字符集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>ASCII字符集</strong> ：基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了<br>21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>Unicode字符集</strong> ：为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国<br>码，其中最为常用的是UTF-8编码：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3. 转换流"></a>3. 转换流</h4><h5 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">转换流java.io.InputStreamReader ，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定</span><br><span class="line">的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。</span><br><span class="line">InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。</span><br></pre></td></tr></table></figure>

<h5 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符</span><br><span class="line">编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。</span><br><span class="line">OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将GBK编码的文件转换为UTF-8编码，代码演示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        OutputStreamWriter osw = </span><br><span class="line">            <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"U8code.txt"</span>));</span><br><span class="line">        InputStreamReader isr = </span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"GBKcode.txt"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            osw.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java提供了一种对象序列化的机制，使【内存中对象的数据】与【硬盘中文件里的数据】可以相互转化。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。</span><br></pre></td></tr></table></figure>

<h5 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span>：创建一个指定OutputStream的序列化流对象。</span></span><br><span class="line"><span class="function"><span class="comment">//写出方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span> <span class="params">(Object obj)</span> : 将指定的对象写出。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>序列化操作注意事项：</strong></p>
<ol>
<li>要实现序列化的类必须实现<code>java.io.Serializable</code>接口，否则会抛出NotSerializableException异常。</li>
<li>被瞬态<code>transient</code>或静态<code>static</code>修饰的属性不会被序列化。</li>
</ol>
</blockquote>
<h5 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span> ： 创建一个指定InputStream的ObjectInputStream。</span></span><br><span class="line"><span class="function"><span class="comment">//读取方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span> <span class="params">()</span> : 读取一个对象。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>serialVersionUID序列版本号：</strong>Serializable 接口给需要序列化的类，提供了一个序列版本号，目的在于验证序列化的对象和对应类是否版本匹配。如果对类进行和修改，那么其序列标本号也会发生修改。可通过在类中写死序列版本号，使修改后的类依然能够匹配序列化的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化代码演示</span></span><br><span class="line"><span class="comment">//定义学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8206478034432139083L</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ObjectOutputStream oos =</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Student.txt"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Student(<span class="string">"Eric"</span>, <span class="number">20</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois =</span><br><span class="line">            <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Student.txt"</span>));</span><br><span class="line">        Student stu = (Student)ois.readObject();</span><br><span class="line">        System.out.println(stu); <span class="comment">//Student&#123;name='Eric', age=20&#125;</span></span><br><span class="line">        ois.close();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-打印流"><a href="#5-打印流" class="headerlink" title="5. 打印流"></a>5. 打印流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.PrintStream 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</span><br></pre></td></tr></table></figure>

<h5 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintStream</span><span class="params">(String fileName)</span> ： 使用指定的文件名创建一个新的打印流。</span></span><br><span class="line"><span class="function"><span class="comment">//改变打印流向</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">	System.setOut(ps);</span><br><span class="line">	System.out.println(<span class="string">"Hello,World"</span>);&#125; <span class="comment">//在ps.txt中输出Hello,World</span></span><br></pre></td></tr></table></figure>



<h2 id="Day11【网络编程】"><a href="#Day11【网络编程】" class="headerlink" title="Day11【网络编程】"></a>Day11【网络编程】</h2><h4 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1. 软件结构"></a>1. 软件结构</h4><ul>
<li>C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
<li>B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</li>
</ul>
<h4 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2. 网络通信协议"></a>2. 网络通信协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">分层</th>
<th align="center">协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">HTTP/FTP/TFTP/SMTP/SNMP/DNS</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">TCP/UDP</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">ICMP/IGMP/IP/ARP/RARP</td>
</tr>
<tr>
<td align="center">数据链路层+物理层</td>
<td align="center">由底层网络定义的协议</td>
</tr>
</tbody></table>
<h4 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3. TCP协议"></a>3. TCP协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，</span><br><span class="line">在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>三次握手建立连接：</strong>在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ol>
<li>客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>客户端再次向服务器端发送确认信息，确认连接。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>四次挥手断开连接：</strong>客户端与服务器之间的四次交互后断开，保证了数据的完整性。</p>
<ol>
<li>客户端先向服务器发送断开请求，问询服务器是否可以断开（说明客户端没有数据要传输了）</li>
<li>服务器向客户端发送数据，需要客户端确认（说明服务器没有数据要传输了）</li>
<li>客户端再次问询服务器是否可以断开连接</li>
<li>断开连接</li>
</ol>
</blockquote>
<h4 id="4-UDP协议"><a href="#4-UDP协议" class="headerlink" title="4. UDP协议"></a>4. UDP协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。</span><br></pre></td></tr></table></figure>

<h4 id="5-IP地址"><a href="#5-IP地址" class="headerlink" title="5. IP地址"></a>5. IP地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设</span><br><span class="line">备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IP地址分类：</strong></p>
<ul>
<li>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如<code>192.168.65.100</code>，最多可以表示42亿个。有资料显示，全球IPv4地址在2011年2月分配完毕。</li>
<li>IPv6：采用128位地址长度，每16个字节一组，分成8组十六进制数，解决了网络地址资源数量不够的问题。表示成：<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code> 。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看本机IP地址，在控制台输入：<code>ipconfig</code></li>
<li>检查网络是否连通，在控制台输入：<code>ping 空格 IP地址</code></li>
<li>本机IP地址：<code>127.0.0.1</code></li>
</ul>
</blockquote>
<h4 id="6-端口号"><a href="#6-端口号" class="headerlink" title="6. 端口号"></a>6. 端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络的通信，本质上是两个进程（应用程序）的通信，端口号可以标识设备中的不同进程（应用程序）。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用两个字节表示的整数，它的取值范围是0~65535。</p>
<p>0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。</p>
<p>常用端口号：</p>
<ol>
<li>网络端口 https:443  http:80</li>
<li>数据库  mysql:3306  oracle:1521</li>
<li>Tomcat服务器:8080</li>
</ol>
</blockquote>
<p><strong>【协议+ IP地址+ 端口号】</strong> 三元组合可以标识网络中的进程，进程间的通信可以利用这个标识与其它进程交互。</p>
<h4 id="7-Socket类"><a href="#7-Socket类" class="headerlink" title="7. Socket类"></a>7. Socket类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.Socket类表示客户端。创建Socket对象向服务器发出连接请求，服务器响应请求，两者建立连接开始通信。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port)</span> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是<span class="keyword">null</span>，则相当于指定地址为回送地址。</span></span><br><span class="line"><span class="function"><span class="comment">//成员方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span>：返回此套接字的输入流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span>：返回此套接字的输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>：关闭此套接字,关闭socket也将关闭相关的InputStream和OutputStream 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownOutput</span><span class="params">()</span>：禁用此套接字的输出流,任何先前写出的数据将被发送，随后终止输出流。</span></span><br></pre></td></tr></table></figure>

<h4 id="8-ServerSocket类"><a href="#8-ServerSocket类" class="headerlink" title="8. ServerSocket类"></a>8. ServerSocket类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.ServerSocket类表示服务端。创建ServerSocket 对象，相当于开启一个服务，并等待客户端的连接。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span>：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</span></span><br><span class="line"><span class="function"><span class="comment">//成员方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span>：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bys);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys,<span class="number">0</span>,len));</span><br><span class="line">        System.out.println(socket);</span><br><span class="line">        socket.close();&#125;&#125;</span><br><span class="line"><span class="comment">//服务端代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bys);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"收到谢谢"</span>.getBytes());</span><br><span class="line">        System.out.println(server);</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-文件上传优化分析"><a href="#9-文件上传优化分析" class="headerlink" title="9. 文件上传优化分析"></a>9. 文件上传优化分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件上传案例服务端代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept(); ②</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>); ①</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.getOutputStream().write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">        fos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line"><span class="comment">//文件上传案例客服端代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src.jpg"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput(); <span class="comment">//避免阻塞问题</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">        fis.close();</span><br></pre></td></tr></table></figure>

<h5 id="①-文件名称写死的问题"><a href="#①-文件名称写死的问题" class="headerlink" title="① 文件名称写死的问题"></a>① 文件名称写死的问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</span><br><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br></pre></td></tr></table></figure>

<h5 id="②-循环接收的问题"><a href="#②-循环接收的问题" class="headerlink" title="② 循环接收的问题"></a>② 循环接收的问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">	Socket socket = server.accept();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="③-效率问题"><a href="#③-效率问题" class="headerlink" title="③ 效率问题"></a>③ 效率问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">	Socket socket = serverSocket.accept();</span><br><span class="line">	<span class="comment">// socket 交给子线程处理.</span></span><br><span class="line">	<span class="keyword">new</span> Thread(() ‐&gt; &#123;</span><br><span class="line">		......</span><br><span class="line">		InputStream is = socket.getInputStream();</span><br><span class="line">		......</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day12【函数式接口】"><a href="#Day12【函数式接口】" class="headerlink" title="Day12【函数式接口】"></a>Day12【函数式接口】</h2><h4 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有且仅有一个抽象方法的接口。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@FunctionalInterface注解：使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。</p>
</blockquote>
<h4 id="2-Lambda的延迟执行"><a href="#2-Lambda的延迟执行" class="headerlink" title="2. Lambda的延迟执行"></a>2. Lambda的延迟执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无论level是多少，都会先把字符串拼接并传入方法内。如果level不符合要求，拼接操作就白做了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">	String msgB = <span class="string">"World"</span>;</span><br><span class="line">	String msgC = <span class="string">"Java"</span>;</span><br><span class="line">	log(<span class="number">1</span>, msgA + msgB + msgC);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">	System.out.println(msg);&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Lambda的延迟执行进行优化，只有满足要求的时候才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">	String msgB = <span class="string">"World"</span>;</span><br><span class="line">	String msgC = <span class="string">"Java"</span>;</span><br><span class="line">	log(<span class="number">1</span>, () ‐&gt; msgA + msgB + msgC );&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">		System.out.println(builder.buildMessage());&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">buildMessage</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Supplier接口"><a href="#3-Supplier接口" class="headerlink" title="3. Supplier接口"></a>3. Supplier接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Supplier&lt;T&gt;接口用来获取一个泛型参数指定类型的对象数据。</span><br><span class="line">仅包含一个无参的抽象方法：<span class="function">T <span class="title">get</span><span class="params">()</span> 。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String s = getString(() -&gt; <span class="string">"Eric"</span> + <span class="string">"loset"</span>);</span><br><span class="line">	System.out.println(s);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sup.get();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Consumer接口"><a href="#4-Consumer接口" class="headerlink" title="4. Consumer接口"></a>4. Consumer接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt; 接口与Supplier接口相反，是消费一个数据，其数据类型由泛型决定。</span><br><span class="line">包含一个有参的抽象方法<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span>，一个默认方法<span class="title">andThen</span><span class="params">()</span>,可以组合多个步骤。</span></span><br><span class="line"><span class="function"><span class="comment">//andThen方法源码：</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">	Objects.requireNonNull(after);</span><br><span class="line">	<span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	method(<span class="string">"方法"</span>,</span><br><span class="line">	(t) -&gt; System.out.print(t + <span class="string">"1"</span>),</span><br><span class="line">	(t) -&gt; System.out.print(t + <span class="string">"2"</span>),</span><br><span class="line">	(t) -&gt; System.out.print(t + <span class="string">"3"</span>));&#125;       <span class="comment">//方法1方法2方法3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2, 								Consumer&lt;String&gt; con3)</span></span>&#123;</span><br><span class="line">	con1.andThen(con2).andThen(con3).accept(name);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Predicate接口"><a href="#5-Predicate接口" class="headerlink" title="5. Predicate接口"></a>5. Predicate接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Predicate&lt;T&gt;接口返回一个<span class="keyword">boolean</span>值结果，用于对某种类型的数据进行判断。</span><br><span class="line">接口中包含一个抽象方法： <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span>，用于条件判断的场景。</span></span><br><span class="line"><span class="function">接口中包含三个默认方法： <span class="title">and</span><span class="params">()</span>,<span class="title">or</span><span class="params">()</span>,<span class="title">negate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdefg"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s,</span><br><span class="line">                (str) -&gt; str.length() &gt; <span class="number">20</span>,</span><br><span class="line">                (str) -&gt; str.contains(<span class="string">"bc"</span>));</span><br><span class="line">        System.out.println(b);&#125; 	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  	Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.or(pre2).test(s);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-Function接口"><a href="#6-Function接口" class="headerlink" title="6. Function接口"></a>6. Function接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据。</span><br><span class="line">包含一个有参的抽象方法 <span class="function">R <span class="title">apply</span><span class="params">(T t)</span>，一个默认方法<span class="title">andThen</span><span class="params">()</span>，可以组合多个步骤。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str, Function&lt;String, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = function.apply(str);</span><br><span class="line">	System.out.println(num + <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	method(<span class="string">"100"</span>,s-&gt;Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day13【Stream流、方法引用】"><a href="#Day13【Stream流、方法引用】" class="headerlink" title="Day13【Stream流、方法引用】"></a>Day13【Stream流、方法引用】</h2><h4 id="1-流式思想"><a href="#1-流式思想" class="headerlink" title="1. 流式思想"></a>1. 流式思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream（流）是一个来自数据源（集合、数组等）的元素队列，元素是特定类型的对象，形成一个队列。</span><br><span class="line">Java中的Stream并不会存储元素，而是按需计算。中间操作都会返回流对象本身，这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。</span><br><span class="line">这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Stream流支持并行，效率高</p>
</blockquote>
<h4 id="2-获取流"><a href="#2-获取流" class="headerlink" title="2. 获取流"></a>2. 获取流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单列集合中，Collecion接口中加入了stream方法用于获取流</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Stream&lt;String&gt; collectionStream = c.stream();</span><br><span class="line"><span class="comment">//双列集合中，获取流需要先获得key集合或value集合或者entry集合</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line"><span class="comment">//要获取数组的流对象，可以通过Stream接口中提供的静态方法of</span></span><br><span class="line">String[] arr = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream = Stream.of(arr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h4><blockquote>
<ul>
<li><strong>延迟方法：</strong>返回值类型仍然是Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</li>
<li><strong>终结方法：</strong>返回值类型不再是Stream 接口自身类型的方法，因此不再支持类似StringBuilder 那样的链式调用。终结方法包括count 和forEach 方法。</li>
</ul>
</blockquote>
<h5 id="forEach：逐一处理"><a href="#forEach：逐一处理" class="headerlink" title="forEach：逐一处理"></a>forEach：逐一处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="filter：过滤"><a href="#filter：过滤" class="headerlink" title="filter：过滤"></a>filter：过滤</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="map：映射"><a href="#map：映射" class="headerlink" title="map：映射"></a>map：映射</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="count：统计个数"><a href="#count：统计个数" class="headerlink" title="count：统计个数"></a>count：统计个数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="limit：取用前几个"><a href="#limit：取用前几个" class="headerlink" title="limit：取用前几个"></a>limit：取用前几个</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。</p>
</blockquote>
<h5 id="skip：跳过前几个"><a href="#skip：跳过前几个" class="headerlink" title="skip：跳过前几个"></a>skip：跳过前几个</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</p>
</blockquote>
<h5 id="concat：组合"><a href="#concat：组合" class="headerlink" title="concat：组合"></a>concat：组合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="collect：将流元素生成集合"><a href="#collect：将流元素生成集合" class="headerlink" title="collect：将流元素生成集合"></a>collect：将流元素生成集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">Set&lt;T&gt; set = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<h5 id="toArray：将流元素生成数组"><a href="#toArray：将流元素生成数组" class="headerlink" title="toArray：将流元素生成数组"></a>toArray：将流元素生成数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = stream.toArray();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">// 第一个队伍只要名字为3个字的成员姓名；// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二个队伍只要姓张的成员姓名；// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 将两个队伍合并为一个队伍；// 根据姓名创建Person对象；// 打印整个队伍的Person对象信息。</span></span><br><span class="line">Stream.concat(streamOne, streamTwo).map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Stream分为三类方法：</p>
<ol>
<li>初始操作，将数据源转换为Stream流</li>
<li>中间操作，调用之后返回值也是Stream对象</li>
<li>终止操作，调用之后返回值不是Streasm对象</li>
</ol>
<p>流中的数据<strong>只能被消费一次</strong>，流在操作过程中，如果执行的是初始操作、中间操作，那么实际上<strong>不会对流元素进行处理</strong>，只有在进行Stream的<strong>终止操作的时候才执行</strong></p>
</blockquote>
<h4 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双冒号::为引用运算符，它所在的表达式被称为方法引用，是简化Lambda的书写。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。前提是括号内的所有内容都是依赖于一个对象的某个方法实现的，并不是所有的Lambda表达式都能被简化为方法引用。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i, Function&lt;Integer, Integer&gt; f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f.apply(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(method(-<span class="number">5</span>, Math::abs));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组的构造器引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] ints = createArray(<span class="number">5</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">	System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> i, Function&lt;Integer, <span class="keyword">int</span>[]&gt; f) &#123;</span><br><span class="line">	<span class="keyword">return</span> f.apply(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的构造器引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	personBuilder(<span class="string">"Eric"</span>, (Person::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">personBuilder</span><span class="params">(String s, Function&lt;String, Person&gt; f)</span> </span>&#123;</span><br><span class="line">	Person p = f.apply(s);</span><br><span class="line">	System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Day14【单元测试、反射、注解】"><a href="#Day14【单元测试、反射、注解】" class="headerlink" title="Day14【单元测试、反射、注解】"></a>Day14【单元测试、反射、注解】</h2><h4 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试分类：</span><br><span class="line">	1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值，不用懂程序的知识也可以进行测试</span><br><span class="line">	2. 白盒测试：需要写代码的，关注程序具体的执行流程。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>白盒测试</strong>步骤：</p>
<ol>
<li>定义一个测试类，类名为被测试类名+Test（CalculatorTest）</li>
<li>定义一个测试方法，可以独立运行，方法名为test+被测方法名（testAdd() ）</li>
</ol>
<p>方法的返回值：void；参数列表：空参</p>
<ol start="3">
<li>给方法加@Test</li>
<li>导入junit依赖环境</li>
</ol>
</blockquote>
<blockquote>
<p>注意事项：</p>
<ol>
<li>使用断言操作<code>Assert.assertEquals(期望的结果,运算的结果)</code>来处理结果</li>
<li>红色结果为失败，绿色结果为成功</li>
<li>@Before：修饰的方法会在测试方法之前被自动执行</li>
<li>@After：修饰的方法会在测试方法执行之后自动被执行</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化..."</span>);&#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> add = c.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>, add);&#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> sub = c.sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(-<span class="number">1</span>, sub);&#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"释放资源"</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-反射"><a href="#2-反射" class="headerlink" title="2. 反射"></a>2. 反射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射：将类的各个组成部分封装为其他对象，这就是反射机制。通过反射，可以在程序运行过程中操作这些对象，是框架的基础。运用反射可以解耦，提高程序的可拓展性。</span><br></pre></td></tr></table></figure>

<h5 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Class.forName(<span class="string">"全类名"</span>)：用于配置文件</span><br><span class="line">	Class personClass = Class.forName(<span class="string">"Reflect.Person"</span>);</span><br><span class="line"><span class="number">2</span>. 类名.class：用于参数的传递</span><br><span class="line">	Class personClass = Person.class;</span><br><span class="line"><span class="number">3</span>. 对象.getClass()：用于对象的获取字节码的方式</span><br><span class="line">	Person p = <span class="keyword">new</span> Person();	Class personClass = p.getClass();</span><br></pre></td></tr></table></figure>

<h5 id="操作成员变量对象"><a href="#操作成员变量对象" class="headerlink" title="操作成员变量对象"></a>操作成员变量对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取成员变量对象</span></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>：获取指定名称的<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span>：获取所有<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>：获取指定名称的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>：获取所有的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function"><span class="comment">//设置成员变量方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span>：设置值</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(Object obj)</span>：获取值</span></span><br><span class="line"><span class="function"><span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span>：忽略访问权限修饰符的安全检查（暴力反射）</span></span><br></pre></td></tr></table></figure>

<h5 id="操作构造方法对象"><a href="#操作构造方法对象" class="headerlink" title="操作构造方法对象"></a>操作构造方法对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取构造方法对象</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(parameterTypes.class)</span>：获取指定参数列表的<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span>：获取所有<span class="keyword">public</span>修饰的构造方法 </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(parameterTypes.class)</span>：获取指定参数列表的成员变量</span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>：获取所有的构造方法，不考虑修饰符  </span></span><br><span class="line"><span class="function"><span class="comment">//创建对象的方法</span></span></span><br><span class="line"><span class="function"> T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="操作成员方法对象"><a href="#操作成员方法对象" class="headerlink" title="操作成员方法对象"></a>操作成员方法对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取成员方法对象</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name，parameterTypes.class)</span>：获取指定名称和参数列表的<span class="keyword">public</span>修饰的方法</span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span>：获取所有<span class="keyword">public</span>修饰的成员方法</span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name，parameterTypes.class)</span>：获取指定名称和参数列表的成员方法</span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span>：获取所有的成员方法，不考虑修饰符（含继承的方法）    </span></span><br><span class="line"><span class="function"><span class="comment">//执行方法</span></span></span><br><span class="line"><span class="function">method <span class="title">invoke</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-“框架”案例"><a href="#3-“框架”案例" class="headerlink" title="3. “框架”案例"></a>3. “框架”案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	配置文件ClassMessage.properties:</span></span><br><span class="line"><span class="comment">//	className = Reflect.Person</span></span><br><span class="line"><span class="comment">//	methodName = eat</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">	pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"ClassMessage.properties"</span>));</span><br><span class="line">	String className = pro.getProperty(<span class="string">"className"</span>);	<span class="comment">//Reflect.Person</span></span><br><span class="line">	String methodName = pro.getProperty(<span class="string">"methodName"</span>);	<span class="comment">//eat</span></span><br><span class="line">	Class cls = Class.forName(className);</span><br><span class="line">	Object o = cls.getConstructor().newInstance();</span><br><span class="line">	Method method = cls.getMethod(methodName);</span><br><span class="line">	method.invoke(o);	<span class="comment">//调用了Person类中的eat方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注解（Annotation），也叫元数据。一种代码级别的说明，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。JDK1.5及以后版本引入的特性。</span><br><span class="line">格式：@注解名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用分类：</p>
<ol>
<li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li>
<li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li>
<li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li>
</ol>
</blockquote>
<blockquote>
<p>JDK中预定义的一些注解：</p>
<ul>
<li>@override：方法重写注解</li>
<li>@Deprecated：过期注解</li>
<li>@SuppressWarnings：压制警告，将当前所有的类警告都去除</li>
</ul>
<p>一般传递参数all  @SuppressWarnings(“all”)</p>
</blockquote>
<h4 id="5-自定义注解"><a href="#5-自定义注解" class="headerlink" title="5. 自定义注解"></a>5. 自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">	元注解</span><br><span class="line">	<span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">		属性列表;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注解本质上就是一个接口，该接口<strong>默认继承Annotation接口</strong>：
<code>public interface MyAnno extends java.lang.annotation.Annotation {}</code></p>
</blockquote>
<blockquote>
<p><strong>注解接口中的要求：</strong></p>
<ul>
<li><strong>接口中的抽象方法称为属性</strong>，返回值类型为：</li>
</ul>
<p>①基本数据类型；②String；③枚举；④注解；⑤以上类型的数组</p>
<ul>
<li>定义了属性，在使用时需要给属性赋值，若定义时已经给了默认值，可以不用赋值，如果只有一个属性需要赋值，并且属性的名称是value，则赋值的时候，value的字样可以省略</li>
<li>数组赋值时，需要使用{}包裹，如果数组中只有一个值，则{}省略</li>
</ul>
</blockquote>
<h4 id="6-元注解"><a href="#6-元注解" class="headerlink" title="6. 元注解"></a>6. 元注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于描述注解的注解。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>@Target(ElementType)</strong>：描述注解能够作用的位置</p>
<p>ElementType取值：</p>
<ol>
<li>ElementType.TYPE：可以作用于类上</li>
<li>ElementType.METHOD：可以作用于方法上</li>
<li>ElementType.FIELD：可以作用于成员变量上</li>
</ol>
<p><strong>@Retention(RetentionPolicy)</strong>：描述注解被保留的阶段</p>
<p>RetentionPolicy取值：</p>
<ol>
<li>RetentionPolicy.RUNTIME：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li>
<li>RetentionPolicy.CLASS：当前被描述的注解，会保留到class字节码文件中，不会被JVM读取</li>
<li>RetentionPolicy.SOURCE：当前被描述的注解，不会被class字节码文件保留</li>
</ol>
<p><strong>@Documented</strong>：描述注解是否被抽取到api文档中</p>
<p><strong>@Inherited</strong>：描述注解是否被子类继承</p>
</blockquote>
<h4 id="7-”测试框架“案例"><a href="#7-”测试框架“案例" class="headerlink" title="7. ”测试框架“案例"></a>7. ”测试框架“案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">	Class cls = c.getClass();</span><br><span class="line">	<span class="comment">//获取类中的所有方法</span></span><br><span class="line">    Method[] methods = cls.getMethods();</span><br><span class="line">    <span class="comment">//创建输出流和记录异常次数的变量count</span></span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"error.txt"</span>));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;  <span class="comment">//遍历所有方法，筛选出被@Check标记的方法</span></span><br><span class="line">		<span class="keyword">if</span> (method.isAnnotationPresent(Check.class)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				method.invoke(c);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				count++;</span><br><span class="line">                <span class="comment">//将异常打印到日志文件中</span></span><br><span class="line">                bw.write(method.getName() + <span class="string">"方法出异常了"</span>);</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.write(<span class="string">"异常的名称"</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.write(<span class="string">"异常的原因"</span> + e.getCause());</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.write(<span class="string">"-----------------"</span>);</span><br><span class="line">                bw.newLine();&#125;&#125;&#125;</span><br><span class="line">	bw.write(<span class="string">"本次测试共出现了"</span> + count + <span class="string">"次异常"</span>);</span><br><span class="line">	bw.close();&#125;</span><br></pre></td></tr></table></figure>

<h1 id="数据库知识点总结"><a href="#数据库知识点总结" class="headerlink" title="数据库知识点总结"></a>数据库知识点总结</h1><h3 id="1-数据库的基本概念"><a href="#1-数据库的基本概念" class="headerlink" title="1. 数据库的基本概念"></a>1. 数据库的基本概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">数据库(DataBase,简称:DB)，用于存储和管理数据的仓库。</span><br><span class="line">类比：数据库：文件夹(仓库)；表：文件（货架子）； 数据：数据（货物）。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>数据库的特点：</p>
<ol>
<li>持久化存储数据，数据库就是一个文件系统</li>
<li>方便存储和管理数据</li>
<li>使用了统一的方式操作数据库 – SQL</li>
</ol>
</blockquote>
<h3 id="2-MySQL配置操作"><a href="#2-MySQL配置操作" class="headerlink" title="2. MySQL配置操作"></a>2. MySQL配置操作</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">服务启动:</span><br><span class="line">	net <span class="keyword">start</span> mysql：启动mysql的服务</span><br><span class="line">	net <span class="keyword">stop</span> mysql：关闭mysql服务</span><br><span class="line">登录:</span><br><span class="line">	mysql -u用户名 -p密码</span><br><span class="line">	mysql -hip地址 -u用户名 -p连接目标的密码</span><br><span class="line">退出:</span><br><span class="line">	<span class="keyword">exit</span>/quit</span><br><span class="line">配置文件 my.ini</span><br></pre></td></tr></table></figure>

<h3 id="3-SQL概念"><a href="#3-SQL概念" class="headerlink" title="3. SQL概念"></a>3. SQL概念</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Structured Query Language：结构化查询语言。</span><br><span class="line">SQL定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>SQL通用语法：</strong></p>
<ol>
<li>SQL 语句可以单行或多行书写，以分号结尾。</li>
<li>可使用空格和缩进来增强语句的可读性。</li>
<li>MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。</li>
<li>注释：<ul>
<li>单行注释: – 注释内容 或 # 注释内容(mysql 特有) </li>
<li>多行注释: /* 注释 */</li>
</ul>
</li>
</ol>
</blockquote>
<blockquote>
<p><strong>SQL分类：</strong></p>
<ul>
<li><strong>DDL（Data Definition Language）</strong>数据定义语言：用来定义数据库对象：数据库，表，列等。</li>
<li><strong>DML（Data Manipulation Language）</strong>数据操作语言：用来对数据库中表的数据进行增删改。</li>
<li><strong>DQL（Data Query Language）</strong>数据查询语言：用来查询数据库中表的记录(数据)。</li>
<li><strong>DCL（Data Control Language）</strong>数据控制语言：用来定义数据库的访问权限和安全级别，创建用户。</li>
</ul>
</blockquote>
<h3 id="4-DDL-定义数据库"><a href="#4-DDL-定义数据库" class="headerlink" title="4. DDL 定义数据库"></a>4. DDL 定义数据库</h3><h4 id="操作数据库"><a href="#操作数据库" class="headerlink" title="操作数据库"></a>操作数据库</h4><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>create database <code>数据库名称</code></td>
<td>创建数据库</td>
</tr>
<tr>
<td>创建</td>
<td>create database if not exists <code>数据库名称</code></td>
<td>创建数据库，判断不存在，再创建</td>
</tr>
<tr>
<td>创建</td>
<td>create database <code>数据库名称</code> character set <code>字符集名称</code></td>
<td>创建数据库，并指定字符集</td>
</tr>
<tr>
<td>查询</td>
<td>show databases</td>
<td>查询所有数据库的名称</td>
</tr>
<tr>
<td>查询</td>
<td>show create database <code>数据库名称</code></td>
<td>查询某个数据库的字符集/创建语句</td>
</tr>
<tr>
<td>修改</td>
<td>alter database<code>数据库名称</code> character set <code>字符集名称</code></td>
<td>修改数据库的字符集</td>
</tr>
<tr>
<td>删除</td>
<td>drop database <code>数据库名称</code></td>
<td>删除数据库</td>
</tr>
<tr>
<td>删除</td>
<td>drop database if exists <code>数据库名称</code></td>
<td>判断数据库存在，存在再删除</td>
</tr>
<tr>
<td>使用</td>
<td>select database()</td>
<td>查询当前正在使用的数据库名称</td>
</tr>
<tr>
<td>使用</td>
<td>use <code>数据库名称</code></td>
<td>使用数据库</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：数据库的名称不可修改</strong></p>
</blockquote>
<h4 id="操作表"><a href="#操作表" class="headerlink" title="操作表"></a>操作表</h4><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>创建</td>
<td>create table <code>表名(列名1 数据类型1,....列名n 数据类型n)</code>;</td>
<td>创建一个表</td>
</tr>
<tr>
<td>创建</td>
<td>create table <code>表名</code> like <code>被复制的表名</code></td>
<td>复制表</td>
</tr>
<tr>
<td>查询</td>
<td>show tables</td>
<td>查询某个数据库中所有的表名称</td>
</tr>
<tr>
<td>查询</td>
<td>desc <code>表名</code></td>
<td>查询表结构</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> rename to <code>新的表名</code></td>
<td>修改表名</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> character set <code>字符集名称</code></td>
<td>修改表的字符集</td>
</tr>
<tr>
<td>修改</td>
<td>show create table <code>表名</code></td>
<td>查看表的字符集</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> add <code>列名 数据类型</code></td>
<td>添加一列</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> add <code>列名 数据类型</code> after <code>指定列名</code></td>
<td>在指定的列后添加一列</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> change <code>列名 新列别 新数据类型</code></td>
<td>修改列名称和数据类型</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> modify <code>列名 新数据类型</code></td>
<td>修改数据类型</td>
</tr>
<tr>
<td>修改</td>
<td>alter table <code>表名</code> drop <code>列名</code></td>
<td>删除列</td>
</tr>
<tr>
<td>删除</td>
<td>drop table <code>表名</code></td>
<td>删除表</td>
</tr>
<tr>
<td>删除</td>
<td>drop table  if exists <code>表名</code></td>
<td>判断表存在，存在再删除</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>数据类型：</strong></p>
<ol>
<li><strong>int</strong>：整数类型  <code>age int</code></li>
<li><strong>double</strong>：小数类型  <code>score double(5,2)</code></li>
<li><strong>date</strong>：日期，只包含年月日  <code>yyyy-MM-dd</code></li>
<li><strong>datetime</strong>：日期，包含年月日时分秒  <code>yyyy-MM-dd HH:mm:ss</code></li>
<li><strong>timestamp</strong>：时间戳，包含年月日时分秒  <code>yyyy-MM-dd HH:mm:ss</code>（默认使用系统当前时间赋值）    </li>
<li><strong>varchar</strong>：字符串  <code>name varchar(20)</code> （括号里数字为可接收最大字符数）</li>
</ol>
</blockquote>
<h3 id="5-DML-增删改表中数据"><a href="#5-DML-增删改表中数据" class="headerlink" title="5. DML 增删改表中数据"></a>5. DML 增删改表中数据</h3><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>insert into <code>表名</code> values <code>(值1,值2,...值n)</code></td>
<td>给表中每一列赋值</td>
</tr>
<tr>
<td>添加</td>
<td>insert into <code>表名(列名1,列名2,...列名n)</code>values<code>(值1,值2,...值n)</code></td>
<td>选择地给表中某一列赋值</td>
</tr>
<tr>
<td>删除</td>
<td>delete from <code>表名 [where 条件]</code></td>
<td>删除符合条件的记录</td>
</tr>
<tr>
<td>删除</td>
<td>truncate table <code>表名</code></td>
<td>删除整张表</td>
</tr>
<tr>
<td>修改</td>
<td>update <code>表名</code> set <code>列名1 = 值1, 列名2 = 值2,... [where 条件]</code></td>
<td>修改指定列的数据</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>除了数字类型，其他类型需要使用引号(单双都可以)引起来，数值类型加引号也不会报错，但是不推荐加</li>
<li>若要删除整表，推荐使用<code>truncate table</code>，效率高；<code>delete from</code> 内部采用逐个删除，效率低</li>
<li>若要修改多条记录，可以指定条件数据范围<code>in()</code></li>
</ol>
</blockquote>
<h3 id="6-DQL-查询表中记录"><a href="#6-DQL-查询表中记录" class="headerlink" title="6. DQL 查询表中记录"></a>6. DQL 查询表中记录</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">语法格式：</span><br><span class="line">	select</span><br><span class="line">		字段列表</span><br><span class="line">	from</span><br><span class="line">		表名列表</span><br><span class="line">	where</span><br><span class="line">		条件列表</span><br><span class="line">	group by</span><br><span class="line">		分组字段</span><br><span class="line">	having</span><br><span class="line">		分组之后的条件</span><br><span class="line">	order by</span><br><span class="line">		排序</span><br><span class="line">	limit</span><br><span class="line">		分页限定</span><br></pre></td></tr></table></figure>

<h4 id="基础查询"><a href="#基础查询" class="headerlink" title="基础查询"></a>基础查询</h4><blockquote>
<ol>
<li><p>多个字段的查询：<code>select 字段名1，字段名2... from 表名；</code>(*来替代查询所有字段)</p>
</li>
<li><p>去除重复：<code>select</code> <strong>distinct</strong> <code>字段名1，字段名2... from 表名；</code></p>
</li>
<li><p>计算列：一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算）</p>
</li>
<li><p>null参与的运算，计算结果都为null。<code>ifnull(表达式1,表达式2)：</code></p>
<p>表达式1：需要判断是否为null的字段；表达式2：若该字段为null后的替换值</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; 5. 起别名：as（as也可以省略）</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h4><blockquote>
<ol>
<li><p>where子句后跟条件</p>
<ol start="2">
<li>运算符</li>
</ol>
<ul>
<li>&lt;&gt; (相当于!=)</li>
<li>BETWEEN…AND  </li>
<li>IN( 集合) </li>
</ul>
<ol start="3">
<li>模糊查询 LIKE：占位符：<code>_</code>：单个任意字符；<code>%</code>：多个任意字符（含0个）</li>
<li>IS NULL (是否为空，不能用=null判断) ；IS NOT NULL：不为空</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="排序查询"><a href="#排序查询" class="headerlink" title="排序查询"></a>排序查询</h4><blockquote>
<ol>
<li>语法：<code>order by 排序字段1 排序方式1 ，排序字段2 排序方式2...</code></li>
<li>排序方式：ASC：升序，默认的；DESC：降序</li>
<li>如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件</li>
</ol>
</blockquote>
<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><blockquote>
<p><strong>将一列数据作为一个整体，进行纵向的计算，需要排除null值</strong></p>
<ol>
<li>count：计算个数（<code>count(*)</code>：只要该数据有一列不为空）</li>
<li>max：计算最大值</li>
<li>min：计算最小值</li>
<li>sum：计算和</li>
<li>avg：计算平均值</li>
</ol>
</blockquote>
<h4 id="分组查询"><a href="#分组查询" class="headerlink" title="分组查询"></a>分组查询</h4><blockquote>
<p>语法：group by 分组字段；</p>
<p>要求：查询条件的字段只能是<strong>分组字段</strong>和<strong>聚合函数</strong></p>
</blockquote>
<h4 id="分页查询"><a href="#分页查询" class="headerlink" title="分页查询"></a>分页查询</h4><blockquote>
<ol>
<li>语法：limit 要开始显示的索引，每页查询的条数；</li>
<li>公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数</li>
<li>limit 是一个MySQL”方言”</li>
</ol>
</blockquote>
<blockquote>
<p><strong>where 和 having 的区别？</strong></p>
<ol>
<li>where 在分组之前进行限定，如果不满足条件，则不参与分组；having在分组之后进行限定，如果不满足结果，则不会被查询出来。</li>
<li>where 后不可以跟聚合函数，having可以进行聚合函数的判断。</li>
</ol>
</blockquote>
<h3 id="7-约束"><a href="#7-约束" class="headerlink" title="7. 约束"></a>7. 约束</h3><h4 id="非空约束"><a href="#非空约束" class="headerlink" title="非空约束"></a>非空约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">not null，某一列的值不能为null</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>创建表时，添加非空约束：CREATE TABLE stu(id INT,NAME VARCHAR(20) <strong>NOT NULL</strong>);</li>
<li>创建表后，添加非空约束：ALTER TABLE stu MODIFY NAME VARCHAR(20) <strong>NOT NULL</strong>;</li>
<li>删除非空约束：ALTER TABLE stu <strong>MODIFY</strong> NAME VARCHAR(20);</li>
</ol>
</blockquote>
<h4 id="唯一约束"><a href="#唯一约束" class="headerlink" title="唯一约束"></a>唯一约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unique，某一列的值不能重复，但可以有多个NULL值</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>创建表时，添加唯一约束：CREATE TABLE stu(id INT, NAME VARCHAR(20) <strong>UNIQUE</strong> );</li>
<li>创建表后，添加唯一约束：ALTER TABLE stu MODIFY NAME VARCHAR(20) <strong>UNIQUE</strong>;</li>
<li>删除唯一约束：ALTER TABLE stu <strong>DROP INDEX</strong> NAME;</li>
</ol>
</blockquote>
<h4 id="主键约束"><a href="#主键约束" class="headerlink" title="主键约束"></a>主键约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">primary key，非空且唯一，一张表只能有一列的值设为主键，是表中记录的唯一标识，一般是数据无关列</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>创建表时，添加主键约束：CREATE TABLE stu(id INT <strong>PRIMARY KEY</strong>, NAME VACHAR(20));</li>
<li>创建表后，添加主键约束：ALTER TABLE stu MODIFY id INT <strong>PRIMARY KEY</strong>;</li>
<li>删除主键约束：ALTER TABLE stu <strong>DROP PRIMARY KEY</strong>;</li>
<li>主键约束添加自增长：id INT PRIMARY KEY <strong>AUTO_INCREMENT</strong>；</li>
</ol>
</blockquote>
<h4 id="外键约束"><a href="#外键约束" class="headerlink" title="外键约束"></a>外键约束</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">foreign key，让表于表产生关系，从而保证数据的正确性</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>创建表时，添加外键约束：</li>
</ol>
<p><strong>constraint</strong> <code>外键名称</code> <strong>foreign key</strong><code>(外键列名称)</code> <strong>references</strong> <code>主表名称(主键列名称)</code>  <strong>①</strong></p>
<p>外键列名称为<strong>受约束的列</strong>名称，主键列名称为<strong>约束别人的列</strong>名称；</p>
<p>外键名称可以自定义，起到删除时索引的作用 。一般格式：当前表名 _ 外键表名 _ fk</p>
<ol start="2">
<li>创建表之后，添加外键约束：ALTER TABLE stu ADD + ①</li>
<li>删除外键约束：ALTER TABLE stu DROP FOREIGN KEY <code>外键名称</code>；</li>
<li>级联操作：级联更新：ON UPDATE CASCADE ；级联删除：ON DELETE CASCADE </li>
</ol>
</blockquote>
<h3 id="8-数据库的设计"><a href="#8-数据库的设计" class="headerlink" title="8. 数据库的设计"></a>8. 数据库的设计</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">1. 一对一：实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。</span><br><span class="line">2. 一对多(多对一)：实现方式：在多的一方建立外键，指向一的一方的主键。</span><br><span class="line">3. 多对多：实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。</span><br><span class="line">-- 旅游网案例展示：一个旅游线路分类中有多个旅游线路；一个用户收藏多个线路，一个线路被多个用户收藏。</span><br><span class="line">/*创建旅游线路分类表 tab_category</span><br><span class="line">    cid 旅游线路分类主键，自动增长</span><br><span class="line">    cname 旅游线路分类名称非空，唯一，字符串 100</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_category (</span><br><span class="line">	cid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	cname VARCHAR(100) UNIQUE NOT NULL</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建旅游线路表 tab_route</span><br><span class="line">    rid 旅游线路主键，自动增长</span><br><span class="line">    rname 旅游线路名称非空，唯一，字符串 100</span><br><span class="line">    price 价格</span><br><span class="line">    rdate 上架时间，日期类型</span><br><span class="line">    cid 外键，所属分类</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_route(</span><br><span class="line">	rid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	rname VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">	price DOUBLE,</span><br><span class="line">	rdate DATE,</span><br><span class="line">	cid INT,</span><br><span class="line">	FOREIGN KEY (cid) REFERENCES tab_category(cid)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建用户表 tab_user</span><br><span class="line">    uid 用户主键，自增长</span><br><span class="line">    username 用户名长度 100，唯一，非空</span><br><span class="line">    password 密码长度 30，非空</span><br><span class="line">    name 真实姓名长度 100</span><br><span class="line">    birthday 生日</span><br><span class="line">    sex 性别，定长字符串 1</span><br><span class="line">    telephone 手机号，字符串 11</span><br><span class="line">    email 邮箱，字符串长度 100</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_user (</span><br><span class="line">	uid INT PRIMARY KEY AUTO_INCREMENT,</span><br><span class="line">	username VARCHAR(100) NOT NULL UNIQUE,</span><br><span class="line">	PASSWORD VARCHAR(30) NOT NULL,</span><br><span class="line">	NAME VARCHAR(100),</span><br><span class="line">	birthday DATE,</span><br><span class="line">	sex CHAR(1) DEFAULT &apos;男&apos;,</span><br><span class="line">	telephone VARCHAR(11),</span><br><span class="line">	email VARCHAR(100)</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line">/*创建收藏表 tab_favorite</span><br><span class="line">    rid 旅游线路 id，外键</span><br><span class="line">    date 收藏时间</span><br><span class="line">    uid 用户 id，外键</span><br><span class="line">    rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次</span><br><span class="line">*/</span><br><span class="line">CREATE TABLE tab_favorite (</span><br><span class="line">	rid INT,</span><br><span class="line">	FOREIGN KEY (rid) REFERENCES tab_route(rid),</span><br><span class="line">	DATE DATETIME,</span><br><span class="line">	uid INT,</span><br><span class="line">	FOREIGN KEY (uid) REFERENCES tab_user(uid),</span><br><span class="line">	PRIMARY KEY (rid,uid)  -- 联合主键</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<h3 id="9-数据库设计范式"><a href="#9-数据库设计范式" class="headerlink" title="9. 数据库设计范式"></a>9. 数据库设计范式</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 第一范式（1NF）：每一列都是不可分割的原子数据项</span><br><span class="line">2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除部分函数依赖）</span><br><span class="line">3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖）</span><br></pre></td></tr></table></figure>

<blockquote>
<p>几个概念：</p>
<ol>
<li>函数依赖：A–&gt;B，如果通过A属性(属性组)的值，可以确定<strong>唯一</strong>B属性的值，则称B依赖于A。</li>
<li>完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定需要依赖于A属性组中<strong>所有</strong>的属性值。</li>
<li>部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中<strong>某一些</strong>值即可。</li>
<li>传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A。</li>
<li>码：一张表中，一个属性或属性组，<strong>被其他所有属性所完全依赖</strong>，则称这个属性(属性组)为该表的码。</li>
</ol>
</blockquote>
<p><strong>第一范式表（1NF）：</strong>原子数据项</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
<th>课程名称</th>
<th>分数</th>
</tr>
</thead>
<tbody><tr>
<td>10010</td>
<td>张无忌</td>
<td>经济系</td>
<td>张三丰</td>
<td>高等数学</td>
<td>95</td>
</tr>
<tr>
<td>10010</td>
<td>张无忌</td>
<td>经济系</td>
<td>张三丰</td>
<td>大学英语</td>
<td>87</td>
</tr>
<tr>
<td>10010</td>
<td>张无忌</td>
<td>经济系</td>
<td>张三丰</td>
<td>计算机基础</td>
<td>65</td>
</tr>
<tr>
<td>10011</td>
<td>令狐冲</td>
<td>法律系</td>
<td>任我行</td>
<td>法理学</td>
<td>77</td>
</tr>
<tr>
<td>10011</td>
<td>令狐冲</td>
<td>法律系</td>
<td>任我行</td>
<td>大学英语</td>
<td>87</td>
</tr>
<tr>
<td>10011</td>
<td>令狐冲</td>
<td>法律系</td>
<td>任我行</td>
<td>法律社会学</td>
<td>65</td>
</tr>
<tr>
<td>10012</td>
<td>杨过</td>
<td>法律系</td>
<td>任我行</td>
<td>法律社会学</td>
<td>95</td>
</tr>
<tr>
<td>10012</td>
<td>杨过</td>
<td>法律系</td>
<td>任我行</td>
<td>法理学</td>
<td>97</td>
</tr>
<tr>
<td>10012</td>
<td>杨过</td>
<td>法律系</td>
<td>任我行</td>
<td>大学英语</td>
<td>99</td>
</tr>
</tbody></table>
<blockquote>
<p>存在问题：</p>
<ol>
<li>存在非常严重的数据冗余(重复)：姓名、系名、系主任</li>
<li>数据添加存在问题：添加新开设的系和系主任时，数据不合法</li>
<li>数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。</li>
</ol>
</blockquote>
<p><strong>第二范式表（2NF）：</strong>消除部分函数依赖</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程名称</th>
<th>分数</th>
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系主任</th>
</tr>
</thead>
<tbody><tr>
<td>10010</td>
<td>高等数学</td>
<td>95</td>
<td>10010</td>
<td>张无忌</td>
<td>经济系</td>
<td>张三丰</td>
</tr>
<tr>
<td>10010</td>
<td>大学英语</td>
<td>87</td>
<td>10011</td>
<td>令狐冲</td>
<td>法律系</td>
<td>任我行</td>
</tr>
<tr>
<td>10010</td>
<td>计算机基础</td>
<td>65</td>
<td>10012</td>
<td>杨过</td>
<td>法律系</td>
<td>任我行</td>
</tr>
<tr>
<td>10011</td>
<td>法理学</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10011</td>
<td>大学英语</td>
<td>87</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10011</td>
<td>法律社会学</td>
<td>65</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10012</td>
<td>法律社会学</td>
<td>95</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10012</td>
<td>法理学</td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10012</td>
<td>大学英语</td>
<td>99</td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>第三范式表（3NF）：</strong>消除传递依赖</p>
<table>
<thead>
<tr>
<th>学号</th>
<th>课程名称</th>
<th>分数</th>
<th>学号</th>
<th>姓名</th>
<th>系名</th>
<th>系名</th>
<th>系主任</th>
</tr>
</thead>
<tbody><tr>
<td>10010</td>
<td>高等数学</td>
<td>95</td>
<td>10010</td>
<td>张无忌</td>
<td>经济系</td>
<td>经济系</td>
<td>张三丰</td>
</tr>
<tr>
<td>10010</td>
<td>大学英语</td>
<td>87</td>
<td>10011</td>
<td>令狐冲</td>
<td>法律系</td>
<td>法律系</td>
<td>任我行</td>
</tr>
<tr>
<td>10010</td>
<td>计算机基础</td>
<td>65</td>
<td>10012</td>
<td>杨过</td>
<td>法律系</td>
<td></td>
<td></td>
</tr>
<tr>
<td>10011</td>
<td>法理学</td>
<td>77</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10011</td>
<td>大学英语</td>
<td>87</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10011</td>
<td>法律社会学</td>
<td>65</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10012</td>
<td>法律社会学</td>
<td>95</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10012</td>
<td>法理学</td>
<td>97</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>10012</td>
<td>大学英语</td>
<td>99</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<h3 id="10-数据库的备份和还原"><a href="#10-数据库的备份和还原" class="headerlink" title="10. 数据库的备份和还原"></a>10. 数据库的备份和还原</h3><blockquote>
<p>备份： <code>mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径</code></p>
<p>还原：登录数据库—&gt;创建数据库—&gt;使用数据库—&gt;执行文件 source 文件路径</p>
</blockquote>
<h3 id="11-多表查询"><a href="#11-多表查询" class="headerlink" title="11. 多表查询"></a>11. 多表查询</h3><h4 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h4><blockquote>
<p>使用where条件消除无用数据：<code>SELECT * FROM emp,dept WHERE emp.dept_id = dept.id</code></p>
</blockquote>
<h4 id="显式内连接"><a href="#显式内连接" class="headerlink" title="显式内连接"></a>显式内连接</h4><blockquote>
<p>表名1 [inner] join 表名2 on 条件：<code>SELECT * FROM emp INNER JOIN dept ON emp.dept_id= dept.id</code></p>
</blockquote>
<h4 id="外链接查询"><a href="#外链接查询" class="headerlink" title="外链接查询"></a>外链接查询</h4><blockquote>
<p>左外连接：查询左表<strong>所有数据</strong>以及其和右表交集部分</p>
<p>语法：select 字段列表 from 表1 left [outer] join 表2 on 条件</p>
<p>右外连接与左外连接正好相反：select 字段列表 from 表1 right [outer] join 表2 on 条件；</p>
</blockquote>
<h4 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">查询中嵌套查询，称嵌套查询为子查询。</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>子查询的结果是<strong>单行单列</strong>的：子查询可以作为条件，使用运算符去判断。 </li>
<li>子查询的结果是<strong>多行单列</strong>的：子查询可以作为条件，使用in(结果)来判断。</li>
<li>子查询的结果是<strong>多行多列</strong>的：子查询可以作为一张虚拟表参与查询。</li>
</ol>
</blockquote>
<h3 id="12-事务"><a href="#12-事务" class="headerlink" title="12. 事务"></a>12. 事务</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>基本操作：</p>
<ol>
<li>开启事务： <code>start transaction;</code></li>
<li>回滚：<code>rollback;</code></li>
<li>提交：<code>commit;</code></li>
</ol>
</blockquote>
<blockquote>
<p>提交方式：</p>
<ul>
<li>自动提交：一条DML(增删改)语句会自动提交一次事务。（mysql）</li>
<li>手动提交：需要先开启事务，再提交。（Oracle）</li>
<li>修改事务的默认提交方式：<ul>
<li>查看事务的默认提交方式：<code>SELECT @@autocommit;</code>  1 代表自动提交，0 代表手动提交</li>
<li>修改默认提交方式： <code>set @@autocommit = 0;</code></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="四大特征ACID"><a href="#四大特征ACID" class="headerlink" title="四大特征ACID"></a>四大特征ACID</h4><blockquote>
<ol>
<li><strong>原子性Atomic</strong>：是不可分割的最小操作单位，要么同时成功，要么同时失败。</li>
<li><strong>一致性Consistent</strong>：事务操作前后，数据总量不变</li>
<li><strong>隔离性Isolated</strong>：多个事务之间。相互独立。</li>
<li><strong>持久性Duration</strong>：当事务提交或回滚后，数据库会持久化的保存数据。</li>
</ol>
</blockquote>
<h4 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题：</span><br><span class="line">1. 脏读：一个事务，读取到另一个事务中没有提交的数据</span><br><span class="line">2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。</span><br><span class="line">3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>四种隔离级别</strong>：</p>
<ol>
<li>read uncommitted：读未提交。产生的问题：脏读、不可重复读、幻读</li>
<li>read committed：读已提交 （Oracle）。产生的问题：不可重复读、幻读</li>
<li>repeatable read：可重复读 （MySQL默认）。产生的问题：幻读</li>
<li>serializable：串行化。可以解决所有的问题</li>
</ol>
</blockquote>
<blockquote>
<p>数据库查询隔离级别：<code>select @@tx_isolation;</code></p>
<p>数据库设置隔离级别：<code>set global transaction isolation level 级别字符串;</code></p>
<p>注意：隔离级别从小到大安全性越来越高，但是效率越来越低</p>
</blockquote>
<h3 id="13-DCL-控制用户权限"><a href="#13-DCL-控制用户权限" class="headerlink" title="13. DCL 控制用户权限"></a>13. DCL 控制用户权限</h3><h4 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h4><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>添加</td>
<td>CREATE USER <code>&#39;用户名&#39;@&#39;主机名&#39;</code>IDENTIFIED BY<code>&#39;密码&#39;</code></td>
<td>创建一个用户</td>
</tr>
<tr>
<td>删除</td>
<td>DROP USER <code>&#39;用户名&#39;@&#39;主机名&#39;</code></td>
<td>删除指定用户</td>
</tr>
<tr>
<td>修改</td>
<td>UPDATE USER SET PASSWORD = PASSWORD<code>(&#39;新密码&#39;)</code>WHERE USER =<code>&#39;用户名&#39;</code></td>
<td>修改用户密码</td>
</tr>
<tr>
<td>修改</td>
<td>SET PASSWORD FOR <code>&#39;用户名&#39;@&#39;主机名&#39;</code>= PASSWORD<code>(&#39;新密码&#39;)</code></td>
<td>修改用户密码</td>
</tr>
<tr>
<td>查询</td>
<td>切换到mysql数据库后，SELECT * FROM <code>用户名</code></td>
<td>查询用户信息</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>重置root用户密码：</strong></p>
<ol>
<li>停止mysql服务：管理员运行cmd – &gt; net stop mysql </li>
<li>使用无验证方式启动mysql服务： mysqld –skip-grant-tables</li>
<li>打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功</li>
<li>切换到mysql数据库：use mysql;</li>
<li>重置密码：update user set password = password(‘你的新密码’) where user = ‘root’;</li>
<li>关闭两个窗口</li>
<li>打开任务管理器，手动结束mysqld.exe 的进程</li>
<li>启动mysql服务：net start mysql</li>
<li>使用新密码登录</li>
</ol>
</blockquote>
<h4 id="权限管理"><a href="#权限管理" class="headerlink" title="权限管理"></a>权限管理</h4><table>
<thead>
<tr>
<th>操作</th>
<th>代码</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>查询</td>
<td>SHOW GRANTS FOR <code>&#39;用户名&#39;@&#39;主机名&#39;</code></td>
<td>查询权限</td>
</tr>
<tr>
<td>授予</td>
<td>grant <code>权限列表</code> on<code>数据库名.表名</code> to <code>&#39;用户名&#39;@&#39;主机名&#39;</code></td>
<td>授予权限</td>
</tr>
<tr>
<td>撤销</td>
<td>revoke <code>权限列表</code> on<code>数据库名.表名</code> from <code>&#39;用户名&#39;@&#39;主机名&#39;</code></td>
<td>撤销权限</td>
</tr>
</tbody></table>
<blockquote>
<p>通配符： % 表示可以在任意主机使用用户登录数据库；<code>localhost</code>主机名仅限于本机使用。</p>
<p>给user用户授予所有权限，在任意数据库任意表上：</p>
<p>GRANT ALL ON * . * TO ‘user’ @ ‘%’;</p>
</blockquote>
<h3 id="14-JDBC"><a href="#14-JDBC" class="headerlink" title="14. JDBC"></a>14. JDBC</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Java DataBase Connectivity Java ：数据库连接</span><br><span class="line">本质：官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>操作步骤：</strong></p>
<ol>
<li><p><strong>导入驱动jar包</strong></p>
<ol>
<li>复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下</li>
<li>右键–&gt;Add As Library</li>
</ol>
</li>
<li><p><strong>注册驱动</strong>（mysql5之后的驱动jar包可以省略注册驱动的步骤）</p>
<p><code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p>
</li>
<li><p><strong>获取数据库连接对象 Connection</strong> </p>
<p><code>Connection conn = DriverManager.getConnection(String url, String user, String password);</code></p>
</li>
<li><p><strong>定义sql语句</strong></p>
</li>
</ol>
<p><code>String sql = &quot;update account set balance = 500 where id = 1&quot;;</code></p>
<ol start="5">
<li><strong>获取执行sql的对象 Statement</strong><br><code>Statement stmt = conn.createStatement();</code></li>
<li><strong>执行sql</strong><br><code>int count = stmt.executeUpdate(sql);</code></li>
<li><strong>处理结果</strong></li>
</ol>
<p><code>System.out.println(count);</code></p>
<ol start="8">
<li><strong>释放资源</strong><br><code>stmt.close();
conn.close();</code></li>
</ol>
</blockquote>
<h4 id="Connection-数据库连接对象"><a href="#Connection-数据库连接对象" class="headerlink" title="Connection 数据库连接对象"></a>Connection 数据库连接对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Connection conn = DriverManager.getConnection(String url, String user, String password)；</span><br><span class="line">url是指定的连接路径，例如jdbc:mysql://localhost:3306/数据库名称；</span><br><span class="line">如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则可以简写为jdbc:mysql:///数据库名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>功能：</p>
<ul>
<li>获取执行sql 的对象：<ul>
<li><code>Statement createStatement()</code></li>
<li><code>PreparedStatement prepareStatement(String sql)</code></li>
</ul>
</li>
<li>管理事务：<ul>
<li>开启事务：<code>setAutoCommit(boolean autoCommit)</code> ：调用该方法设置参数为false，即开启事务</li>
<li>提交事务：<code>commit()</code></li>
<li>回滚事务：<code>rollback()</code></li>
</ul>
</li>
</ul>
</blockquote>
<h4 id="Statement-执行sql的对象"><a href="#Statement-执行sql的对象" class="headerlink" title="Statement 执行sql的对象"></a>Statement 执行sql的对象</h4><blockquote>
<ol>
<li><code>boolean execute(String sql)</code>：可以执行任意的sql </li>
<li><code>int executeUpdate(String sql)</code>：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句。返回值为影响的行数，可以通过这个影响的行数判断DML语句是否执行成功：返回值&gt;0的则执行成功，反之，则失败。</li>
<li><code>ResultSet executeQuery(String sql)</code>：执行DQL（select)语句</li>
</ol>
</blockquote>
<h4 id="ResultSet-结果集对象"><a href="#ResultSet-结果集对象" class="headerlink" title="ResultSet 结果集对象"></a>ResultSet 结果集对象</h4><blockquote>
<ol>
<li><code>boolean next()</code>：游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true。</li>
<li><code>getXxx(参数)</code>：获取数据，XXX如：int getInt()，String getString()</li>
</ol>
<p>参数可以是int，代表列的编号，从1开始；也可以是String，代表列名称。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示,展示指定表中数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (Connection conn = DriverManager.getConnection(<span class="string">"jdbc:mysql:///db_day01"</span>, 				<span class="string">"root"</span>, <span class="string">"root"</span>);</span><br><span class="line">             Statement stmt = conn.createStatement();</span><br><span class="line">             ResultSet rs = stmt.executeQuery(<span class="string">"select * from dept"</span>);)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">                String DEPTON = rs.getString(<span class="string">"DEPTNO"</span>);</span><br><span class="line">                String DNAME = rs.getString(<span class="string">"DNAME"</span>);</span><br><span class="line">                String LOC = rs.getString(<span class="string">"LOC"</span>);</span><br><span class="line">                System.out.println(DEPTON + <span class="string">"---"</span> + DNAME + <span class="string">"---"</span> + LOC);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="15-JDBCUtils-抽取JDBC工具类"><a href="#15-JDBCUtils-抽取JDBC工具类" class="headerlink" title="15. JDBCUtils 抽取JDBC工具类"></a>15. JDBCUtils 抽取JDBC工具类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDBCUtils 代码展示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JDBCUtils</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String url;	<span class="comment">//配置文件的四个参数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String user;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String password;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String driver;	</span><br><span class="line">    <span class="keyword">static</span>&#123; <span class="comment">//静态代码块，完成各个参数的赋值，省略了try...catch语句</span></span><br><span class="line">            Properties pro = <span class="keyword">new</span> Properties(); </span><br><span class="line">            InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream</span><br><span class="line">                (<span class="string">"jdbc.properties"</span>);	<span class="comment">//通过类加载器获得配置文件路径</span></span><br><span class="line">            pro.load(is); </span><br><span class="line">            url = pro.getProperty(<span class="string">"url"</span>);</span><br><span class="line">            user = pro.getProperty(<span class="string">"user"</span>);</span><br><span class="line">            password = pro.getProperty(<span class="string">"password"</span>);</span><br><span class="line">            driver = pro.getProperty(<span class="string">"driver"</span>);</span><br><span class="line">            Class.forName(driver);&#125;</span><br><span class="line">	<span class="comment">//获取Connection对象的方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DriverManager.getConnection(url, user, password);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//释放资源的方法，两种重载形式</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt,Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();&#125;&#125;</span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;               </span><br><span class="line">                e.printStackTrace();&#125;&#125;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( rs != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();&#125;&#125;</span><br><span class="line">        <span class="keyword">if</span>( stmt != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();&#125;&#125;</span><br><span class="line">        <span class="keyword">if</span>( conn != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">                e.printStackTrace();&#125;&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="16-用户登录案例与sql注入问题"><a href="#16-用户登录案例与sql注入问题" class="headerlink" title="16. 用户登录案例与sql注入问题"></a>16. 用户登录案例与sql注入问题</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题。PreparedStatement对象可以解决这个问题，预编SQL语句时使用“？”作为占位符，可以防止SQL注入，同时效率更高。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用JDBCUtils完成登录案例代码展示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        System.out.println(<span class="string">"请输入用户名："</span>);</span><br><span class="line">        String username = sc.nextLine();</span><br><span class="line">        System.out.println(<span class="string">"请输入密码："</span>);</span><br><span class="line">        String password = sc.nextLine();</span><br><span class="line">        <span class="keyword">boolean</span> flag = login(username, password);</span><br><span class="line">        <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">            System.out.println(<span class="string">"登录成功"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"用户名或密码错误"</span>);</span><br><span class="line">        &#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">login</span><span class="params">(String username, String password)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (username == <span class="keyword">null</span> || password == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection conn = <span class="keyword">null</span>;</span><br><span class="line">        PreparedStatement pstmt = <span class="keyword">null</span>;</span><br><span class="line">        ResultSet rs = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            conn = JDBCUtils.getConnection();</span><br><span class="line">            <span class="comment">/*特殊关键字拼接sql时会造成安全性问题，例如密码：a' or 'a' = 'a</span></span><br><span class="line"><span class="comment">            String sql = "select * from user where </span></span><br><span class="line"><span class="comment">            	username = '"+username+"' and password = '"+password+"' ";</span></span><br><span class="line"><span class="comment">			stmt = conn.createStatement();</span></span><br><span class="line"><span class="comment">			rs = stmt.executeQuery(sql);</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            <span class="comment">//使用PreparedStatement对象来解决,参数使用?作为占位符</span></span><br><span class="line">            String sql = <span class="string">"select * from user where username = ? and password = ?"</span>;</span><br><span class="line">            pstmt = conn.prepareStatement(sql);</span><br><span class="line">            pstmt.setString(<span class="number">1</span>, username); <span class="comment">//setXXX方法，参数1为第几个问号的位置，参数2为赋值</span></span><br><span class="line">            pstmt.setString(<span class="number">2</span>, password);</span><br><span class="line">            rs = pstmt.executeQuery();</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">return</span> rs.next();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            JDBCUtils.close(rs, pstmt, conn);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="17-JDBC事务控制"><a href="#17-JDBC事务控制" class="headerlink" title="17. JDBC事务控制"></a>17. JDBC事务控制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    Connection conn = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pstmt1 = <span class="keyword">null</span>;</span><br><span class="line">    PreparedStatement pstmt2 = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        conn = JDBCUtils.getConnection();</span><br><span class="line">        <span class="comment">//开启事务</span></span><br><span class="line">        conn.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line">        <span class="comment">//张三 - 500</span></span><br><span class="line">        String sql1 = <span class="string">"update account set balance = balance - ? where id = ?"</span>;</span><br><span class="line">        <span class="comment">//李四 + 500</span></span><br><span class="line">        String sql2 = <span class="string">"update account set balance = balance + ? where id = ?"</span>;</span><br><span class="line">        <span class="comment">//获取执行sql对象</span></span><br><span class="line">        pstmt1 = conn.prepareStatement(sql1);</span><br><span class="line">        pstmt2 = conn.prepareStatement(sql2);</span><br><span class="line">        <span class="comment">//设置参数</span></span><br><span class="line">        pstmt1.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">        pstmt1.setInt(<span class="number">2</span>,<span class="number">1</span>);</span><br><span class="line">        pstmt2.setDouble(<span class="number">1</span>,<span class="number">500</span>);</span><br><span class="line">        pstmt2.setInt(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">        <span class="comment">//执行张三sql</span></span><br><span class="line">        pstmt1.executeUpdate();</span><br><span class="line">        <span class="comment">// 手动制造异常</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">3</span>/<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//执行李四sql</span></span><br><span class="line">        pstmt2.executeUpdate();</span><br><span class="line">        <span class="comment">//提交事务</span></span><br><span class="line">        conn.commit();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;  <span class="comment">//发生任何异常，事务回滚</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">                conn.rollback();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e1) &#123;</span><br><span class="line">            e1.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        JDBCUtils.close(pstmt1,conn);</span><br><span class="line">        JDBCUtils.close(pstmt2,<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="18-数据库连接池"><a href="#18-数据库连接池" class="headerlink" title="18. 数据库连接池"></a>18. 数据库连接池</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">本质是一个存放数据库连接的容器(集合)。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>好处：针对数据库连接对象的复用，可以节约创建以及销毁数据库连接对象的资源，提高用户访问效率。</p>
<p>标准接口：DataSource </p>
<p>常用方法：获取连接：getConnection()；归还连接：Connection.close()</p>
</blockquote>
<h4 id="C3P0-数据库连接池技术"><a href="#C3P0-数据库连接池技术" class="headerlink" title="C3P0 数据库连接池技术"></a>C3P0 数据库连接池技术</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用步骤：</span></span><br><span class="line"><span class="comment">//1. 导入jar包：【c3p0-0.9.5.2.jar】和【mchange-commons-java-0.2.12.jar】</span></span><br><span class="line"><span class="comment">//2. 定义配置文件：【c3p0.properties】或【c3p0-config.xml】直接放在src目录下</span></span><br><span class="line"><span class="comment">//3. 创建数据库连接池对象</span></span><br><span class="line">DataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line"><span class="comment">//4. 获取连接对象</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>

<h4 id="Druid-数据库连接池技术"><a href="#Druid-数据库连接池技术" class="headerlink" title="Druid 数据库连接池技术"></a>Druid 数据库连接池技术</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用步骤：</span></span><br><span class="line"><span class="comment">//1. 导入jar包【druid-1.0.9.jar】</span></span><br><span class="line"><span class="comment">//2. 定义配置文件：properties文件，可以叫任意名称，放在任意目录下</span></span><br><span class="line">InputStream is = Demo.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>);</span><br><span class="line"><span class="comment">//3. 加载配置文件：</span></span><br><span class="line">Properties pro = <span class="keyword">new</span> Properties(); </span><br><span class="line">pro.load(is);</span><br><span class="line"><span class="comment">//4. 获取数据库连接池对象：通过工厂来来获取 </span></span><br><span class="line">DataSource ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line"><span class="comment">//5. 获取连接：</span></span><br><span class="line">Connection conn = ds.getConnection();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示：根据Druid技术，定义工具类JDBCUtils</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> DataSource ds;</span><br><span class="line"><span class="comment">//静态代码块中加载配置文件，生成DataSource对象</span></span><br><span class="line"><span class="keyword">static</span>&#123;	</span><br><span class="line">    	Properties pro = <span class="keyword">new</span> Properties();           	         </span><br><span class="line">        pro.load</span><br><span class="line">            (DruidUtils.class.getClassLoader().getResourceAsStream(<span class="string">"druid.properties"</span>));</span><br><span class="line">        ds = DruidDataSourceFactory.createDataSource(pro);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回DataSource对象的方法，用于SpringJDBC</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DataSource <span class="title">getDataSource</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//返回Connection对象的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ds.getConnection();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//两个重载的归还连接方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">    close(<span class="keyword">null</span>, stmt, conn);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">(ResultSet rs, Statement stmt, Connection conn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (rs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;rs.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br><span class="line">    <span class="keyword">if</span> (stmt != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;stmt.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br><span class="line">    <span class="keyword">if</span> (conn != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;conn.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="19-Spring-JDBC"><a href="#19-Spring-JDBC" class="headerlink" title="19. Spring JDBC"></a>19. Spring JDBC</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常用方法：</p>
<ul>
<li>使用数据源DataSource，创建JdbcTemplate对象：</li>
</ul>
<p><code>JdbcTemplate template = new JdbcTemplate(ds);</code></p>
<ul>
<li>update()：执行DML增、删、改语句：</li>
</ul>
<p><code>int count = template.update(sql);</code></p>
<ul>
<li>queryForMap()：将列名作为key，值作为value，将一条记录封装为一个map集合</li>
</ul>
<p><code>Map&lt;String, Object&gt; map = template.queryForMap(sql);</code></p>
<ul>
<li>queryForList()：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中</li>
</ul>
<p><code>List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql);</code></p>
<ul>
<li>query()：查询结果，将结果封装为JavaBean对象</li>
</ul>
<p><code>List&lt;T&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;T&gt;(T.class));</code></p>
<ul>
<li>queryForObject：查询结果，将结果封装为对象，一般用于获取单行单列的数值数据</li>
</ul>
<p><code>String count = template.queryForObject(sql, String.class);</code></p>
</blockquote>
<h1 id="Web前端知识点总结"><a href="#Web前端知识点总结" class="headerlink" title="Web前端知识点总结"></a>Web前端知识点总结</h1><h3 id="1-B-S架构资源"><a href="#1-B-S架构资源" class="headerlink" title="1. B/S架构资源"></a>1. B/S架构资源</h3><blockquote>
<p><strong>静态资源：</strong>使用静态网页开发技术发布的资源</p>
<ul>
<li>所有用户访问，得到的结果是一样的。</li>
<li>如：文本，图片，音频、视频, HTML,CSS,JavaScript。</li>
<li>如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏器。</li>
<li>用HTML搭建基础网页， 用CSS美化、布局页面，用JavaScript控制页面的元素，让页面有动态效果。</li>
</ul>
<p><strong>动态资源：</strong>使用动态网页及时发布的资源</p>
<ul>
<li>所有用户访问，得到的结果可能不一样。</li>
<li>如：jsp/servlet,php,asp…。</li>
<li>如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器。</li>
</ul>
</blockquote>
<h3 id="2-HTML"><a href="#2-HTML" class="headerlink" title="2. HTML"></a>2. HTML</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hyper Text Markup Language 超文本标记语言，是最基础的网页开发语言</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>超文本</strong>：用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本</p>
<p><strong>标记语言</strong>：由标签&lt;标签名称&gt; 构成的语言，如html、xml，不属于编程语言。</p>
<p><strong>标签</strong>：标签可以嵌套，不区分大小写，建议用小写，分为两类：</p>
<ul>
<li>围堵标签：有开始标签和结束标签。如 <html> </html></li>
<li>自闭标签：开始标签和结束标签在一起。如 &lt; br/&gt;</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="left">标签</th>
<th>说明</th>
<th>属性</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&lt; html&gt;</td>
<td>文档的根标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; head&gt;</td>
<td>头标签，用于指定html文档的一些属性，引入外部的资源</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; title&gt;</td>
<td>标题标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; body&gt;</td>
<td>体标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; !DOCTYPE html &gt;</td>
<td>html5中定义该文档是html文档</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; !– 注释内容 – &gt;</td>
<td>注释</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; h1&gt; to &lt; h6&gt;</td>
<td>标题标签，h1到h6字体大小逐渐递减</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; p&gt;</td>
<td>段落标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; br/&gt;</td>
<td>换行标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; hr&gt;</td>
<td>展示一条水平线</td>
<td>color/width/size/align</td>
</tr>
<tr>
<td align="left">&lt; b&gt;</td>
<td>字体加粗</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; i&gt;</td>
<td>字体斜体</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; font&gt;</td>
<td>字体标签</td>
<td>color/face/size</td>
</tr>
<tr>
<td align="left">&lt; center&gt;</td>
<td>文本居中</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; img src=” “ alt=” “&gt;</td>
<td>展示图片（src为图片URL，alt为图片替代文本）</td>
<td>align/height/width</td>
</tr>
<tr>
<td align="left">&lt; ol&gt; &lt; li&gt;&lt; /li&gt; &lt; /ol&gt;</td>
<td>有序列表</td>
<td>type</td>
</tr>
<tr>
<td align="left">&lt; ul&gt; &lt; li&gt;&lt; /li&gt; &lt; /ul&gt;</td>
<td>无序列表</td>
<td>type</td>
</tr>
<tr>
<td align="left">&lt; a href=””&gt;&lt; /a&gt;</td>
<td>超链接标签</td>
<td>target( _self/ _blank)</td>
</tr>
<tr>
<td align="left">&lt; div&gt;</td>
<td>块级标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; span&gt;</td>
<td>行内标签</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; header&gt;</td>
<td>页眉</td>
<td></td>
</tr>
<tr>
<td align="left">&lt; footer&gt;</td>
<td>页脚</td>
<td></td>
</tr>
</tbody></table>
<blockquote>
<p><strong>超链接的功能</strong>：1. 生成可以被点击的样式；    2. 点击后跳转到href指定的url</p>
<p>若需要保留1功能，去掉2功能，则：<code>href = &quot;javascript:void(0)&quot;</code></p>
</blockquote>
<h3 id="3-表格标签"><a href="#3-表格标签" class="headerlink" title="3. 表格标签"></a>3. 表格标签</h3><blockquote>
<p><strong>table</strong>：定义表格</p>
<ul>
<li>width：宽度</li>
<li>border：边框</li>
<li>cellpadding：定义内容和单元格的距离</li>
<li>cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条</li>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
<p><strong>tr</strong>：定义行</p>
<ul>
<li>bgcolor：背景色</li>
<li>align：对齐方式</li>
</ul>
<p><strong>td</strong>：定义单元格</p>
<ul>
<li>colspan：合并列</li>
<li>rowspan：合并行</li>
</ul>
<p><strong>th</strong>：定义表头单元格</p>
</blockquote>
<h3 id="4-表单标签"><a href="#4-表单标签" class="headerlink" title="4. 表单标签"></a>4. 表单标签</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于采集用户输入的数据，和服务器进行交互的标签。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>action</strong>：指定提交数据的URL，若是写一个#，那么就是提交到本页面</p>
<p><strong>method</strong>：指定提交方式，表单项中的数据要想被提交，必须指定其name属性</p>
<ul>
<li>get：请求参数会在地址栏中显示，参数大小不能超过255， 不太安全</li>
<li>post：请求参数不会在地址栏中显示，参数的大小没有限制，多用于提交视频和图片，比较安全</li>
</ul>
<p><strong>input</strong>：可以通过type属性值，改变元素展示的样式</p>
<ul>
<li>text：文本输入框，默认值（参数placeholder：指定输入框的提示信息）</li>
<li>password：密码输入框</li>
<li>radio：单选框，多个单选框的name属性值必须一样，在value属性中指定其被选中后提交的值</li>
<li>checkbox：在value属性中指定其被选中后提交的值</li>
<li>file：文件选择框</li>
<li>hidden：隐藏域，用于提交一些信息，不需要用户输入</li>
<li>submit：提交按钮，可以提交表单</li>
<li>image：图片提交按钮，src属性指定图片的路径    </li>
</ul>
<p><strong>label</strong>：label的for属性一般会和input的id属性值对应。点击label区域，会让对应的input输入框获取焦点</p>
<p><strong>select</strong>：下拉列表，子元素option为指定列表项</p>
<p><strong>textarea</strong>：文本域，cols：指定列数， rows：默认多少行</p>
</blockquote>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>FormTest<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">method</span>=<span class="string">"get"</span>&gt;</span></span><br><span class="line">    姓名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入姓名"</span> <span class="attr">name</span> = <span class="string">"username"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    密码：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"password"</span> <span class="attr">placeholder</span>=<span class="string">"请输入密码"</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span> <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    性别：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span> = <span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"男"</span>&gt;</span> 男</span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span> = <span class="string">"gender"</span> <span class="attr">value</span>=<span class="string">"女"</span>&gt;</span> 女<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    爱好：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"hobby"</span> <span class="attr">value</span> = <span class="string">1</span>&gt;</span> 小米</span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"hobby"</span> <span class="attr">value</span> = <span class="string">2</span>&gt;</span> 华为</span><br><span class="line">          <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"checkbox"</span> <span class="attr">name</span> = <span class="string">"hobby"</span> <span class="attr">value</span> = <span class="string">3</span>&gt;</span> 锤子<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>文件<span class="tag">&lt;/<span class="name">label</span>&gt;</span>：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">id</span>=<span class="string">"file"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    隐藏：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"hidden"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    提交：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"提交"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">	图片提交：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"image"</span> <span class="attr">src</span>=<span class="string">"baidu.png"</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    地区：<span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"place"</span> <span class="attr">id</span>=<span class="string">"place"</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span>请选择地区<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span> =<span class="string">"北京"</span>&gt;</span>北京<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"深圳"</span>&gt;</span>深圳<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"厦门"</span>&gt;</span>厦门<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="5-CCS"><a href="#5-CCS" class="headerlink" title="5. CCS"></a>5. CCS</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Cascading Style Sheets 层叠样式表，多个样式可以作用在同一个html的元素上，用于页面美化和布局控制</span><br><span class="line">好处：功能强大，将内容展示和样式控制分离，易于分工合作，提高效率，同时可以使页面中的样式得以复用。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>CCS与Html的结合：</strong></p>
<ol>
<li>内联样式：在标签内使用style属性指定css代码：</li>
</ol>
<p><code>&lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt;</code></p>
<ol start="2">
<li>内部样式： 在head标签内，定义style标签，style标签的标签体内容就是css代码：</li>
</ol>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">&gt;     <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">&gt;         div&#123;color:blue;&#125;</span><br><span class="line">&gt;     <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">&gt; 	<span class="tag">&lt;<span class="name">div</span>&gt;</span>hello css<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">&gt; <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<blockquote>
<ol start="3">
<li>外部样式：先定义css资源文件，再在head标签内，定义link标签，引入外部的资源文件</li>
</ol>
<p><code>&lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt;</code></p>
<p>（也可以写为：<code>&lt;style&gt;  @import &quot;a.css&quot;;  &lt;/style&gt;</code>）</p>
</blockquote>
<h3 id="6-CCS选择器"><a href="#6-CCS选择器" class="headerlink" title="6. CCS选择器"></a>6. CCS选择器</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">选择器：筛选具有相似特征的元素</span><br><span class="line">选择器 &#123;</span><br><span class="line">		属性名1:属性值1;</span><br><span class="line">		属性名2:属性值2;</span><br><span class="line">		...</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>基础选择器：</strong></p>
<ol>
<li><strong>id选择器</strong>：选择具体的id属性值的元素，建议在一个html页面中id值唯一。语法：<code>#id属性值{}</code></li>
<li><strong>类选择器</strong>：选择具有相同的class属性值的元素。语法：<code>.class属性值{}</code></li>
<li><strong>元素选择器</strong>：选择具有相同标签名称的元素。语法：<code>标签名称{}</code></li>
</ol>
<p><strong>扩展选择器：</strong></p>
<ol>
<li>选择所有元素。语法：<code>*{}</code></li>
<li>并集选择器：同时筛选多个选择器。语法：<code>选择器1,选择器2{}</code></li>
<li>子选择器：筛选选择器1元素下的选择器2元素。 语法：<code>选择器1 选择器2{}</code></li>
<li>直系父选择器：筛选选择器2的父元素选择器1。语法：<code>选择器1 &gt; 选择器2{}</code></li>
<li>属性选择器：选择元素名称，属性名=属性值的元素。语法：<code>元素名称[属性名=&quot;属性值&quot;]{}</code></li>
<li>伪类选择器：选择一些元素具有的状态。语法：<code>元素：状态{}</code>  如：超链接标签 &lt; a&gt;：<ul>
<li><code>a:link{}</code>：初始化的状态</li>
<li><code>a:visited{}</code>：被访问过的状态</li>
<li><code>a:active{}</code>：正在访问状态</li>
<li><code>a:hover{}</code>：鼠标悬浮状态</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="7-CCS属性"><a href="#7-CCS属性" class="headerlink" title="7. CCS属性"></a>7. CCS属性</h3><blockquote>
<ol>
<li>字体、文本：<ul>
<li><code>font-size</code>：字体大小</li>
<li><code>color</code>：文本颜色</li>
<li><code>text-align</code>：对齐方式</li>
<li><code>line-height</code>：行高 </li>
</ul>
</li>
<li>背景<code>background</code>：可以设置背景色或填充图片</li>
<li>边框<code>border</code>：设置边框，符合属性</li>
<li>尺寸<code>width</code>：宽度height：高度</li>
<li>盒子模型：控制布局<ul>
<li><code>margin</code>：外边距</li>
<li><code>padding</code>：内边距，默认情况下内边距会影响整个盒子的大小</li>
<li><code>box-sizing: border-box</code>;  设置盒子的属性，让width和height就是最终盒子的大小</li>
</ul>
</li>
<li>浮动：<code>float</code>，脱离文档流布局（靠左：left；靠右：right）</li>
</ol>
</blockquote>
<h3 id="8-JavaScript基本语法"><a href="#8-JavaScript基本语法" class="headerlink" title="8. JavaScript基本语法"></a>8. JavaScript基本语法</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">JavaScript是一门客户端脚本语言，运行在客户端的浏览器中，每一个浏览器都有JavaScript的解析引擎。</span><br><span class="line">JS可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。</span><br><span class="line">脚本语言：不需要编译，可以直接被浏览器内核解析执行的语言。</span><br><span class="line">客户端脚本语言的标准：ECMAScript，统一了所有客户端脚本语言的编码方式。</span><br></pre></td></tr></table></figure>

<h4 id="结合html"><a href="#结合html" class="headerlink" title="结合html"></a>结合html</h4><ul>
<li>内部JS：定义&lt; script&gt;，标签体内容就是js代码</li>
<li>外部JS： 定义&lt; script&gt;，通过src属性引入外部的js文件</li>
</ul>
<blockquote>
<p>注意： &lt; script&gt;可以定义多个，可以定义在html页面的任何地方，但是定义的位置会影响执行顺序。</p>
<p>建议书写位置：1. head标题中   2. body最下方</p>
</blockquote>
<h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><blockquote>
<ul>
<li>原始数据类型：五种<ol>
<li>number：数字。包含整数、小数、NaN(Not a Number,代表不是数字的数字类型)</li>
<li>string：字符串。 “abc”、 “a”、 ‘abc’</li>
<li>boolean：true和false</li>
<li>null：一个对象为空的占位符(注意：null运算是其typeof类型为object，属设计错误)</li>
<li>undefined：未定义。一个没有初始化的变量，会被默认赋值为undefined</li>
</ol>
</li>
<li>引用数据类型：对象</li>
</ul>
</blockquote>
<h4 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">JavaScript是弱类型语言，定义变量的语法：var 变量名 = 初始化值</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>强类型：在开辟变量存储空间时，定义了空间将来存储数据的数据类型。只能存储固定类型的数据。</li>
<li>弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。</li>
</ul>
</blockquote>
<h4 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h4><blockquote>
<ul>
<li>被正负号修饰的运算数（+(-)）会自动转换为number类型，如果字面值不是数字，则转为NaN，true转为1，false转为0。</li>
<li>==：直接比较字面值，类型不同时，先进行类型转换，再比较</li>
</ul>
<p>===：全等于，在比较之前，先判断类型，如果类型不一样，则直接返回false</p>
<ul>
<li>进行逻辑运算时：<ol>
<li>number：0或NaN为假，其他为真</li>
<li>string：除了空字符串(“”)，其他都是true</li>
<li>null&amp;undefined:都是false</li>
<li>对象：所有对象都为true</li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="9-JavaScript基本对象"><a href="#9-JavaScript基本对象" class="headerlink" title="9. JavaScript基本对象"></a>9. JavaScript基本对象</h3><h4 id="Function-函数对象"><a href="#Function-函数对象" class="headerlink" title="Function:函数对象"></a>Function:函数对象</h4><blockquote>
<ul>
<li>创建：<ol>
<li>var fun = new Function(形式参数列表,方法体)；</li>
<li>function 方法名称(形式参数列表){<br>方法体<br>}</li>
<li>var 方法名 = function(形式参数列表){<br>方法体<br>}</li>
</ol>
</li>
<li>方法：</li>
</ul>
<p>​    length:代表形参的个数</p>
<ul>
<li>特点：<ol>
<li>JS中不存在方法重载，方法的调用只与方法的名称有关，和参数列表无关</li>
<li>方法是一个对象，如果定义名称相同的方法，后执行的方法会覆盖之前的方法</li>
<li>第二种创建方法执行优先级较高，若定义名称相同，会被第三种创建方法覆盖</li>
<li>在方法声明中有一个隐藏的内置对象（数组）arguments，封装所有的实际参数</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="Array-数组对象"><a href="#Array-数组对象" class="headerlink" title="Array:数组对象"></a>Array:数组对象</h4><blockquote>
<ul>
<li>创建：<ol>
<li>var arr = new Array(元素列表);</li>
<li>var arr = new Array(默认长度);</li>
<li>var arr = [元素列表]</li>
</ol>
</li>
<li>方法：<ol>
<li>join(参数)：将数组中的元素按照指定的分隔符拼接为字符串</li>
<li>push(参数)：向数组的末尾添加一个或更多元素，并返回新的数组长度</li>
</ol>
</li>
<li>特点：</li>
</ul>
<p>JS中的数组长度可变，元素类型也可变。</p>
</blockquote>
<h4 id="Date-日期对象"><a href="#Date-日期对象" class="headerlink" title="Date:日期对象"></a>Date:日期对象</h4><blockquote>
<ul>
<li>创建：var date = new Date();</li>
<li>方法：<br>toLocaleString()：返回当前date对象对应的时间本地字符串格式<br>getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差</li>
</ul>
</blockquote>
<h4 id="RegExp-正则表达式对象"><a href="#RegExp-正则表达式对象" class="headerlink" title="RegExp:正则表达式对象"></a>RegExp:正则表达式对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>创建：<ol>
<li>var reg = new RegExp(“正则表达式”);</li>
<li>var reg = /正则表达式/; （表达式不需要双引号，不需要加转义字符）</li>
</ol>
</li>
<li>方法：<ol>
<li>test(参数)：验证指定的字符串是否符合正则定义的规范    </li>
<li>match(参数)：可以匹配正则，返回的是匹配正则的内容</li>
</ol>
</li>
</ul>
</blockquote>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">字符 x</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">反斜线字符</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="center">a、b 或 c（简单类）</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="center">任何字符，除了 a、b 或 c（否定）</td>
</tr>
<tr>
<td align="center">[a-zA-Z]</td>
<td align="center">a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">单词字符：[a-zA-Z_0-9]</td>
</tr>
<tr>
<td align="center">X?</td>
<td align="center">X，一次或一次也没有</td>
</tr>
<tr>
<td align="center">X*</td>
<td align="center">X，零次或多次</td>
</tr>
<tr>
<td align="center">X+</td>
<td align="center">X，一次或多次</td>
</tr>
<tr>
<td align="center">X{n}</td>
<td align="center">X，恰好 n 次</td>
</tr>
<tr>
<td align="center">X{n,}</td>
<td align="center">X，至少 n 次</td>
</tr>
<tr>
<td align="center">X{n,m}</td>
<td align="center">X，至少 n 次，但是不超过 m 次</td>
</tr>
<tr>
<td align="center">^</td>
<td align="center">开始</td>
</tr>
<tr>
<td align="center">$</td>
<td align="center">结束</td>
</tr>
</tbody></table>
<h4 id="Global-全局对象"><a href="#Global-全局对象" class="headerlink" title="Global:全局对象"></a>Global:全局对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Global中封装的方法不需要对象就可以直接调用</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法：</p>
<ol>
<li>encodeURI()：url编码</li>
<li>decodeURI()：url解码</li>
<li>encodeURIComponent()：url编码（编码的字符范围更大）</li>
<li>decodeURIComponent()：url解码</li>
<li>parseInt()：将字符串转为数字（逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number）</li>
<li>isNaN()：判断一个值是否是NaN（NaN六亲不认，连自己都不认。NaN参与的==比较全部问false）</li>
<li>eval()：将一个字符串转换为JS代码，并把它作为脚本代码来执行</li>
</ol>
</blockquote>
<h3 id="10-BOM"><a href="#10-BOM" class="headerlink" title="10. BOM"></a>10. BOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Browser Object Model 浏览器对象模型：将浏览器的各个组成部分封装成为对象</span><br></pre></td></tr></table></figure>

<h4 id="Window-窗口对象"><a href="#Window-窗口对象" class="headerlink" title="Window:窗口对象"></a>Window:窗口对象</h4><blockquote>
<ul>
<li><p>弹出框相关方法：</p>
<ol>
<li>alert()：显示带有一段消息和一个确认按钮的警告框</li>
<li>confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。<ul>
<li>如果用户点击确定按钮，则方法返回true</li>
<li>如果用户点击取消按钮，则方法返回false</li>
</ul>
</li>
<li>prompt()：显示可提示用户输入的对话框，返回用户输入的值。</li>
</ol>
</li>
<li><p>打开关闭窗口相关方法：</p>
<ol>
<li>close()：关闭调用此方法的浏览器窗口</li>
<li>open()：打开一个新的浏览器窗口，返回新的window对象</li>
</ol>
</li>
<li><p>定时器相关方法：</p>
<ol>
<li><p>setTimeout(js代码或者方法对象，毫秒值)：在指定的毫秒数后调用函数或计算表达式</p>
<p>返回值：唯一标识，用于取消定时器</p>
</li>
<li><p>clearTimeout()：取消由 setTimeout() 方法设置的 timeout</p>
</li>
<li><p>setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式</p>
</li>
<li><p>clearInterval()：取消由 setInterval() 设置的 timeout</p>
</li>
</ol>
</li>
</ul>
</blockquote>
<blockquote>
<p><strong>注意</strong>：Window可以获取其他BOM对象【history/location/navigator/screen】，DOM对象【document】。</p>
<p>Window对象不需要创建可以直接使用，window.方法名()，且window本身可省略</p>
</blockquote>
<h4 id="Location-地址栏对象"><a href="#Location-地址栏对象" class="headerlink" title="Location:地址栏对象"></a>Location:地址栏对象</h4><blockquote>
<ul>
<li>方法：reload()：重新加载当前文档，同刷新</li>
</ul>
</blockquote>
<h4 id="History-历史记录对象"><a href="#History-历史记录对象" class="headerlink" title="History:历史记录对象"></a>History:历史记录对象</h4><blockquote>
<ul>
<li>方法：<ol>
<li>back()：加载 history 列表中的前一个 URL</li>
<li>forward()：加载 history 列表中的下一个 URL</li>
<li>go(参数)：加载 history 列表中的某个具体页面（参数：前进(正数)或后退(负数)几个历史记录）</li>
<li>length：返回当前窗口历史列表中的 URL 数量。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="Navigator-浏览器对象"><a href="#Navigator-浏览器对象" class="headerlink" title="Navigator:浏览器对象"></a>Navigator:浏览器对象</h4><h4 id="Screen-显示器屏幕对象"><a href="#Screen-显示器屏幕对象" class="headerlink" title="Screen:显示器屏幕对象"></a>Screen:显示器屏幕对象</h4><h3 id="11-DOM"><a href="#11-DOM" class="headerlink" title="11. DOM"></a>11. DOM</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Document Object Model 文档对象模型：将标记语言文档的各个组成部分封装为对象。可以使用这些对象对标记语言文档进行CRUD的动态操作。</span><br><span class="line">W3C标准中，DOM被分为三个不同的部分：</span><br><span class="line">1. 核心DOM -针对任何结构化文档的标准模型</span><br><span class="line">2. XML DOM -针对XML文档的标准模型</span><br><span class="line">3. HTML DOM -针对HTML文档的标准模型</span><br></pre></td></tr></table></figure>

<h4 id="Document-文档对象"><a href="#Document-文档对象" class="headerlink" title="Document:文档对象"></a>Document:文档对象</h4><blockquote>
<ul>
<li>获取：在HTML DOM模型中可以通过window对象来获取</li>
<li>获取Element对象方法：<ol>
<li>getElementBy<strong>Id</strong>()：根据id属性值获取元素对象。</li>
<li>getElementsBy<strong>TagName</strong>()：根据标签名称获取元素对象们，返回值是一个数组</li>
<li>getElementsBy<strong>ClassName</strong>()：根据Class属性值获取元素对象们，返回值是一个数组</li>
<li>getElementsBy<strong>Name</strong>()：根据name属性值获取元素对象们，返回值是一个数组</li>
</ol>
</li>
<li>创建其他DOM对象方法：<ol>
<li>createAttribute(name)：创建Attribute属性对象</li>
<li>createComment()：创建Comment注释对象</li>
<li>createElement()：创建Element元素对象</li>
<li>createTextNode()：创建Text文本对象</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="Element-元素对象"><a href="#Element-元素对象" class="headerlink" title="Element:元素对象"></a>Element:元素对象</h4><blockquote>
<ul>
<li>属性：<ol>
<li>previousSibling：获取该元素的前一个节点</li>
<li>nextSibling：获取该元素的后一个节点</li>
<li>innerHTML：可以获取标签内所有的内容，包括标签</li>
<li>innerText：可以获取标签内所有的文本内容，不包括标签</li>
</ol>
</li>
<li>方法：<ol>
<li>removeAttribute()：删除属性</li>
<li>setAttribute()：设置属性</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="Node-节点对象"><a href="#Node-节点对象" class="headerlink" title="Node:节点对象"></a>Node:节点对象</h4><blockquote>
<ul>
<li>特点：所有dom对象都可以被认为是一个节点</li>
<li>属性：parentNode 返回节点的父节点</li>
<li>方法：<ol>
<li>appendChild()：向节点的子节点列表的结尾添加新的子节点。</li>
<li>removeChild()：删除（并返回）当前节点的指定子节点。</li>
<li>replaceChild()：用新节点替换一个子节点。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="Attribute-属性对象"><a href="#Attribute-属性对象" class="headerlink" title="Attribute:属性对象"></a>Attribute:属性对象</h4><h4 id="Text-文本对象"><a href="#Text-文本对象" class="headerlink" title="Text:文本对象"></a>Text:文本对象</h4><h4 id="Comment-注释对象"><a href="#Comment-注释对象" class="headerlink" title="Comment:注释对象"></a>Comment:注释对象</h4><h3 id="12-事件监听机制"><a href="#12-事件监听机制" class="headerlink" title="12. 事件监听机制"></a>12. 事件监听机制</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">概念：某些组件（按钮，文本输入框...）被执行了某些操作（单击，双击，键盘按下，鼠标移动...）后，触发某些代码的执行。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见的事件：</p>
<ol>
<li><p>点击事件：</p>
<ul>
<li>onclick：单击事件</li>
<li>ondblclick：双击事件</li>
</ul>
</li>
<li><p>焦点事件：（input框里面有光标的时候，叫获取焦点）</p>
<ul>
<li>onblur：失去焦点</li>
<li>onfocus：元素获得焦点</li>
</ul>
</li>
<li><p>加载事件：</p>
<ul>
<li>onload：在页面当中所有的内容加载完之后触发，常作为入口函数</li>
</ul>
<p><code>window.onload = function(){}</code></p>
</li>
<li><p>鼠标事件：</p>
<ul>
<li>onmousedown    鼠标按钮被按下</li>
<li>onmouseup         鼠标按键被松开</li>
<li>onmousemove    鼠标被移动</li>
<li>onmouseover      鼠标移到某元素之上</li>
<li>onmouseout        鼠标从某元素移开</li>
</ul>
</li>
<li><p>键盘事件：</p>
<ul>
<li>onkeydown    某个键盘按键被按下</li>
<li>onkeyup         某个键盘按键被松开</li>
<li>onkeypress    某个键盘按键被按下并松开</li>
</ul>
</li>
<li><p>选择和改变：</p>
<ul>
<li>onchange    域的内容被改变。失焦后触发</li>
<li>onselect       文本被选中</li>
</ul>
</li>
<li><p>表单事件：</p>
<ul>
<li>onsubmit    确认按钮被点击</li>
<li>onreset         重置按钮被点击</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="13-综合案例"><a href="#13-综合案例" class="headerlink" title="13. 综合案例"></a>13. 综合案例</h3><h4 id="动态表格"><a href="#动态表格" class="headerlink" title="动态表格"></a>动态表格</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>动态表格<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">        table&#123;</span><br><span class="line">            border: 1px solid;</span><br><span class="line">            margin: auto;</span><br><span class="line">            width: 500px;</span><br><span class="line">        &#125;</span><br><span class="line">        td,th&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            border: 1px solid;</span><br><span class="line">        &#125;</span><br><span class="line">        div&#123;</span><br><span class="line">            text-align: center;</span><br><span class="line">            margin: 50px;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"id"</span> <span class="attr">placeholder</span>=<span class="string">"请输入编号"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"name"</span>  <span class="attr">placeholder</span>=<span class="string">"请输入姓名"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"gender"</span>  <span class="attr">placeholder</span>=<span class="string">"请输入性别"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"添加"</span> <span class="attr">id</span>=<span class="string">"btn_add"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">caption</span>&gt;</span>学生信息表<span class="tag">&lt;/<span class="name">caption</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>编号<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>操作<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">//给添加按钮绑定单击事件</span><br><span class="line">document.getElementById("btn_add").onclick = function () &#123;</span><br><span class="line">	//获取文本框内容</span><br><span class="line">    var id = document.getElementById("id").value;</span><br><span class="line">    var name = document.getElementById("name").value;</span><br><span class="line">    var gender = document.getElementById("gender").value;</span><br><span class="line">    //将输入的内容添加到表格    </span><br><span class="line">	var table = document.getElementsByTagName("table")[0];</span><br><span class="line"><span class="xml">	table.innerHTML += '<span class="tag">&lt;<span class="name">tr</span>&gt;</span>\n' +'<span class="tag">&lt;<span class="name">td</span>&gt;</span>'+ id +'<span class="tag">&lt;/<span class="name">td</span>&gt;</span>\n' +</span></span><br><span class="line"><span class="xml">		'<span class="tag">&lt;<span class="name">td</span>&gt;</span>'+ name +'<span class="tag">&lt;/<span class="name">td</span>&gt;</span>\n' +'<span class="tag">&lt;<span class="name">td</span>&gt;</span>'+ gender +'<span class="tag">&lt;/<span class="name">td</span>&gt;</span>\n' +</span></span><br><span class="line"><span class="xml">		'<span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"javascript:void(0)"</span> <span class="attr">onclick</span>=<span class="string">"delTr(this)"</span>&gt;</span>删除<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span>\n' +'<span class="tag">&lt;/<span class="name">tr</span>&gt;</span>';</span></span><br><span class="line">&#125;</span><br><span class="line">//定义删除方法</span><br><span class="line">function delTr(obj) &#123;  //节点关系：a -&gt; td -&gt; tr -&gt; table</span><br><span class="line">	var table = obj.parentNode.parentNode.parentNode;</span><br><span class="line">	var tr = obj.parentNode.parentNode;</span><br><span class="line">	table.removeChild(tr);</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="表单校验"><a href="#表单校验" class="headerlink" title="表单校验"></a>表单校验</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line">// 校验name的方法</span><br><span class="line">function checkName() &#123;</span><br><span class="line">	var name = document.getElementById("name").value;</span><br><span class="line">	var flag = /^[a-zA-Z]&#123;1,12&#125;$/.test(name);</span><br><span class="line">	var name_add = document.getElementById("span_name");</span><br><span class="line">	if(flag) &#123;</span><br><span class="line"><span class="xml">		name_add.innerHTML = "<span class="tag">&lt;<span class="name">img</span> <span class="attr">height</span> = <span class="string">'25'</span> <span class="attr">width</span> = <span class="string">'35'</span> " +"<span class="attr">src</span> = <span class="string">'img/gou.png'</span>&gt;</span>"</span></span><br><span class="line">	&#125;else&#123;</span><br><span class="line">		name_add.innerHTML = "姓名格式有误";</span><br><span class="line">	&#125;</span><br><span class="line">	return flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--表单校验的第一种方式--&gt;</span></span><br><span class="line">var form = document.getElementById("form");</span><br><span class="line">form.onsubmit = checkName;</span><br><span class="line"><span class="comment">&lt;!--表单校验的第二种方式--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"#"</span> <span class="attr">id</span>=<span class="string">"form"</span> <span class="attr">onsubmit</span>=<span class="string">"return checkName()"</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="14-Bootstrap"><a href="#14-Bootstrap" class="headerlink" title="14. Bootstrap"></a>14. Bootstrap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个前端开发的响应式布局框架，基于HTML、CSS、JavaScript开发，简洁灵活，使得 Web 开发更加快捷。</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--快速入门：导入Bootstrap文件和jQuery包，创建html页面，引入必要的资源文件： --&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"zh-CN"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"IE=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都必须跟随其后！ --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Index<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"css/bootstrap.min.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Bootstrap中js插件都是依赖于jquery的，要第一步引入--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/jquery-3.2.1.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"js/bootstrap.min.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World！<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h4 id="响应式布局"><a href="#响应式布局" class="headerlink" title="响应式布局"></a>响应式布局</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">响应式布局可以使同一套页面兼容不同分辨率的设备。</span><br><span class="line">实现方式依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现步骤：</p>
<ol>
<li>定义容器：作用相当于&lt; table&gt;，样式：&lt; div&gt;</li>
</ol>
<p>容器分类：1. container：两边留白；     2. container-fluid：每一种设备都是100%宽度</p>
<ol start="2">
<li>定义行：作用相当于&lt; tr&gt;，样式：&lt; row&gt;</li>
<li>定义元素：指定元素使用的设备和格子数目，样式：col-设备代号-格子数目</li>
</ol>
<p>设备代号：</p>
<ul>
<li>xs：超小屏幕 手机 (&lt;768px)</li>
<li>sm：小屏幕 平板 (≥768px)</li>
<li>md：中等屏幕 桌面显示器 (≥992px)</li>
<li>lg：大屏幕 大桌面显示器 (≥1200px)</li>
</ul>
<p>注意：</p>
<ol>
<li>一行中如果格子数目超过12，则超出部分自动换行</li>
<li>栅格类属性可以向上兼容，小尺寸设备代号兼容大尺寸设备显示</li>
<li>如果设备真实宽度小于栅格指定的设备代码的临界值，会一个元素占满一整行</li>
</ol>
</blockquote>
<h1 id="Web核心知识点总结"><a href="#Web核心知识点总结" class="headerlink" title="Web核心知识点总结"></a>Web核心知识点总结</h1><h3 id="1-XML概述"><a href="#1-XML概述" class="headerlink" title="1. XML概述"></a>1. XML概述</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Extensible Markup Language 可扩展标记语言，自定义标签，使用标记语言的特性描述数据结构，主要作为配置文件用于数据的存储以及传输。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>语法特点：</strong></p>
<ol>
<li>文档后缀名：xml</li>
<li>第一行必须定义为文档声明</li>
<li>文档中有且仅有一个根标签，所有标签必须闭合，区分大小写</li>
<li>属性值必须加引号</li>
</ol>
<p><strong>文档声明：</strong></p>
<ol>
<li>格式：<code>&lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot; standalone = &quot;yes&quot;?&gt;</code></li>
<li>version 版本号是必须的属性；</li>
<li>encoding 告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 不支持汉</li>
<li>standalone 是否独立，取值yes为不依赖其他文件，取值no为依赖其他文件</li>
</ol>
<p><strong>指令：</strong></p>
<ol>
<li>结合CSS指令：<code>&lt; ?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;</code></li>
<li>CDATA区（数据原样展示，不被解析）：<code>&lt;![CDATA[ 数据 ]]&gt;</code></li>
</ol>
</blockquote>
<h3 id="2-XML约束"><a href="#2-XML约束" class="headerlink" title="2. XML约束"></a>2. XML约束</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">规定xml文档的书写规则，不影响解析，主要有两种技术：</span><br><span class="line">DTD:一种简单的约束技术，约束的内容较为简单；Schema:一种复杂的约束技术，约束的内容较为详细</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>DTD引入：</strong></p>
<ul>
<li>内部dtd：将约束规则定义在xml文档中</li>
<li>外部dtd：将约束的规则定义在外部的dtd文件中</li>
</ul>
<p>本地：<code>&lt; !DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;</code></p>
<p>网络：<code>&lt; !DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;</code></p>
<p><strong>Schema引入：</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&gt; 1. 填写xml文档的根元素:</span><br><span class="line">&gt; 	&lt;beans</span><br><span class="line">&gt; 2. 引入xsd约束的标准，并声明前缀xsi：</span><br><span class="line">&gt; 	xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance</span><br><span class="line">&gt; 3. 给xsi的location参数赋值，说明引入的xsd文件路径，路径前是xsd文件的命名空间：</span><br><span class="line">&gt; 	xsi:schemaLocation=&quot;</span><br><span class="line">&gt;      http://www.springframework.org/schema/beans（命名空间） 		</span><br><span class="line">&gt;      http://www.springframework.org/schema/beans/spring-beans.xsd（文件路径）</span><br><span class="line">&gt;      http://www.springframework.org/schema/context （命名空间）</span><br><span class="line">&gt;      http://www.springframework.org/schema/context/spring-context.xsd（文件路径）</span><br><span class="line">&gt;      http://www.springframework.org/schema/mvc（命名空间）</span><br><span class="line">&gt;      http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;（文件路径）</span><br><span class="line">&gt; 4. 为每一个xsd约束声明一个前缀，作为标识：</span><br><span class="line">&gt; 	xmlns=&quot;http://www.springframework.org/schema/beans&quot;（无前缀为默认）</span><br><span class="line">&gt; 	xmlns:context=&quot;http://www.springframework.org/schema/context&quot;（前缀context）</span><br><span class="line">&gt; 	xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;（前缀mvc）&gt;	</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h3 id="3-XML解析"><a href="#3-XML解析" class="headerlink" title="3. XML解析"></a>3. XML解析</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">操作xml文档，将文档中的数据读取到内存中</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>解析的方式：</strong></p>
<ol>
<li>DOM：将标记语言文档一次性加载进内存，在内存中形成一颗DOM树</li>
</ol>
<p>优点：操作方便，可以对文档进行CRUD操作；缺点：占内存</p>
<ol start="2">
<li>SAX：逐行读取，基于事件驱动</li>
</ol>
<p>优点：不占内存；缺点：只能读取，不能增删改</p>
<p><strong>常见解析器</strong>：</p>
<ol>
<li>JAXP：sun公司提供的解析器，支持dom和sax两种思想</li>
<li>DOM4J：一款非常优秀的解析器。应用广泛，对XPath支持度高</li>
<li>Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据</li>
<li>PULL：Android操作系统内置的解析器，sax方式的</li>
</ol>
</blockquote>
<h4 id="Jsoup解析器"><a href="#Jsoup解析器" class="headerlink" title="Jsoup解析器"></a>Jsoup解析器</h4><blockquote>
<p>Jsoup方法：</p>
<ol>
<li>parse解析，返回Document：<ul>
<li>parse(File in, String charsetName)：解析xml或html文件的</li>
<li>parse(String html)：解析xml或html字符串</li>
<li>parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象</li>
</ul>
</li>
<li>通过Document的方法获取Elements对象：<ul>
<li>getElementById(String id)：根据id属性值获取唯一的element对象</li>
<li>getElementsByTag(String tagName)：根据标签名称获取元素对象集合</li>
<li>getElementsByAttribute(String key)：根据属性名称获取元素对象集合</li>
<li>getElementsByAttributeValue(String key, String value)：根据属性名和属性值获取元素对象集合</li>
</ul>
</li>
<li>通过Elements集合获取元素Element（Elements可当做ArrayList使用）：<ul>
<li>String attr(String key)：根据属性名称获取属性值</li>
<li>String text():获取文本内容</li>
<li>String html():获取标签体的所有内容(包括子标签及其字符串内容)</li>
</ul>
</li>
<li>selector选择器：<ul>
<li>document.select(String cssQuery)，返回Elements</li>
<li>cssQuery语法参考Selector类中定义的语法：</li>
</ul>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;    <span class="comment">//示例：获取student标签并且number属性值为heima_0001的age子标签</span></span><br><span class="line">&gt;   	document.select(<span class="string">"student[number=\"heima_0001\"] &gt; age"</span>);</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Jsoup使用步骤</span></span><br><span class="line"><span class="comment">//0.导入jar包：jsoup-1.11.2.jar</span></span><br><span class="line"><span class="comment">//1.获取要解析文件的路径</span></span><br><span class="line">String path = Demo01Jsoup.class.getClassLoader().getResource(<span class="string">"url"</span>).getPath();</span><br><span class="line"><span class="comment">//2.通过Jsoup的方法解析，加载文档进内存，获取Document对象</span></span><br><span class="line">Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//3.获取元素对象集合</span></span><br><span class="line">Elements elements = document.getElementsByTag(<span class="string">"name"</span>);</span><br><span class="line"><span class="comment">//4.获取单个元素对象</span></span><br><span class="line">Element element = elements.get(<span class="number">1</span>);</span><br><span class="line">System.out.println(element.html());	<span class="comment">//获取标签体的所有内容(包括子标签)</span></span><br><span class="line">System.out.println(element.text());	<span class="comment">//获取文本内容</span></span><br></pre></td></tr></table></figure>

<h4 id="Xpath路径语言"><a href="#Xpath路径语言" class="headerlink" title="Xpath路径语言"></a>Xpath路径语言</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言，使用Jsoup的Xpath需要额外导入jar包，Jsoup只支持XPath1.0。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//XPath使用演示：</span></span><br><span class="line"><span class="comment">//1.获取要解析文件的路径</span></span><br><span class="line">String path = Demo01Jsoup.class.getClassLoader().getResource(<span class="string">"url"</span>).getPath();</span><br><span class="line"><span class="comment">//2.通过Jsoup的方法解析，加载文档进内存，获取Document对象</span></span><br><span class="line">Document document = Jsoup.parse(<span class="keyword">new</span> File(path), <span class="string">"utf-8"</span>);</span><br><span class="line"><span class="comment">//3.根据document对象，创建JXDocument对象</span></span><br><span class="line">JXDocument jxDocument = <span class="keyword">new</span> JXDocument(document);</span><br><span class="line"><span class="comment">//4.结合xpath语法查询符合条件的结果并输出</span></span><br><span class="line">List&lt;JXNode&gt; jxNodes = jxDocument.selN(<span class="string">"条件"</span>);</span><br><span class="line"><span class="keyword">for</span> (JXNode jxNode : jxNodes) &#123;</span><br><span class="line">    System.out.println(jxNode);&#125;</span><br><span class="line"><span class="comment">//条件示范：</span></span><br><span class="line"><span class="comment">//查询所有student标签：</span></span><br><span class="line">jxDocument.selN(<span class="string">"//student"</span>); </span><br><span class="line"><span class="comment">//查询所有student标签下的name标签：</span></span><br><span class="line">jxDocument.selN(<span class="string">"//student/name"</span>); </span><br><span class="line"><span class="comment">//查询student标签下带有id属性的name标签：</span></span><br><span class="line">jxDocument.selN(<span class="string">"//student/name[@id]"</span>); </span><br><span class="line"><span class="comment">//查询student标签下带有id属性的name标签，并且id属性值为itcast：</span></span><br><span class="line">jxDocument.selN(<span class="string">"//student/name[@id='itcast']"</span>);</span><br></pre></td></tr></table></figure>

<h3 id="4-web服务器软件"><a href="#4-web服务器软件" class="headerlink" title="4. web服务器软件"></a>4. web服务器软件</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">web服务器软件搭载在服务器上，可以部署web项目，让用户通过浏览器来访问这些项目</span><br><span class="line">常见的java相关的web服务器软件：</span><br><span class="line">	webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。</span><br><span class="line">	webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。</span><br><span class="line">	JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费。</span><br><span class="line">	Tomcat：Apache基金组织，中小型的JavaEE服务器，支持少量的JavaEE规范servlet/jsp，开源，免费。</span><br></pre></td></tr></table></figure>

<h4 id="Tomcat介绍"><a href="#Tomcat介绍" class="headerlink" title="Tomcat介绍"></a>Tomcat介绍</h4><blockquote>
<p>启动：打开bin/startup.bat</p>
<p>关闭：打开bin/shutdown.bat或在命令行ctrl+c</p>
<p>部署项目的三种方式：</p>
<ol>
<li>将项目打包成war(zip)包，放到<code>webapps</code>目录下即可</li>
</ol>
<p>war包会自动解压缩，若需部署多个项目，可以放到虚拟目录中区分不同的项目。</p>
<ol start="2">
<li>配置<code>conf/server.xm</code>l文件<ul>
<li>docBase:项目存放的路径  </li>
<li>path：虚拟目录</li>
</ul>
</li>
<li>在<code>conf\Catalina\localhost</code>创建xml文件</li>
</ol>
<p>xml文件名为虚拟目录名</p>
<p>xml文件中编写<context docbase="D:\hello"></context></p>
</blockquote>
<h3 id="5-Servlet接口"><a href="#5-Servlet接口" class="headerlink" title="5. Servlet接口"></a>5. Servlet接口</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。</span><br><span class="line">Java类只要实现了这个接口，那么这个类就可以被浏览器访问到（让该类代码执行）。</span><br></pre></td></tr></table></figure>

<h4 id="访问原理"><a href="#访问原理" class="headerlink" title="访问原理"></a>访问原理</h4><blockquote>
<ol>
<li>当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径<ol start="2">
<li>查找web.xml文件，是否有对应的<url-pattern>标签体内容。</url-pattern></li>
<li>如果有，则在找到对应的<servlet-class>全类名</servlet-class></li>
<li>tomcat会将字节码文件加载进内存，并且通过反射机制创建其对象</li>
<li>调用其方法</li>
</ol>
</li>
</ol>
</blockquote>
<h4 id="使用步骤"><a href="#使用步骤" class="headerlink" title="使用步骤"></a>使用步骤</h4><blockquote>
<ol>
<li>创建JavaEE项目</li>
<li>定义一个类，实现Servlet接口<code>public class ServletDemo1 implements Servle</code></li>
<li>实现接口中的抽象方法</li>
<li><strong>配置Servlet</strong></li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="comment">//方法一： </span></span><br><span class="line">&gt; 在web.xml中配置：</span><br><span class="line">&gt; 	&lt;!--配置Servlet --&gt;</span><br><span class="line">&gt; 	&lt;servlet&gt;</span><br><span class="line">&gt; 	        &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;</span><br><span class="line">&gt; 	        &lt;servlet-<span class="class"><span class="keyword">class</span>&gt;<span class="title">cn</span>.<span class="title">itcast</span>.<span class="title">web</span>.<span class="title">servlet</span>.<span class="title">ServletDemo1</span>&lt;/<span class="title">servlet</span>-<span class="title">class</span>&gt;</span></span><br><span class="line"><span class="class">&gt; 	&lt;/<span class="title">servlet</span>&gt;</span></span><br><span class="line"><span class="class">&gt; 	</span></span><br><span class="line"><span class="class">&gt; 	&lt;<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&gt; 		&lt;<span class="title">servlet</span>-<span class="title">name</span>&gt;<span class="title">demo1</span>&lt;/<span class="title">servlet</span>-<span class="title">name</span>&gt;</span></span><br><span class="line"><span class="class">&gt; 		&lt;<span class="title">url</span>-<span class="title">pattern</span>&gt;/<span class="title">demo1</span>&lt;/<span class="title">url</span>-<span class="title">pattern</span>&gt;</span></span><br><span class="line"><span class="class">&gt; 	&lt;/<span class="title">servlet</span>-<span class="title">mapping</span>&gt;</span></span><br><span class="line"><span class="class">&gt; 	/*在&lt;<span class="title">servlet</span>&gt;标签下配置 &lt;<span class="title">load</span>-<span class="title">on</span>-<span class="title">startup</span>&gt;，赋值：</span></span><br><span class="line"><span class="class">&gt; 		值为负数：第一次被访问时创建</span></span><br><span class="line"><span class="class">&gt; 	    值为非负数：在服务器启动时创建*/    </span></span><br><span class="line"><span class="class">&gt; //方法二：</span></span><br><span class="line">&gt; 在类上使用@WebServlet("/资源路径")注解，进行配置 (Servlet3.0版本以上)</span><br><span class="line">&gt; <span class="comment">//一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;"/d4","/dd4","/ddd4"&#125;)</span></span><br><span class="line">&gt; <span class="comment">//路径定义规则：</span></span><br><span class="line">&gt;       <span class="number">1</span>. /xxx/xxx:多层路径，目录结构</span><br><span class="line">&gt;       <span class="number">2</span>. *.<span class="keyword">do</span>：扩展名匹配(任何以.<span class="keyword">do</span>结尾都可以匹配到)                             </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="内部方法"><a href="#内部方法" class="headerlink" title="内部方法"></a>内部方法</h4><blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ServletConfig servletConfig)</span> <span class="keyword">throws</span> ServletException </span>&#123;</span><br><span class="line">&gt; 	<span class="comment">//Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">&gt;  <span class="comment">//每次访问Servlet时，Service方法都会被调用一次。</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&gt; 	<span class="comment">//destroy方法在Servlet服务器正常关闭之前才会执行，一般用于释放资源。</span></span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> String <span class="title">getServletInfo</span><span class="params">()</span> </span>&#123;   <span class="comment">//不常用</span></span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt; <span class="meta">@Override</span></span><br><span class="line">&gt; <span class="function"><span class="keyword">public</span> ServletConfig <span class="title">getServletConfig</span><span class="params">()</span> </span>&#123;   <span class="comment">//不常用</span></span><br><span class="line">&gt;  <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">op1=&gt;operation: Servlet -- 接口</span><br><span class="line">op2=&gt;operation: GenericServlet -- 抽象类</span><br><span class="line">op3=&gt;operation: HttpServlet  -- 抽象类</span><br><span class="line">op1-&gt;op2-&gt;op3</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象。继承后实现service()方法即可。</li>
<li>HttpServlet：对http协议的一种封装，简化操作。复写doGet/doPost方法。</li>
</ul>
</blockquote>
<h3 id="6-HTTP协议"><a href="#6-HTTP协议" class="headerlink" title="6. HTTP协议"></a>6. HTTP协议</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Hyper Text Transfer Protocol 超文本传输协议：定义了，客户端和服务器端通信时，发送数据的格式</span><br><span class="line">客户端和服务器必须同时遵守HTTP协议，才能通信</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<ol>
<li>基于TCP/IP的高级协议</li>
<li>默认端口号:80</li>
<li>基于请求/响应模型的:一次请求对应一次响应</li>
<li>无状态的：每次请求之间相互独立，不能交互数据</li>
</ol>
</blockquote>
<blockquote>
<p>版本：</p>
<ul>
<li>1.0：每一次请求响应都会建立新的连接Connection，较耗费资源</li>
<li>1.1：复用连接，Connection复用，省略了重复创建连接所耗费的资源</li>
<li>2.0：1.X版本都是使用文本传输数据，2.0开始使用字节传输，多路复用，速率提升</li>
</ul>
</blockquote>
<h3 id="7-请求消息数据格式"><a href="#7-请求消息数据格式" class="headerlink" title="7. 请求消息数据格式"></a>7. 请求消息数据格式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">POST /login.html	HTTP/1.1  <span class="comment">&lt;!--1.请求行：请求方式+请求url+请求协议/版本--&gt;</span></span><br><span class="line">Host: localhost     <span class="comment">&lt;!--2.请求头：IP地址+User-Agent浏览器信息+Referer来源+...--&gt;</span></span><br><span class="line">User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0</span><br><span class="line">Accept: text/html,application/xhtml+xml,application/xml;q=0.9,;q=0.8</span><br><span class="line">Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2</span><br><span class="line">Accept-Encoding: gzip, deflate</span><br><span class="line">Referer: http://localhost/login.html<span class="comment">&lt;!--告诉服务器请求的来源--&gt;</span></span><br><span class="line">Connection: keep-alive</span><br><span class="line">Upgrade-Insecure-Requests: 1	<span class="comment">&lt;!--2.请求头--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--3.请求空行：分割请求头和请求体--&gt;</span></span><br><span class="line">username=zhangsan	<span class="comment">&lt;!--4.请求体(正文)：封装POST请求消息的请求参数的--&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>常见的请求头：</p>
<ol>
<li>User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息。服务器端可以获取该信息，针对不同浏览器设置参数，解决浏览器的兼容性问题。</li>
<li>Referer：<a href="http://localhost/login.html：告诉服务器当前请求的来源。作用：防盗链，统计工作。" target="_blank" rel="noopener">http://localhost/login.html：告诉服务器当前请求的来源。作用：防盗链，统计工作。</a></li>
</ol>
</blockquote>
<h3 id="8-Request对象"><a href="#8-Request对象" class="headerlink" title="8. Request对象"></a>8. Request对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request对象用来获取请求消息，response对象用来设置响应消息，request和response对象都是由服务器创建的。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>request对象继承体系结构：</strong></p>
<p>​                        ServletRequest 接口<br>​                                     |    继承<br>​                 HttpServletRequest 接口<br>​                                     |    实现<br>org.apache.catalina.connector.RequestFacade 类(tomcat)<br>在用户发出请求的时候 会自动的创建RequestFacade对象</p>
</blockquote>
<h4 id="获取请求消息数据的方法"><a href="#获取请求消息数据的方法" class="headerlink" title="获取请求消息数据的方法"></a>获取请求消息数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取请求方式 </span></span><br><span class="line">String method = request.getMethod();	<span class="comment">// GET</span></span><br><span class="line"><span class="comment">//获取虚拟目录 </span></span><br><span class="line">String contextPath = request.getContextPath();	<span class="comment">// day03</span></span><br><span class="line"><span class="comment">//获取Servlet路径 </span></span><br><span class="line">String servletPath = request.getServletPath();	<span class="comment">// /Demo01Servlet</span></span><br><span class="line"><span class="comment">//获取get方式请求参数 </span></span><br><span class="line">String queryString = request.getQueryString();	<span class="comment">// username=zhangsan</span></span><br><span class="line"><span class="comment">//获取请求URI、URL</span></span><br><span class="line">String requestURI = request.getRequestURI();	<span class="comment">// /day03/Demo01Servlet</span></span><br><span class="line">StringBuffer requestURL = request.getRequestURL();</span><br><span class="line"><span class="comment">//http://localhost:8080/day03/Demo01Servlet</span></span><br><span class="line"><span class="comment">//获取协议及版本 </span></span><br><span class="line">String protocol = request.getProtocol();	<span class="comment">// HTTP/1.1</span></span><br><span class="line"><span class="comment">//获取客户机的IP地址 </span></span><br><span class="line">String remoteAddr = request.getRemoteAddr();	<span class="comment">// 0:0:0:0:0:0:0:1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>URL：统一资源定位符：<a href="http://localhost/day14/demo1" target="_blank" rel="noopener">http://localhost/day14/demo1</a>    （中华人民共和国）</li>
<li>URI：统一资源标识符：/day14/demo1        （共和国）</li>
</ul>
</blockquote>
<h4 id="获取请求头数据的方法"><a href="#获取请求头数据的方法" class="headerlink" title="获取请求头数据的方法"></a>获取请求头数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getHeader</span><span class="params">(String name)</span>:通过请求头的名称获取请求头的值</span></span><br><span class="line"><span class="function">Enumeration&lt;String&gt; <span class="title">getHeaderNames</span><span class="params">()</span>:获取所有的请求头名称，封装为键值对</span></span><br><span class="line"><span class="function">    <span class="comment">//使用示范：</span></span></span><br><span class="line"><span class="function">    Enumeration&lt;String&gt; headerNames </span>= request.getHeaderNames();</span><br><span class="line">        <span class="keyword">while</span> (headerNames.hasMoreElements()) &#123;</span><br><span class="line">            String name = headerNames.nextElement();</span><br><span class="line">            String value = request.getHeader(name);</span><br><span class="line">            System.out.println(name + <span class="string">"------"</span> + value);&#125;</span><br><span class="line">    <span class="comment">/*输出结果：</span></span><br><span class="line"><span class="comment">    host------localhost:8080</span></span><br><span class="line"><span class="comment">    connection------keep-alive</span></span><br><span class="line"><span class="comment">    cache-control------max-age=0</span></span><br><span class="line"><span class="comment">    upgrade-insecure-requests------1</span></span><br><span class="line"><span class="comment">    user-agent------Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML,     like Gecko) Chrome/74.0.3729.108 Safari/537.36</span></span><br><span class="line"><span class="comment">    accept-----text/html,application/xhtml+xml,application/xml;</span></span><br><span class="line"><span class="comment">    accept-encoding------gzip, deflate, br</span></span><br><span class="line"><span class="comment">    accept-language------zh-CN,zh;q=0.9</span></span><br><span class="line"><span class="comment">    cookie------_xsrf=2|50c9000a|7b65bf12b3842e1198f0522667c61f08|1554439214; */</span></span><br></pre></td></tr></table></figure>

<h4 id="获取请求体数据的方法"><a href="#获取请求体数据的方法" class="headerlink" title="获取请求体数据的方法"></a>获取请求体数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数</span></span><br><span class="line"><span class="comment">//步骤：1. 获取流对象</span></span><br><span class="line">	<span class="function">BufferedReader <span class="title">getReader</span><span class="params">()</span>：获取字符输入流，只能操作字符数据</span></span><br><span class="line"><span class="function">	ServletInputStream <span class="title">getInputStream</span><span class="params">()</span>：获取字节输入流，可以操作所有类型数据</span></span><br><span class="line"><span class="function">	<span class="comment">//2. 再从流对象中拿数据</span></span></span><br></pre></td></tr></table></figure>

<h4 id="获取请求参数通用方式"><a href="#获取请求参数通用方式" class="headerlink" title="获取请求参数通用方式"></a>获取请求参数通用方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function">String <span class="title">getParameter</span><span class="params">(String name)</span>:根据参数名称获取参数值 </span></span><br><span class="line"><span class="function">2. String[] <span class="title">getParameterValues</span><span class="params">(String name)</span>:根据参数名称获取参数值的数组  </span></span><br><span class="line"><span class="function">3. Enumeration&lt;String&gt; <span class="title">getParameterNames</span><span class="params">()</span>:获取所有请求的参数名称</span></span><br><span class="line"><span class="function">4. Map&lt;String,String[]&gt; <span class="title">getParameterMap</span><span class="params">()</span>:获取所有参数的map集合</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>中文乱码问题：post方式会乱码，我们在获取前端传递的参数之前，都进行设置编码</p>
<p><code>request.setCharacterEncoding(&quot;utf-8&quot;);</code></p>
</blockquote>
<h4 id="请求转发的方法"><a href="#请求转发的方法" class="headerlink" title="请求转发的方法"></a>请求转发的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request.getRequestDispatcher(<span class="string">"String path"</span>).forward(request,response);</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>浏览器地址栏路径不发生变化</li>
<li>只能转发到当前服务器内部资源中</li>
<li>转发是一次请求，多个资源用的是同一个请求</li>
</ol>
</blockquote>
<h4 id="共享数据的方法"><a href="#共享数据的方法" class="headerlink" title="共享数据的方法"></a>共享数据的方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">void</span> <span class="title">setAttribute</span><span class="params">(String name,Object obj)</span>:存储数据</span></span><br><span class="line"><span class="function">2. Object <span class="title">getAttitude</span><span class="params">(String name)</span>:通过键获取值</span></span><br><span class="line"><span class="function">3. <span class="keyword">void</span> <span class="title">removeAttribute</span><span class="params">(String name)</span>:通过键移除键值对</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>域对象：一个有作用范围的对象，可以在范围内共享数据</li>
<li>request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据</li>
</ul>
</blockquote>
<h3 id="9-BeanUtils工具类"><a href="#9-BeanUtils工具类" class="headerlink" title="9. BeanUtils工具类"></a>9. BeanUtils工具类</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">用于封装标准JavaBean的工具类，按照属性进行映射。</span><br><span class="line">属性：setter和getter方法截取后的产物例，如：getUsername() --&gt; Username--&gt; username</span><br></pre></td></tr></table></figure>

<blockquote>
<p>方法：</p>
<ol>
<li>setProperty()</li>
<li>getProperty()</li>
<li>populate(Object obj , Map map):将map集合的键值对信息，封装到对应的JavaBean对象中</li>
</ol>
</blockquote>
<h3 id="10-响应消息数据格式"><a href="#10-响应消息数据格式" class="headerlink" title="10. 响应消息数据格式"></a>10. 响应消息数据格式</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK  	<span class="comment">&lt;!--1.响应行：协议/版本+响应状态码+状态码描述--&gt;</span></span><br><span class="line">Content-Type: text/html;charset=UTF-8<span class="comment">&lt;!--2.响应头：协议/版本+响应状态码+状态码描述--&gt;</span></span><br><span class="line">Content-Length: 101</span><br><span class="line">Date: Wed, 06 Jun 2018 07:08:42 GMT</span><br><span class="line">	<span class="comment">&lt;!--3.响应空行--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>			<span class="comment">&lt;!--4.响应体:传输的数据--&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="name">title</span>&gt;</span>$Title$<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">		hello , response</span><br><span class="line">	<span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span>			<span class="comment">&lt;!--4.响应体:传输的数据--&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li>响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态，状态码都是3位数字。<ul>
<li>1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码</li>
<li>2xx：成功。代表：200</li>
<li>3xx：重定向。代表：302(重定向)，304(访问缓存)</li>
<li>4xx：客户端错误。代表：404(请求路径没有对应的资源)，405：(请求方式没有对应的doXxx方法)</li>
<li>5xx：服务器端错误。代表：500(服务器内部出现异常，写的代码有bug)</li>
</ul>
</li>
<li>常见的响应头：<ul>
<li>Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式</li>
<li>Content-disposition：服务器告诉客户端以什么格式打开响应体数据<ul>
<li>in-line：默认值，在当前页面内打开</li>
<li>attachment；filename=xxx：以附件形式打开响应体：文件下载</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="11-Response对象"><a href="#11-Response对象" class="headerlink" title="11. Response对象"></a>11. Response对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request对象和response对象由tomcat创建，每次请求相互独立</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Response方法</strong>：</p>
<ul>
<li>设置状态码：<code>setStatus(int sc)</code></li>
<li>设置响应头：<code>setHeader(String name, String value)</code></li>
<li>设置响应体：</li>
<li>字符输出流：<code>PrintWriter getWriter()</code></li>
<li>字节输出流：<code>ServletOutputStream getOutputStream()</code></li>
<li>设置输出流的编码：<code>response.setContentType(&quot;text/html;charset=utf-8&quot;);</code></li>
</ul>
<p>setContentType方法同时起到两个作用：1. 设置该流的默认编码    2. 告诉浏览器响应体使用的编码</p>
</blockquote>
<h3 id="12-重定向"><a href="#12-重定向" class="headerlink" title="12. 重定向"></a>12. 重定向</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">重定向：资源跳转的方式</span><br><span class="line"><span class="comment">//基本的重定向方法：1. 设置状态码为302；2.设置响应头location</span></span><br><span class="line">response.setStatus(<span class="number">302</span>);</span><br><span class="line">response.setHeader(<span class="string">"location"</span>,<span class="string">"/responseDemo2"</span>);</span><br><span class="line"><span class="comment">//简化的重定向方法：</span></span><br><span class="line">response.sendRedirect(<span class="string">"/responseDemo2"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>转发(forward)和重定向(redirect)的特点：</strong> </p>
<ul>
<li>转发的特点：<ol>
<li>转发地址栏路径不变</li>
<li>转发只能访问当前服务器下的资源</li>
<li>转发是一次请求，可以使用request对象来共享数据</li>
<li>跳转路径<strong>不需要加虚拟目录</strong></li>
</ol>
</li>
<li>重定向的特点<ol>
<li>重定向地址栏路径变化</li>
<li>重定向可以访问其他站点(服务器)的资源</li>
<li>重定向是两次独立的请求，不能使用request对象来共享数据</li>
<li>跳转路径<strong>需要加虚拟目录</strong></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="13-ServletContext对象"><a href="#13-ServletContext对象" class="headerlink" title="13. ServletContext对象"></a>13. ServletContext对象</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">代表整个web应用，可以和程序的容器(服务器)来通信</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>ServletContext方法</strong>：</p>
<ul>
<li>获取ServletContext：<ol>
<li>通过request对象获取：<code>equest.getServletContext();</code></li>
<li>通过HttpServlet获取：<code>this.getServletContext();</code></li>
</ol>
</li>
<li>获取MIME类型：<ol>
<li>MIME类型:在互联网通信过程中定义的一种文件数据类型（大类型/小类型：image/jpeg）</li>
<li><code>String getMimeType(String file)</code></li>
</ol>
</li>
<li>域对象：共享数据（对象范围：所有用户所有请求的数据）<ol>
<li><code>setAttribute(String name,Object value)</code></li>
<li><code>getAttribute(String name)</code></li>
<li><code>removeAttribute(String name)</code></li>
</ol>
</li>
</ul>
<p>（由于ServletContext域对象范围太大，一般不用）</p>
<ul>
<li>获取文件的真实(<strong>服务器</strong>)路径：<code>String getRealPath(String path)</code><ol>
<li>获取web目录下资源：<code>getRealPath(&quot;/a.txt&quot;);</code></li>
<li>获取WEB-INF目录下资源：<code>getRealPath(&quot;/WEB-INF/a.txt&quot;);</code></li>
<li>获取src目录下资源：<code>getRealPath(&quot;/WEB-INF/classes/a.txt&quot;);</code></li>
</ol>
</li>
</ul>
</blockquote>
<h3 id="14-案例：文件下载"><a href="#14-案例：文件下载" class="headerlink" title="14. 案例：文件下载"></a>14. 案例：文件下载</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取请求参数中的文件名称，找到该文件的真实路径，关联给字节输入流</span></span><br><span class="line">String filename = request.getParameter(<span class="string">"filename"</span>);	</span><br><span class="line">   ServletContext servletContext = <span class="keyword">this</span>.getServletContext();</span><br><span class="line">   String realPath = servletContext.getRealPath(<span class="string">"/img/"</span> + filename);</span><br><span class="line">   FileInputStream fis = <span class="keyword">new</span> FileInputStream(realPath);	</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置response响应头的"content-type"参数为图片的Mime格式</span></span><br><span class="line">   String mimeType = servletContext.getMimeType(filename);	</span><br><span class="line">   response.setHeader(<span class="string">"content-type"</span>, mimeType);</span><br><span class="line"></span><br><span class="line"><span class="comment">//通过工具将filename改造成对应浏览器能够解读的格式</span></span><br><span class="line">   String userAgent = request.getHeader(<span class="string">"user-agent"</span>);	</span><br><span class="line">   filename = DownLoadUtils.getFileName(userAgent, filename);</span><br><span class="line"><span class="comment">//设置response响应头的"content-disposition"参数为附件形式</span></span><br><span class="line">   response.setHeader(<span class="string">"content-disposition"</span>,<span class="string">"attachment;filename="</span> + filename);</span><br><span class="line"></span><br><span class="line">   <span class="comment">//将输入流的数据写出到输出流中</span></span><br><span class="line">   ServletOutputStream sos = response.getOutputStream();</span><br><span class="line">   <span class="keyword">byte</span>[] buff = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span> * <span class="number">8</span>];</span><br><span class="line">   <span class="keyword">int</span> len = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">while</span> ((len = fis.read(buff)) != -<span class="number">1</span>) &#123;</span><br><span class="line">       sos.write(buff, <span class="number">0</span>, len);</span><br><span class="line">   &#125;</span><br><span class="line">   fis.close();</span><br></pre></td></tr></table></figure>


      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/15/hello-world/" rel="next" title="Hello World">
                <i class="fa fa-chevron-left"></i> Hello World
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">John Doe</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">2</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#基础班知识点总结"><span class="nav-number">1.</span> <span class="nav-text">基础班知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-01-【前言、入门程序、常量、变量】"><span class="nav-number">1.1.</span> <span class="nav-text">Day 01 【前言、入门程序、常量、变量】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Java语言用途"><span class="nav-number">1.1.0.1.</span> <span class="nav-text">1. Java语言用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-十进制和二进制的转换规则"><span class="nav-number">1.1.0.2.</span> <span class="nav-text">2. 十进制和二进制的转换规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-计算机存储单元"><span class="nav-number">1.1.0.3.</span> <span class="nav-text">3.计算机存储单元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java的跨平台性？"><span class="nav-number">1.1.0.4.</span> <span class="nav-text">4. Java的跨平台性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-JDK、JRE和JVM"><span class="nav-number">1.1.0.5.</span> <span class="nav-text">5. JDK、JRE和JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-环境变量配置的意义"><span class="nav-number">1.1.0.6.</span> <span class="nav-text">6. 环境变量配置的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Java程序编写的三个步骤"><span class="nav-number">1.1.0.7.</span> <span class="nav-text">7. Java程序编写的三个步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-常用命令提示符"><span class="nav-number">1.1.0.8.</span> <span class="nav-text">8. 常用命令提示符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-注释及其格式"><span class="nav-number">1.1.0.9.</span> <span class="nav-text">9. 注释及其格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-关键字"><span class="nav-number">1.1.0.10.</span> <span class="nav-text">10. 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-标识符及其定义规范"><span class="nav-number">1.1.0.11.</span> <span class="nav-text">11. 标识符及其定义规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-数据类型"><span class="nav-number">1.1.0.12.</span> <span class="nav-text">12. 数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-常量及其分类"><span class="nav-number">1.1.0.13.</span> <span class="nav-text">13. 常量及其分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-变量及其定义格式"><span class="nav-number">1.1.0.14.</span> <span class="nav-text">14. 变量及其定义格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-02-【数据类型转换、运算符、方法入门】"><span class="nav-number">1.2.</span> <span class="nav-text">Day 02 【数据类型转换、运算符、方法入门】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据类型转换"><span class="nav-number">1.2.0.1.</span> <span class="nav-text">1. 数据类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-精度损失和数据溢出"><span class="nav-number">1.2.0.2.</span> <span class="nav-text">2. 精度损失和数据溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运算时数据类型的转换规则"><span class="nav-number">1.2.0.3.</span> <span class="nav-text">3.  运算时数据类型的转换规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-编译器的两点优化"><span class="nav-number">1.2.0.4.</span> <span class="nav-text">4.  编译器的两点优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-加号的三种用法"><span class="nav-number">1.2.0.5.</span> <span class="nav-text">5. 加号的三种用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ASCII码表"><span class="nav-number">1.2.0.6.</span> <span class="nav-text">6. ASCII码表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-运算符"><span class="nav-number">1.2.0.7.</span> <span class="nav-text">7. 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-、–的使用场景"><span class="nav-number">1.2.0.8.</span> <span class="nav-text">8. ++、–的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-a-1和a-a-1的区别"><span class="nav-number">1.2.0.9.</span> <span class="nav-text">9. a += 1和a = a + 1的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-定义方法的好处"><span class="nav-number">1.2.0.10.</span> <span class="nav-text">10. 定义方法的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-方法定义和调用的注意事项"><span class="nav-number">1.2.0.11.</span> <span class="nav-text">11. 方法定义和调用的注意事项</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-03-【流程控制语句】"><span class="nav-number">1.3.</span> <span class="nav-text">Day 03 【流程控制语句】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-if语句的三种格式"><span class="nav-number">1.3.0.1.</span> <span class="nav-text">1. if语句的三种格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-程序的健壮性"><span class="nav-number">1.3.0.2.</span> <span class="nav-text">2. 程序的健壮性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-switch语句的格式"><span class="nav-number">1.3.0.3.</span> <span class="nav-text">3. switch语句的格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-三种循环语句的格式"><span class="nav-number">1.3.0.4.</span> <span class="nav-text">4. 三种循环语句的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）for循环"><span class="nav-number">1.3.0.4.1.</span> <span class="nav-text">（1）for循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）while循环"><span class="nav-number">1.3.0.4.2.</span> <span class="nav-text">（2）while循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）do-while循环"><span class="nav-number">1.3.0.4.3.</span> <span class="nav-text">（3）do..while循环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-三种循环语句的区别"><span class="nav-number">1.3.0.5.</span> <span class="nav-text">5. 三种循环语句的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-break和continue"><span class="nav-number">1.3.0.6.</span> <span class="nav-text">6. break和continue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-死循环的格式"><span class="nav-number">1.3.0.7.</span> <span class="nav-text">7. 死循环的格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-04-【Idea、方法】"><span class="nav-number">1.4.</span> <span class="nav-text">Day 04 【Idea、方法】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是方法"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">1. 什么是方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-方法的定义格式"><span class="nav-number">1.4.0.2.</span> <span class="nav-text">2. 方法的定义格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-return的作用"><span class="nav-number">1.4.0.3.</span> <span class="nav-text">3. return的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-方法的调用的方式"><span class="nav-number">1.4.0.4.</span> <span class="nav-text">4.方法的调用的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-方法的执行流程"><span class="nav-number">1.4.0.5.</span> <span class="nav-text">5. 方法的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-方法的三要素"><span class="nav-number">1.4.0.6.</span> <span class="nav-text">6. 方法的三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-方法的重载"><span class="nav-number">1.4.0.7.</span> <span class="nav-text">7. 方法的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-IDEA-常用快捷键"><span class="nav-number">1.4.0.8.</span> <span class="nav-text">8. IDEA 常用快捷键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-05-【数组】"><span class="nav-number">1.5.</span> <span class="nav-text">Day 05 【数组】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是数组"><span class="nav-number">1.5.0.1.</span> <span class="nav-text">1. 什么是数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数组的初始化"><span class="nav-number">1.5.0.2.</span> <span class="nav-text">2. 数组的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-索引"><span class="nav-number">1.5.0.3.</span> <span class="nav-text">3. 索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java内存的5个组成部分"><span class="nav-number">1.5.0.4.</span> <span class="nav-text">4. Java内存的5个组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-数组越界索引异常"><span class="nav-number">1.5.0.5.</span> <span class="nav-text">5. 数组越界索引异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-数组空指针异常"><span class="nav-number">1.5.0.6.</span> <span class="nav-text">6. 数组空指针异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-方法的参数类型区别"><span class="nav-number">1.5.0.7.</span> <span class="nav-text">7. 方法的参数类型区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-数组的直接打印"><span class="nav-number">1.5.0.8.</span> <span class="nav-text">8. 数组的直接打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-数组的内存执行流程"><span class="nav-number">1.5.0.9.</span> <span class="nav-text">9. 数组的内存执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-数组的反转"><span class="nav-number">1.5.0.10.</span> <span class="nav-text">10. 数组的反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-06-【类与对象、封装、构造方法】"><span class="nav-number">1.6.</span> <span class="nav-text">Day 06 【类与对象、封装、构造方法】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-面向对象"><span class="nav-number">1.6.0.1.</span> <span class="nav-text">1. 面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-类与对象"><span class="nav-number">1.6.0.2.</span> <span class="nav-text">2. 类与对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-类描述的信息"><span class="nav-number">1.6.0.3.</span> <span class="nav-text">3. 类描述的信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-对象的使用方式"><span class="nav-number">1.6.0.4.</span> <span class="nav-text">4. 对象的使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-成员变量和局部变量区别"><span class="nav-number">1.6.0.5.</span> <span class="nav-text">5. 成员变量和局部变量区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-封装"><span class="nav-number">1.6.0.6.</span> <span class="nav-text">6. 封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-private关键字"><span class="nav-number">1.6.0.7.</span> <span class="nav-text">7. private关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-this关键字"><span class="nav-number">1.6.0.8.</span> <span class="nav-text">8. this关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-成员变量的默认值"><span class="nav-number">1.6.0.9.</span> <span class="nav-text">9. 成员变量的默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-构造方法注意事项"><span class="nav-number">1.6.0.10.</span> <span class="nav-text">10. 构造方法注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-标准代码——JavaBean"><span class="nav-number">1.6.0.11.</span> <span class="nav-text">11. 标准代码——JavaBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-对象的内存图流程"><span class="nav-number">1.6.0.12.</span> <span class="nav-text">12. 对象的内存图流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-07【Scanner类、Random类、ArrayList类】"><span class="nav-number">1.7.</span> <span class="nav-text">Day 07【Scanner类、Random类、ArrayList类】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-API的使用方式"><span class="nav-number">1.7.0.1.</span> <span class="nav-text">1. API的使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Scanner类使用步骤"><span class="nav-number">1.7.0.2.</span> <span class="nav-text">2. Scanner类使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Random类使用步骤"><span class="nav-number">1.7.0.3.</span> <span class="nav-text">3. Random类使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-匿名对象"><span class="nav-number">1.7.0.4.</span> <span class="nav-text">4. 匿名对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-数组与集合的不同"><span class="nav-number">1.7.0.5.</span> <span class="nav-text">5. 数组与集合的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ArrayList类"><span class="nav-number">1.7.0.6.</span> <span class="nav-text">6. ArrayList类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-ArrayList中的常用方法"><span class="nav-number">1.7.0.7.</span> <span class="nav-text">7. ArrayList中的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-包装类"><span class="nav-number">1.7.0.8.</span> <span class="nav-text">8. 包装类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-08【String类、static关键字、Arrays类、Math类】"><span class="nav-number">1.8.</span> <span class="nav-text">Day 08【String类、static关键字、Arrays类、Math类】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-String类的三个特点"><span class="nav-number">1.8.0.1.</span> <span class="nav-text">1. String类的三个特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建字符串的1-3种方法"><span class="nav-number">1.8.0.2.</span> <span class="nav-text">2. 创建字符串的1+3种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-String常用方法"><span class="nav-number">1.8.0.3.</span> <span class="nav-text">3.String常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#判断"><span class="nav-number">1.8.0.3.1.</span> <span class="nav-text">判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取"><span class="nav-number">1.8.0.3.2.</span> <span class="nav-text">获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#转换"><span class="nav-number">1.8.0.3.3.</span> <span class="nav-text">转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分割"><span class="nav-number">1.8.0.3.4.</span> <span class="nav-text">分割</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-正则表达式"><span class="nav-number">1.8.0.4.</span> <span class="nav-text">4. 正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-static关键字"><span class="nav-number">1.8.0.5.</span> <span class="nav-text">5. static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类变量"><span class="nav-number">1.8.0.5.1.</span> <span class="nav-text">类变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法"><span class="nav-number">1.8.0.5.2.</span> <span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态代码块"><span class="nav-number">1.8.0.5.3.</span> <span class="nav-text">静态代码块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Arrays类"><span class="nav-number">1.8.0.6.</span> <span class="nav-text">6. Arrays类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Math类"><span class="nav-number">1.8.0.7.</span> <span class="nav-text">7. Math类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-09【继承、super、this、抽象类】"><span class="nav-number">1.9.</span> <span class="nav-text">Day 09【继承、super、this、抽象类】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-继承"><span class="nav-number">1.9.0.1.</span> <span class="nav-text">1. 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-抽象类"><span class="nav-number">1.9.0.2.</span> <span class="nav-text">2. 抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-继承后的特点"><span class="nav-number">1.9.0.3.</span> <span class="nav-text">3. 继承后的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#成员变量重名"><span class="nav-number">1.9.0.3.1.</span> <span class="nav-text">成员变量重名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员方法重名——重写-Override"><span class="nav-number">1.9.0.3.2.</span> <span class="nav-text">成员方法重名——重写(Override)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法"><span class="nav-number">1.9.0.3.3.</span> <span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-super关键字的三种用法"><span class="nav-number">1.9.0.4.</span> <span class="nav-text">4. super关键字的三种用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-this关键字的三种用法"><span class="nav-number">1.9.0.5.</span> <span class="nav-text">5. this关键字的三种用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-10【接口、多态】"><span class="nav-number">1.10.</span> <span class="nav-text">Day 10【接口、多态】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-接口的定义"><span class="nav-number">1.10.0.1.</span> <span class="nav-text">1. 接口的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-接口包含的内容"><span class="nav-number">1.10.0.2.</span> <span class="nav-text">2. 接口包含的内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常量（Java-7）"><span class="nav-number">1.10.0.2.1.</span> <span class="nav-text">常量（Java 7）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#抽象方法（Java-7）"><span class="nav-number">1.10.0.2.2.</span> <span class="nav-text">抽象方法（Java 7）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认方法-Java-8"><span class="nav-number">1.10.0.2.3.</span> <span class="nav-text">默认方法(Java 8)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法-Java-8"><span class="nav-number">1.10.0.2.4.</span> <span class="nav-text">静态方法(Java 8)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#私有方法-Java-9"><span class="nav-number">1.10.0.2.5.</span> <span class="nav-text">私有方法(Java 9)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-接口的多实现"><span class="nav-number">1.10.0.3.</span> <span class="nav-text">3. 接口的多实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-接口的特点"><span class="nav-number">1.10.0.4.</span> <span class="nav-text">4. 接口的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-多态"><span class="nav-number">1.10.0.5.</span> <span class="nav-text">5. 多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-多态成员的访问"><span class="nav-number">1.10.0.6.</span> <span class="nav-text">6. 多态成员的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-多态的好处和弊端"><span class="nav-number">1.10.0.7.</span> <span class="nav-text">7. 多态的好处和弊端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-引用、对象、对象名称的区分"><span class="nav-number">1.10.0.8.</span> <span class="nav-text">8. 引用、对象、对象名称的区分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-向上转型和向下转型"><span class="nav-number">1.10.0.9.</span> <span class="nav-text">9. 向上转型和向下转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-instanceof-关键字"><span class="nav-number">1.10.0.10.</span> <span class="nav-text">10. instanceof 关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day-11【final、权限、内部类、引用类型】"><span class="nav-number">1.11.</span> <span class="nav-text">Day 11【final、权限、内部类、引用类型】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-final-关键字"><span class="nav-number">1.11.0.1.</span> <span class="nav-text">1. final 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰类"><span class="nav-number">1.11.0.1.1.</span> <span class="nav-text">修饰类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰方法"><span class="nav-number">1.11.0.1.2.</span> <span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰局部变量"><span class="nav-number">1.11.0.1.3.</span> <span class="nav-text">修饰局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰成员变量"><span class="nav-number">1.11.0.1.4.</span> <span class="nav-text">修饰成员变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-权限修饰符"><span class="nav-number">1.11.0.2.</span> <span class="nav-text">2. 权限修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-成员内部类"><span class="nav-number">1.11.0.3.</span> <span class="nav-text">3. 成员内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-类的权限修饰符"><span class="nav-number">1.11.0.4.</span> <span class="nav-text">4. 类的权限修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-局部内部类的final问题"><span class="nav-number">1.11.0.5.</span> <span class="nav-text">5. 局部内部类的final问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-匿名内部类"><span class="nav-number">1.11.0.6.</span> <span class="nav-text">6. 匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#就业班知识点总结"><span class="nav-number">2.</span> <span class="nav-text">就业班知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Day01【Object类、常用API】"><span class="nav-number">2.1.</span> <span class="nav-text">Day01【Object类、常用API】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Object类"><span class="nav-number">2.1.0.1.</span> <span class="nav-text">1. Object类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-toString方法"><span class="nav-number">2.1.0.2.</span> <span class="nav-text">2. toString方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-equals方法"><span class="nav-number">2.1.0.3.</span> <span class="nav-text">3. equals方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Objects类"><span class="nav-number">2.1.0.4.</span> <span class="nav-text">4. Objects类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Date类"><span class="nav-number">2.1.0.5.</span> <span class="nav-text">5. Date类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-DateFormat类"><span class="nav-number">2.1.0.6.</span> <span class="nav-text">6. DateFormat类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Calendar类"><span class="nav-number">2.1.0.7.</span> <span class="nav-text">7. Calendar类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-日期、字符串、毫秒值和日历的相互转换"><span class="nav-number">2.1.0.8.</span> <span class="nav-text">8. 日期、字符串、毫秒值和日历的相互转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-System类"><span class="nav-number">2.1.0.9.</span> <span class="nav-text">9. System类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-StringBuilder类"><span class="nav-number">2.1.0.10.</span> <span class="nav-text">10. StringBuilder类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-基本类型与字符串之间的转换"><span class="nav-number">2.1.0.11.</span> <span class="nav-text">11. 基本类型与字符串之间的转换</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day02【Collection、泛型】"><span class="nav-number">2.2.</span> <span class="nav-text">Day02【Collection、泛型】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Collection"><span class="nav-number">2.2.0.1.</span> <span class="nav-text">1. Collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-集合和数组的区别"><span class="nav-number">2.2.0.2.</span> <span class="nav-text">2. 集合和数组的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Collection-常用功能"><span class="nav-number">2.2.0.3.</span> <span class="nav-text">3. Collection 常用功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Iterator接口"><span class="nav-number">2.2.0.4.</span> <span class="nav-text">4.  Iterator接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-ListIterator接口"><span class="nav-number">2.2.0.5.</span> <span class="nav-text">5. ListIterator接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-增强for"><span class="nav-number">2.2.0.6.</span> <span class="nav-text">6. 增强for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-泛型"><span class="nav-number">2.2.0.7.</span> <span class="nav-text">7. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#含有泛型的类"><span class="nav-number">2.2.0.7.1.</span> <span class="nav-text">含有泛型的类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#含有泛型的方法"><span class="nav-number">2.2.0.7.2.</span> <span class="nav-text">含有泛型的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#含有泛型的接口"><span class="nav-number">2.2.0.7.3.</span> <span class="nav-text">含有泛型的接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-泛型通配符"><span class="nav-number">2.2.0.8.</span> <span class="nav-text">8. 泛型通配符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day03【List、Set、数据结构、Collections】"><span class="nav-number">2.3.</span> <span class="nav-text">Day03【List、Set、数据结构、Collections】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据结构"><span class="nav-number">2.3.0.1.</span> <span class="nav-text">1. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#栈"><span class="nav-number">2.3.0.1.1.</span> <span class="nav-text">栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#队列"><span class="nav-number">2.3.0.1.2.</span> <span class="nav-text">队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-number">2.3.0.1.3.</span> <span class="nav-text">数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链表"><span class="nav-number">2.3.0.1.4.</span> <span class="nav-text">链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#红黑树"><span class="nav-number">2.3.0.1.5.</span> <span class="nav-text">红黑树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-List-接口"><span class="nav-number">2.3.0.2.</span> <span class="nav-text">2. List 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-LinkedList-集合"><span class="nav-number">2.3.0.3.</span> <span class="nav-text">3. LinkedList 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-HashSet-集合"><span class="nav-number">2.3.0.4.</span> <span class="nav-text">4. HashSet 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-LinkedHashSet-集合"><span class="nav-number">2.3.0.5.</span> <span class="nav-text">5. LinkedHashSet 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-重写HashCode-方法"><span class="nav-number">2.3.0.6.</span> <span class="nav-text">6. 重写HashCode()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-可变参数"><span class="nav-number">2.3.0.7.</span> <span class="nav-text">7. 可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Collections-工具类"><span class="nav-number">2.3.0.8.</span> <span class="nav-text">8. Collections 工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-Comparable-Comparator-接口"><span class="nav-number">2.3.0.9.</span> <span class="nav-text">9. Comparable/Comparator 接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day04【Map、Debug】"><span class="nav-number">2.4.</span> <span class="nav-text">Day04【Map、Debug】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Map接口"><span class="nav-number">2.4.0.1.</span> <span class="nav-text">1. Map接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Map的常用子类"><span class="nav-number">2.4.0.2.</span> <span class="nav-text">2. Map的常用子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Map的常用方法"><span class="nav-number">2.4.0.3.</span> <span class="nav-text">3. Map的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Entry键值对对象"><span class="nav-number">2.4.0.4.</span> <span class="nav-text">4. Entry键值对对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Map的两种遍历方式"><span class="nav-number">2.4.0.5.</span> <span class="nav-text">5. Map的两种遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-JDK9对集合添加的优化"><span class="nav-number">2.4.0.6.</span> <span class="nav-text">6. JDK9对集合添加的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Debug追踪"><span class="nav-number">2.4.0.7.</span> <span class="nav-text">7. Debug追踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day05【异常、线程】"><span class="nav-number">2.5.</span> <span class="nav-text">Day05【异常、线程】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-异常"><span class="nav-number">2.5.0.1.</span> <span class="nav-text">1. 异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Throwable体系"><span class="nav-number">2.5.0.2.</span> <span class="nav-text">2. Throwable体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-异常的分类"><span class="nav-number">2.5.0.3.</span> <span class="nav-text">3. 异常的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-异常产生过程解析"><span class="nav-number">2.5.0.4.</span> <span class="nav-text">4. 异常产生过程解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-throw关键字"><span class="nav-number">2.5.0.5.</span> <span class="nav-text">5. throw关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Objects非空判断"><span class="nav-number">2.5.0.6.</span> <span class="nav-text">6. Objects非空判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-throws声明异常"><span class="nav-number">2.5.0.7.</span> <span class="nav-text">7. throws声明异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-try…catch捕获异常"><span class="nav-number">2.5.0.8.</span> <span class="nav-text">8. try…catch捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-finally代码块"><span class="nav-number">2.5.0.9.</span> <span class="nav-text">9. finally代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-多个异常使用捕获"><span class="nav-number">2.5.0.10.</span> <span class="nav-text">10. 多个异常使用捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-自定义异常"><span class="nav-number">2.5.0.11.</span> <span class="nav-text">11. 自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-并发与并行"><span class="nav-number">2.5.0.12.</span> <span class="nav-text">12. 并发与并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-线程与进程"><span class="nav-number">2.5.0.13.</span> <span class="nav-text">13. 线程与进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day06【线程、同步】"><span class="nav-number">2.6.</span> <span class="nav-text">Day06【线程、同步】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Thread类"><span class="nav-number">2.6.0.1.</span> <span class="nav-text">1. Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建线程-继承Thread类"><span class="nav-number">2.6.0.2.</span> <span class="nav-text">2. 创建线程-继承Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-创建线程-Runnable接口"><span class="nav-number">2.6.0.3.</span> <span class="nav-text">3. 创建线程-Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Runnable接口具有的优势"><span class="nav-number">2.6.0.4.</span> <span class="nav-text">4. Runnable接口具有的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-线程安全"><span class="nav-number">2.6.0.5.</span> <span class="nav-text">5. 线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-同步代码块"><span class="nav-number">2.6.0.6.</span> <span class="nav-text">6. 同步代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-同步方法"><span class="nav-number">2.6.0.7.</span> <span class="nav-text">7. 同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Lock锁"><span class="nav-number">2.6.0.8.</span> <span class="nav-text">8. Lock锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-六种线程状态"><span class="nav-number">2.6.0.9.</span> <span class="nav-text">9. 六种线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-等待与唤醒方法"><span class="nav-number">2.6.0.10.</span> <span class="nav-text">10. 等待与唤醒方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day07【线程池、Lambda表达式】"><span class="nav-number">2.7.</span> <span class="nav-text">Day07【线程池、Lambda表达式】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-等待唤醒机制"><span class="nav-number">2.7.0.1.</span> <span class="nav-text">1. 等待唤醒机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-线程池"><span class="nav-number">2.7.0.2.</span> <span class="nav-text">2. 线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Lambda表达式"><span class="nav-number">2.7.0.3.</span> <span class="nav-text">3. Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day08【File类、递归】"><span class="nav-number">2.8.</span> <span class="nav-text">Day08【File类、递归】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-File类"><span class="nav-number">2.8.0.1.</span> <span class="nav-text">1. File类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法-1"><span class="nav-number">2.8.0.1.1.</span> <span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取的方法"><span class="nav-number">2.8.0.1.2.</span> <span class="nav-text">获取的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#判断的方法"><span class="nav-number">2.8.0.1.3.</span> <span class="nav-text">判断的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建删除的方法"><span class="nav-number">2.8.0.1.4.</span> <span class="nav-text">创建删除的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历的方法"><span class="nav-number">2.8.0.1.5.</span> <span class="nav-text">遍历的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-绝对路径和相对路径"><span class="nav-number">2.8.0.2.</span> <span class="nav-text">2. 绝对路径和相对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-递归"><span class="nav-number">2.8.0.3.</span> <span class="nav-text">3. 递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-文件过滤器"><span class="nav-number">2.8.0.4.</span> <span class="nav-text">4. 文件过滤器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day09【字节流、字符流】"><span class="nav-number">2.9.</span> <span class="nav-text">Day09【字节流、字符流】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-IO流"><span class="nav-number">2.9.0.1.</span> <span class="nav-text">1. IO流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字节输出流【OutputStream】"><span class="nav-number">2.9.0.2.</span> <span class="nav-text">2. 字节输出流【OutputStream】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream"><span class="nav-number">2.9.0.2.1.</span> <span class="nav-text">FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-字节输入流【InputStream】"><span class="nav-number">2.9.0.3.</span> <span class="nav-text">3. 字节输入流【InputStream】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream"><span class="nav-number">2.9.0.3.1.</span> <span class="nav-text">FileInputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-字符输入流【Reader】"><span class="nav-number">2.9.0.4.</span> <span class="nav-text">4. 字符输入流【Reader】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReader"><span class="nav-number">2.9.0.4.1.</span> <span class="nav-text">FileReader</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-字符输出流【Writer】"><span class="nav-number">2.9.0.5.</span> <span class="nav-text">5. 字符输出流【Writer】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter"><span class="nav-number">2.9.0.5.1.</span> <span class="nav-text">FileWriter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-IO异常的处理"><span class="nav-number">2.9.0.6.</span> <span class="nav-text">6. IO异常的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK7前处理"><span class="nav-number">2.9.0.6.1.</span> <span class="nav-text">JDK7前处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK7的处理"><span class="nav-number">2.9.0.6.2.</span> <span class="nav-text">JDK7的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK9的改进"><span class="nav-number">2.9.0.6.3.</span> <span class="nav-text">JDK9的改进</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Properties类"><span class="nav-number">2.9.0.7.</span> <span class="nav-text">7. Properties类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day10【缓冲流、转换流、序列化流】"><span class="nav-number">2.10.</span> <span class="nav-text">Day10【缓冲流、转换流、序列化流】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-缓冲流"><span class="nav-number">2.10.0.1.</span> <span class="nav-text">1. 缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字节缓冲流"><span class="nav-number">2.10.0.1.1.</span> <span class="nav-text">字节缓冲流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符缓冲流"><span class="nav-number">2.10.0.1.2.</span> <span class="nav-text">字符缓冲流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字符集"><span class="nav-number">2.10.0.2.</span> <span class="nav-text">2. 字符集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-转换流"><span class="nav-number">2.10.0.3.</span> <span class="nav-text">3. 转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InputStreamReader类"><span class="nav-number">2.10.0.3.1.</span> <span class="nav-text">InputStreamReader类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OutputStreamWriter类"><span class="nav-number">2.10.0.3.2.</span> <span class="nav-text">OutputStreamWriter类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-序列化"><span class="nav-number">2.10.0.4.</span> <span class="nav-text">4. 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectOutputStream类"><span class="nav-number">2.10.0.4.1.</span> <span class="nav-text">ObjectOutputStream类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectInputStream类"><span class="nav-number">2.10.0.4.2.</span> <span class="nav-text">ObjectInputStream类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-打印流"><span class="nav-number">2.10.0.5.</span> <span class="nav-text">5. 打印流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PrintStream类"><span class="nav-number">2.10.0.5.1.</span> <span class="nav-text">PrintStream类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day11【网络编程】"><span class="nav-number">2.11.</span> <span class="nav-text">Day11【网络编程】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-软件结构"><span class="nav-number">2.11.0.1.</span> <span class="nav-text">1. 软件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-网络通信协议"><span class="nav-number">2.11.0.2.</span> <span class="nav-text">2. 网络通信协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-TCP协议"><span class="nav-number">2.11.0.3.</span> <span class="nav-text">3. TCP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-UDP协议"><span class="nav-number">2.11.0.4.</span> <span class="nav-text">4. UDP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-IP地址"><span class="nav-number">2.11.0.5.</span> <span class="nav-text">5. IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-端口号"><span class="nav-number">2.11.0.6.</span> <span class="nav-text">6. 端口号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Socket类"><span class="nav-number">2.11.0.7.</span> <span class="nav-text">7. Socket类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-ServerSocket类"><span class="nav-number">2.11.0.8.</span> <span class="nav-text">8. ServerSocket类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-文件上传优化分析"><span class="nav-number">2.11.0.9.</span> <span class="nav-text">9. 文件上传优化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①-文件名称写死的问题"><span class="nav-number">2.11.0.9.1.</span> <span class="nav-text">① 文件名称写死的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#②-循环接收的问题"><span class="nav-number">2.11.0.9.2.</span> <span class="nav-text">② 循环接收的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#③-效率问题"><span class="nav-number">2.11.0.9.3.</span> <span class="nav-text">③ 效率问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day12【函数式接口】"><span class="nav-number">2.12.</span> <span class="nav-text">Day12【函数式接口】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-函数式接口"><span class="nav-number">2.12.0.1.</span> <span class="nav-text">1. 函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Lambda的延迟执行"><span class="nav-number">2.12.0.2.</span> <span class="nav-text">2. Lambda的延迟执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Supplier接口"><span class="nav-number">2.12.0.3.</span> <span class="nav-text">3. Supplier接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Consumer接口"><span class="nav-number">2.12.0.4.</span> <span class="nav-text">4. Consumer接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Predicate接口"><span class="nav-number">2.12.0.5.</span> <span class="nav-text">5. Predicate接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Function接口"><span class="nav-number">2.12.0.6.</span> <span class="nav-text">6. Function接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day13【Stream流、方法引用】"><span class="nav-number">2.13.</span> <span class="nav-text">Day13【Stream流、方法引用】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-流式思想"><span class="nav-number">2.13.0.1.</span> <span class="nav-text">1. 流式思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-获取流"><span class="nav-number">2.13.0.2.</span> <span class="nav-text">2. 获取流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-常用方法"><span class="nav-number">2.13.0.3.</span> <span class="nav-text">3. 常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forEach：逐一处理"><span class="nav-number">2.13.0.3.1.</span> <span class="nav-text">forEach：逐一处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#filter：过滤"><span class="nav-number">2.13.0.3.2.</span> <span class="nav-text">filter：过滤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map：映射"><span class="nav-number">2.13.0.3.3.</span> <span class="nav-text">map：映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#count：统计个数"><span class="nav-number">2.13.0.3.4.</span> <span class="nav-text">count：统计个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#limit：取用前几个"><span class="nav-number">2.13.0.3.5.</span> <span class="nav-text">limit：取用前几个</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#skip：跳过前几个"><span class="nav-number">2.13.0.3.6.</span> <span class="nav-text">skip：跳过前几个</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#concat：组合"><span class="nav-number">2.13.0.3.7.</span> <span class="nav-text">concat：组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#collect：将流元素生成集合"><span class="nav-number">2.13.0.3.8.</span> <span class="nav-text">collect：将流元素生成集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toArray：将流元素生成数组"><span class="nav-number">2.13.0.3.9.</span> <span class="nav-text">toArray：将流元素生成数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-方法引用"><span class="nav-number">2.13.0.4.</span> <span class="nav-text">4. 方法引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Day14【单元测试、反射、注解】"><span class="nav-number">2.14.</span> <span class="nav-text">Day14【单元测试、反射、注解】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-单元测试"><span class="nav-number">2.14.0.1.</span> <span class="nav-text">1. 单元测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-反射"><span class="nav-number">2.14.0.2.</span> <span class="nav-text">2. 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获取Class对象"><span class="nav-number">2.14.0.2.1.</span> <span class="nav-text">获取Class对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作成员变量对象"><span class="nav-number">2.14.0.2.2.</span> <span class="nav-text">操作成员变量对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作构造方法对象"><span class="nav-number">2.14.0.2.3.</span> <span class="nav-text">操作构造方法对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作成员方法对象"><span class="nav-number">2.14.0.2.4.</span> <span class="nav-text">操作成员方法对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-“框架”案例"><span class="nav-number">2.14.0.3.</span> <span class="nav-text">3. “框架”案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-注解"><span class="nav-number">2.14.0.4.</span> <span class="nav-text">4. 注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-自定义注解"><span class="nav-number">2.14.0.5.</span> <span class="nav-text">5. 自定义注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-元注解"><span class="nav-number">2.14.0.6.</span> <span class="nav-text">6. 元注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-”测试框架“案例"><span class="nav-number">2.14.0.7.</span> <span class="nav-text">7. ”测试框架“案例</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#数据库知识点总结"><span class="nav-number">3.</span> <span class="nav-text">数据库知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-数据库的基本概念"><span class="nav-number">3.0.1.</span> <span class="nav-text">1. 数据库的基本概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-MySQL配置操作"><span class="nav-number">3.0.2.</span> <span class="nav-text">2. MySQL配置操作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-SQL概念"><span class="nav-number">3.0.3.</span> <span class="nav-text">3. SQL概念</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-DDL-定义数据库"><span class="nav-number">3.0.4.</span> <span class="nav-text">4. DDL 定义数据库</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#操作数据库"><span class="nav-number">3.0.4.1.</span> <span class="nav-text">操作数据库</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#操作表"><span class="nav-number">3.0.4.2.</span> <span class="nav-text">操作表</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-DML-增删改表中数据"><span class="nav-number">3.0.5.</span> <span class="nav-text">5. DML 增删改表中数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-DQL-查询表中记录"><span class="nav-number">3.0.6.</span> <span class="nav-text">6. DQL 查询表中记录</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#基础查询"><span class="nav-number">3.0.6.1.</span> <span class="nav-text">基础查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#条件查询"><span class="nav-number">3.0.6.2.</span> <span class="nav-text">条件查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#排序查询"><span class="nav-number">3.0.6.3.</span> <span class="nav-text">排序查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#聚合函数"><span class="nav-number">3.0.6.4.</span> <span class="nav-text">聚合函数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分组查询"><span class="nav-number">3.0.6.5.</span> <span class="nav-text">分组查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#分页查询"><span class="nav-number">3.0.6.6.</span> <span class="nav-text">分页查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-约束"><span class="nav-number">3.0.7.</span> <span class="nav-text">7. 约束</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#非空约束"><span class="nav-number">3.0.7.1.</span> <span class="nav-text">非空约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#唯一约束"><span class="nav-number">3.0.7.2.</span> <span class="nav-text">唯一约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#主键约束"><span class="nav-number">3.0.7.3.</span> <span class="nav-text">主键约束</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外键约束"><span class="nav-number">3.0.7.4.</span> <span class="nav-text">外键约束</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-数据库的设计"><span class="nav-number">3.0.8.</span> <span class="nav-text">8. 数据库的设计</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-数据库设计范式"><span class="nav-number">3.0.9.</span> <span class="nav-text">9. 数据库设计范式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-数据库的备份和还原"><span class="nav-number">3.0.10.</span> <span class="nav-text">10. 数据库的备份和还原</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-多表查询"><span class="nav-number">3.0.11.</span> <span class="nav-text">11. 多表查询</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#隐式内连接"><span class="nav-number">3.0.11.1.</span> <span class="nav-text">隐式内连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#显式内连接"><span class="nav-number">3.0.11.2.</span> <span class="nav-text">显式内连接</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#外链接查询"><span class="nav-number">3.0.11.3.</span> <span class="nav-text">外链接查询</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#子查询"><span class="nav-number">3.0.11.4.</span> <span class="nav-text">子查询</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-事务"><span class="nav-number">3.0.12.</span> <span class="nav-text">12. 事务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#四大特征ACID"><span class="nav-number">3.0.12.1.</span> <span class="nav-text">四大特征ACID</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#隔离级别"><span class="nav-number">3.0.12.2.</span> <span class="nav-text">隔离级别</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-DCL-控制用户权限"><span class="nav-number">3.0.13.</span> <span class="nav-text">13. DCL 控制用户权限</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#用户管理"><span class="nav-number">3.0.13.1.</span> <span class="nav-text">用户管理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#权限管理"><span class="nav-number">3.0.13.2.</span> <span class="nav-text">权限管理</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-JDBC"><span class="nav-number">3.0.14.</span> <span class="nav-text">14. JDBC</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Connection-数据库连接对象"><span class="nav-number">3.0.14.1.</span> <span class="nav-text">Connection 数据库连接对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Statement-执行sql的对象"><span class="nav-number">3.0.14.2.</span> <span class="nav-text">Statement 执行sql的对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ResultSet-结果集对象"><span class="nav-number">3.0.14.3.</span> <span class="nav-text">ResultSet 结果集对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#15-JDBCUtils-抽取JDBC工具类"><span class="nav-number">3.0.15.</span> <span class="nav-text">15. JDBCUtils 抽取JDBC工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#16-用户登录案例与sql注入问题"><span class="nav-number">3.0.16.</span> <span class="nav-text">16. 用户登录案例与sql注入问题</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#17-JDBC事务控制"><span class="nav-number">3.0.17.</span> <span class="nav-text">17. JDBC事务控制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#18-数据库连接池"><span class="nav-number">3.0.18.</span> <span class="nav-text">18. 数据库连接池</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#C3P0-数据库连接池技术"><span class="nav-number">3.0.18.1.</span> <span class="nav-text">C3P0 数据库连接池技术</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Druid-数据库连接池技术"><span class="nav-number">3.0.18.2.</span> <span class="nav-text">Druid 数据库连接池技术</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#19-Spring-JDBC"><span class="nav-number">3.0.19.</span> <span class="nav-text">19. Spring JDBC</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web前端知识点总结"><span class="nav-number">4.</span> <span class="nav-text">Web前端知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-B-S架构资源"><span class="nav-number">4.0.1.</span> <span class="nav-text">1. B/S架构资源</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-HTML"><span class="nav-number">4.0.2.</span> <span class="nav-text">2. HTML</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-表格标签"><span class="nav-number">4.0.3.</span> <span class="nav-text">3. 表格标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-表单标签"><span class="nav-number">4.0.4.</span> <span class="nav-text">4. 表单标签</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-CCS"><span class="nav-number">4.0.5.</span> <span class="nav-text">5. CCS</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-CCS选择器"><span class="nav-number">4.0.6.</span> <span class="nav-text">6. CCS选择器</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-CCS属性"><span class="nav-number">4.0.7.</span> <span class="nav-text">7. CCS属性</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-JavaScript基本语法"><span class="nav-number">4.0.8.</span> <span class="nav-text">8. JavaScript基本语法</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结合html"><span class="nav-number">4.0.8.1.</span> <span class="nav-text">结合html</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#数据类型"><span class="nav-number">4.0.8.2.</span> <span class="nav-text">数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#变量"><span class="nav-number">4.0.8.3.</span> <span class="nav-text">变量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#运算符"><span class="nav-number">4.0.8.4.</span> <span class="nav-text">运算符</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-JavaScript基本对象"><span class="nav-number">4.0.9.</span> <span class="nav-text">9. JavaScript基本对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Function-函数对象"><span class="nav-number">4.0.9.1.</span> <span class="nav-text">Function:函数对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Array-数组对象"><span class="nav-number">4.0.9.2.</span> <span class="nav-text">Array:数组对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Date-日期对象"><span class="nav-number">4.0.9.3.</span> <span class="nav-text">Date:日期对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#RegExp-正则表达式对象"><span class="nav-number">4.0.9.4.</span> <span class="nav-text">RegExp:正则表达式对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Global-全局对象"><span class="nav-number">4.0.9.5.</span> <span class="nav-text">Global:全局对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-BOM"><span class="nav-number">4.0.10.</span> <span class="nav-text">10. BOM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Window-窗口对象"><span class="nav-number">4.0.10.1.</span> <span class="nav-text">Window:窗口对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Location-地址栏对象"><span class="nav-number">4.0.10.2.</span> <span class="nav-text">Location:地址栏对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#History-历史记录对象"><span class="nav-number">4.0.10.3.</span> <span class="nav-text">History:历史记录对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Navigator-浏览器对象"><span class="nav-number">4.0.10.4.</span> <span class="nav-text">Navigator:浏览器对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Screen-显示器屏幕对象"><span class="nav-number">4.0.10.5.</span> <span class="nav-text">Screen:显示器屏幕对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-DOM"><span class="nav-number">4.0.11.</span> <span class="nav-text">11. DOM</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Document-文档对象"><span class="nav-number">4.0.11.1.</span> <span class="nav-text">Document:文档对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Element-元素对象"><span class="nav-number">4.0.11.2.</span> <span class="nav-text">Element:元素对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Node-节点对象"><span class="nav-number">4.0.11.3.</span> <span class="nav-text">Node:节点对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Attribute-属性对象"><span class="nav-number">4.0.11.4.</span> <span class="nav-text">Attribute:属性对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Text-文本对象"><span class="nav-number">4.0.11.5.</span> <span class="nav-text">Text:文本对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Comment-注释对象"><span class="nav-number">4.0.11.6.</span> <span class="nav-text">Comment:注释对象</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-事件监听机制"><span class="nav-number">4.0.12.</span> <span class="nav-text">12. 事件监听机制</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-综合案例"><span class="nav-number">4.0.13.</span> <span class="nav-text">13. 综合案例</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#动态表格"><span class="nav-number">4.0.13.1.</span> <span class="nav-text">动态表格</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#表单校验"><span class="nav-number">4.0.13.2.</span> <span class="nav-text">表单校验</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-Bootstrap"><span class="nav-number">4.0.14.</span> <span class="nav-text">14. Bootstrap</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#响应式布局"><span class="nav-number">4.0.14.1.</span> <span class="nav-text">响应式布局</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Web核心知识点总结"><span class="nav-number">5.</span> <span class="nav-text">Web核心知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-XML概述"><span class="nav-number">5.0.1.</span> <span class="nav-text">1. XML概述</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-XML约束"><span class="nav-number">5.0.2.</span> <span class="nav-text">2. XML约束</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-XML解析"><span class="nav-number">5.0.3.</span> <span class="nav-text">3. XML解析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Jsoup解析器"><span class="nav-number">5.0.3.1.</span> <span class="nav-text">Jsoup解析器</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Xpath路径语言"><span class="nav-number">5.0.3.2.</span> <span class="nav-text">Xpath路径语言</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-web服务器软件"><span class="nav-number">5.0.4.</span> <span class="nav-text">4. web服务器软件</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#Tomcat介绍"><span class="nav-number">5.0.4.1.</span> <span class="nav-text">Tomcat介绍</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-Servlet接口"><span class="nav-number">5.0.5.</span> <span class="nav-text">5. Servlet接口</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#访问原理"><span class="nav-number">5.0.5.1.</span> <span class="nav-text">访问原理</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#使用步骤"><span class="nav-number">5.0.5.2.</span> <span class="nav-text">使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部方法"><span class="nav-number">5.0.5.3.</span> <span class="nav-text">内部方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#体系结构"><span class="nav-number">5.0.5.4.</span> <span class="nav-text">体系结构</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#6-HTTP协议"><span class="nav-number">5.0.6.</span> <span class="nav-text">6. HTTP协议</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#7-请求消息数据格式"><span class="nav-number">5.0.7.</span> <span class="nav-text">7. 请求消息数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#8-Request对象"><span class="nav-number">5.0.8.</span> <span class="nav-text">8. Request对象</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#获取请求消息数据的方法"><span class="nav-number">5.0.8.1.</span> <span class="nav-text">获取请求消息数据的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取请求头数据的方法"><span class="nav-number">5.0.8.2.</span> <span class="nav-text">获取请求头数据的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取请求体数据的方法"><span class="nav-number">5.0.8.3.</span> <span class="nav-text">获取请求体数据的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#获取请求参数通用方式"><span class="nav-number">5.0.8.4.</span> <span class="nav-text">获取请求参数通用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#请求转发的方法"><span class="nav-number">5.0.8.5.</span> <span class="nav-text">请求转发的方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#共享数据的方法"><span class="nav-number">5.0.8.6.</span> <span class="nav-text">共享数据的方法</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#9-BeanUtils工具类"><span class="nav-number">5.0.9.</span> <span class="nav-text">9. BeanUtils工具类</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#10-响应消息数据格式"><span class="nav-number">5.0.10.</span> <span class="nav-text">10. 响应消息数据格式</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#11-Response对象"><span class="nav-number">5.0.11.</span> <span class="nav-text">11. Response对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#12-重定向"><span class="nav-number">5.0.12.</span> <span class="nav-text">12. 重定向</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#13-ServletContext对象"><span class="nav-number">5.0.13.</span> <span class="nav-text">13. ServletContext对象</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#14-案例：文件下载"><span class="nav-number">5.0.14.</span> <span class="nav-text">14. 案例：文件下载</span></a></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">John Doe</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
