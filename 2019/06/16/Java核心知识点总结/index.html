<!DOCTYPE html>












  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.7.0">

<link rel="stylesheet" href="/css/main.css?v=7.1.2">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=7.1.2">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.1.2">


  <link rel="mask-icon" href="/images/logo.svg?v=7.1.2" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '7.1.2',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="Java核心知识点总结【入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商  2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加  3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单位是1024">
<meta property="og:type" content="article">
<meta property="og:title" content="java核心">
<meta property="og:url" content="http://yoursite.com/2019/06/16/Java核心知识点总结/index.html">
<meta property="og:site_name" content="Space">
<meta property="og:description" content="Java核心知识点总结【入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商  2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加  3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单位是1024">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2019-06-16T07:37:12.708Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="java核心">
<meta name="twitter:description" content="Java核心知识点总结【入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商  2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加  3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单位是1024">





  
  
  <link rel="canonical" href="http://yoursite.com/2019/06/16/Java核心知识点总结/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>java核心 | Space</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Space</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="Navigationsleiste an/ausschalten">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-document">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-tasks"></i> <br>文档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-javacore">

    
    
    
      
    

    

    <a href="/2019/06/16/Java%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="section"><i class="menu-item-icon fa fa-fw fa-coffee"></i> <br>Java核心</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-database">

    
    
    
      
    

    

    <a href="/2019/06/16/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="section"><i class="menu-item-icon fa fa-fw fa-database"></i> <br>数据库</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-html">

    
    
    
      
    

    

    <a href="/2019/06/16/Web%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="section"><i class="menu-item-icon fa fa-fw fa-globe"></i> <br>Web前端</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-webcore">

    
    
    
      
    

    

    <a href="/2019/06/16/Web%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="section"><i class="menu-item-icon fa fa-fw fa-cube"></i> <br>Web核心</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-ssmframwork">

    
    
    
      
    

    

    <a href="/2019/06/16/%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" rel="section"><i class="menu-item-icon fa fa-fw fa-leaf"></i> <br>SSM框架</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>Suche</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="Suche..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/16/Java核心知识点总结/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Eric">
      <meta itemprop="description" content="Eric's Knowledge Base">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Space">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">java核心

              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              

              
                
              

              <time title="Erstellt: 2019-06-16 15:29:54 / Geändert am: 15:37:12" itemprop="dateCreated datePublished" datetime="2019-06-16T15:29:54+08:00">2019-06-16</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="Java核心知识点总结"><a href="#Java核心知识点总结" class="headerlink" title="Java核心知识点总结"></a>Java核心知识点总结</h1><h2 id="【入门程序、常量、变量】"><a href="#【入门程序、常量、变量】" class="headerlink" title="【入门程序、常量、变量】"></a>【入门程序、常量、变量】</h2><h4 id="1-Java语言用途"><a href="#1-Java语言用途" class="headerlink" title="1. Java语言用途"></a>1. Java语言用途</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">开发网站的后台业务逻辑，例如：传统行业和电商</span><br></pre></td></tr></table></figure>

<h4 id="2-十进制和二进制的转换规则"><a href="#2-十进制和二进制的转换规则" class="headerlink" title="2. 十进制和二进制的转换规则"></a>2. 十进制和二进制的转换规则</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制</span><br><span class="line"></span><br><span class="line">二进制转十进制：位权乘以二进制数，再相加</span><br></pre></td></tr></table></figure>

<h4 id="3-计算机存储单元"><a href="#3-计算机存储单元" class="headerlink" title="3.计算机存储单元"></a>3.计算机存储单元</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s</span><br><span class="line"></span><br><span class="line">进制单位是1024</span><br></pre></td></tr></table></figure>

<h4 id="4-Java的跨平台性？"><a href="#4-Java的跨平台性？" class="headerlink" title="4. Java的跨平台性？"></a>4. Java的跨平台性？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为Java运行在虚拟机上，不同的系统对应不同版本的虚拟机（JVM）</span><br></pre></td></tr></table></figure>

<h4 id="5-JDK、JRE和JVM"><a href="#5-JDK、JRE和JVM" class="headerlink" title="5. JDK、JRE和JVM"></a>5. JDK、JRE和JVM</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">JDK：是开发工具包，能进行开发，运行环境</span><br><span class="line"></span><br><span class="line">JRE：是java的运行环境</span><br><span class="line"></span><br><span class="line">JVM：是java的核心，虚拟机</span><br><span class="line"></span><br><span class="line">包含关系: jdk --&gt; jre --&gt; jvm</span><br></pre></td></tr></table></figure>

<h4 id="6-环境变量配置的意义"><a href="#6-环境变量配置的意义" class="headerlink" title="6. 环境变量配置的意义"></a>6. 环境变量配置的意义</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">配置环境变量的意义是让操作系统知道去哪里找java命令，使计算机能够在任意目录下运行java和javac这两个命令</span><br></pre></td></tr></table></figure>

<h4 id="7-Java程序编写的三个步骤"><a href="#7-Java程序编写的三个步骤" class="headerlink" title="7. Java程序编写的三个步骤"></a>7. Java程序编写的三个步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">编写：程序员编写代码</span><br><span class="line"></span><br><span class="line">编译：将我们编写的代码编程计算机能识别的代码</span><br><span class="line"></span><br><span class="line">运行：运行字节码文件，.class文件，显示效果</span><br></pre></td></tr></table></figure>

<h4 id="8-常用命令提示符"><a href="#8-常用命令提示符" class="headerlink" title="8. 常用命令提示符"></a>8. 常用命令提示符</h4><table>
<thead>
<tr>
<th>功能</th>
<th>输入</th>
</tr>
</thead>
<tbody><tr>
<td>切换盘符</td>
<td>盘符名称：</td>
</tr>
<tr>
<td>进入文件夹</td>
<td>cd  文件夹1\文件夹2\文件夹3</td>
</tr>
<tr>
<td>返回上一级</td>
<td>cd ..</td>
</tr>
<tr>
<td>直接回根路径</td>
<td>cd \</td>
</tr>
<tr>
<td>查看当前文件夹内容</td>
<td>dir</td>
</tr>
<tr>
<td>清屏</td>
<td>cls</td>
</tr>
<tr>
<td>退出</td>
<td>exit</td>
</tr>
</tbody></table>
<h4 id="9-注释及其格式"><a href="#9-注释及其格式" class="headerlink" title="9. 注释及其格式"></a>9. 注释及其格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">注释是对代码进行解释说明的文字，提高代码的可读性</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>java中的注释分三种：</strong></p>
<ul>
<li>单行注释:        // 文字</li>
<li>多行注释:        /*  文字 */</li>
<li>文档注释:        /** 文字 */</li>
</ul>
</blockquote>
<h4 id="10-关键字"><a href="#10-关键字" class="headerlink" title="10. 关键字"></a>10. 关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">关键字：被java语言赋予了特殊的含义的单词，Java一共定义了50个关键字。</span><br><span class="line"></span><br><span class="line">特点：（1）全部小写；（2）在不同的编辑器下关键字的颜色是不一样的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>目前已学的关键字可分为4类：（更新至Day05课程）</p>
<p><strong>定义数据类型</strong>：class  byte  short  int  long  float  double  char  boolean  void</p>
<p><strong>定义数据值类型</strong>：true  false  null</p>
<p><strong>定义流程控制</strong>：if  else  switch  case  default  while  do  for  break  continue  return</p>
<p><strong>其他类型</strong>：public  static  new  package  import </p>
</blockquote>
<h4 id="11-标识符及其定义规范"><a href="#11-标识符及其定义规范" class="headerlink" title="11. 标识符及其定义规范"></a>11. 标识符及其定义规范</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">标识符：自己定义的单词</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>硬性要求：</strong></p>
<ol>
<li>标识符包含英文26字母（大小写）、数字0-9、$、_</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
</ol>
</blockquote>
<blockquote>
<p><strong>软性建议：</strong></p>
<ol>
<li>类名：大驼峰（单词的首字母全部大写）</li>
<li>变量名：小驼峰（如果有多个单词，那么第一个单词首字母小写，后面单词首字母大写）</li>
<li>方法名：小驼峰</li>
</ol>
</blockquote>
<h4 id="12-数据类型"><a href="#12-数据类型" class="headerlink" title="12. 数据类型"></a>12. 数据类型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java是强类型语言, 对于每一种数据类型都规定了明确的取值范围。</span><br><span class="line"></span><br><span class="line">数据类型分为两种：基本数据类型（四类八种）、引用数据类型（目前有String和数组）</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">四类</th>
<th align="center">八种</th>
<th align="center">字节数</th>
<th align="center">表示范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">整型</td>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128~127</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">正负3万多</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">*<em>int *</em></td>
<td align="center">4</td>
<td align="center">正负21亿多</td>
</tr>
<tr>
<td align="center">整型</td>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">正负19位数</td>
</tr>
<tr>
<td align="center">布尔型</td>
<td align="center">boolean</td>
<td align="center">1</td>
<td align="center">true, false</td>
</tr>
<tr>
<td align="center">字符型</td>
<td align="center">char</td>
<td align="center">2</td>
<td align="center">一个字符’A’，’a’</td>
</tr>
<tr>
<td align="center">浮点型</td>
<td align="center">float</td>
<td align="center">4</td>
<td align="center">正负38位数</td>
</tr>
<tr>
<td align="center">浮点型</td>
<td align="center"><strong>double</strong></td>
<td align="center">8</td>
<td align="center">正负308位数</td>
</tr>
</tbody></table>
<h4 id="13-常量及其分类"><a href="#13-常量及其分类" class="headerlink" title="13. 常量及其分类"></a>13. 常量及其分类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">常量：在程序的执行过程中, 其值不可以发生改变的量</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>整数常量：所有整数</li>
<li>浮点数常量：所有小数</li>
<li>字符常量：被单引号括起来的内容, 里面只能装单个字</li>
<li>字符串常量：被双引号括起来的内容</li>
<li>布尔常量：true、false</li>
<li>空常量：null</li>
</ol>
</blockquote>
<h4 id="14-变量及其定义格式"><a href="#14-变量及其定义格式" class="headerlink" title="14. 变量及其定义格式"></a>14. 变量及其定义格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">变量：在程序的执行过程中, 其值在某个范围内可以发生改变的量。变量就像一个容器，可以不断修改其中的内容。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>三种定义格式：</strong></p>
<ol>
<li>一步到位 ： <code>int a = 10；</code></li>
<li>分开定义，赋值： <code>int a；</code>   <code>a = 10；</code></li>
<li>简便格式： <code>int a = 10, b = 20, c = 30;</code></li>
</ol>
</blockquote>
<blockquote>
<p><strong>变量需注意的细节：</strong></p>
<ol>
<li>变量不赋值，不能使用</li>
<li>变量名不能重复定义</li>
<li>变量赋值的范围，不能超过数据类型的最大表示范围</li>
<li>变量有作用域，作用域是一对大括号</li>
<li>long类型数据需加上标识L，float类型数据需加上标识F</li>
</ol>
</blockquote>
<h2 id="【数据类型转换、运算符、方法入门】"><a href="#【数据类型转换、运算符、方法入门】" class="headerlink" title="【数据类型转换、运算符、方法入门】"></a>【数据类型转换、运算符、方法入门】</h2><h4 id="1-数据类型转换"><a href="#1-数据类型转换" class="headerlink" title="1. 数据类型转换"></a>1. 数据类型转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">自动类型转换：是程序自动完成的，将小的数据类型转换成大的数据类型</span><br><span class="line"></span><br><span class="line">强制类型转换：需要手动进行转换，将大的数据类型转换成小的数据类型  格式：<span class="keyword">int</span> a = (<span class="keyword">int</span>) <span class="number">10.5</span>;</span><br></pre></td></tr></table></figure>

<h4 id="2-精度损失和数据溢出"><a href="#2-精度损失和数据溢出" class="headerlink" title="2. 精度损失和数据溢出"></a>2. 精度损失和数据溢出</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">精度损失：当一个浮点数转为整数的时候，会发生精度损失，精度损失是直接舍弃小数部分</span><br><span class="line"></span><br><span class="line">数据溢出：当一个表示范围大的数据类型强转为范围小的数据类型的时候，会发生数据溢出，造成部分数据丢失</span><br></pre></td></tr></table></figure>

<h4 id="3-运算时数据类型的转换规则"><a href="#3-运算时数据类型的转换规则" class="headerlink" title="3.  运算时数据类型的转换规则"></a>3.  运算时数据类型的转换规则</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">范围小的类型向范围大的类型提升，<span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span> 运算时直接提升为<span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span>、<span class="keyword">short</span>、<span class="keyword">char</span>--&gt;<span class="keyword">int</span>--&gt;<span class="keyword">long</span>--&gt;<span class="keyword">float</span>--&gt;<span class="keyword">double</span></span><br></pre></td></tr></table></figure>

<h4 id="4-编译器的两点优化"><a href="#4-编译器的两点优化" class="headerlink" title="4.  编译器的两点优化"></a>4.  编译器的两点优化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">优化一：对于<span class="keyword">byte</span>/<span class="keyword">short</span>/<span class="keyword">char</span>三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为</span><br><span class="line">我们补上一个(<span class="keyword">byte</span>)(<span class="keyword">short</span>)(<span class="keyword">char</span>)。</span><br><span class="line"></span><br><span class="line"><span class="keyword">byte</span> num1 = <span class="comment">/*(byte)*/</span> <span class="number">30</span>; <span class="comment">// 右侧没有超过左侧的范围</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">优化二：在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。</span><br><span class="line"></span><br><span class="line"><span class="keyword">short</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">short</span> result = <span class="number">5</span> + <span class="number">8</span>;  <span class="comment">//编译通过</span></span><br><span class="line"><span class="keyword">short</span> result2 = a + <span class="number">8</span>; <span class="comment">//编译报错</span></span><br></pre></td></tr></table></figure>

<h4 id="5-加号的三种用法"><a href="#5-加号的三种用法" class="headerlink" title="5. 加号的三种用法"></a>5. 加号的三种用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.数值运算</span><br><span class="line"></span><br><span class="line">2.和char类型参数运算的时候，会将char类型按照ASCII码表，查表找到对应的ASCII值，进行计算</span><br><span class="line"></span><br><span class="line">3.用于字符串拼接，所有的数据类型和字符串进行拼接，都会变成字符串，也要看运算顺序</span><br></pre></td></tr></table></figure>

<h4 id="6-ASCII码表"><a href="#6-ASCII码表" class="headerlink" title="6. ASCII码表"></a>6. ASCII码表</h4><p>美国标准信息交换码(American Standard Code for Information Interchange ）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">人类定义的一个字符和计算机中二进制存储的对照关系表，是所有编码表的核心。</span><br><span class="line"></span><br><span class="line">编码表本身是字符和一个十进制数进行对应起来组成一张表格，需要记住：&apos;0&apos;-48，&apos;A&apos;-65，&apos;a&apos;-97</span><br></pre></td></tr></table></figure>

<h4 id="7-运算符"><a href="#7-运算符" class="headerlink" title="7. 运算符"></a>7. 运算符</h4><table>
<thead>
<tr>
<th align="left">类型</th>
<th align="left">符号</th>
</tr>
</thead>
<tbody><tr>
<td align="left">算数运算符</td>
<td align="left"><code>+</code> <code>-</code> <code>*</code> <code>/</code> <code>%</code> <code>++</code>  <code>--</code></td>
</tr>
<tr>
<td align="left">赋值运算符</td>
<td align="left"><code>=</code> <code>+=</code> <code>-=</code> <code>*=</code> <code>/=</code> <code>%=</code></td>
</tr>
<tr>
<td align="left">比较运算符</td>
<td align="left"><code>&gt;</code> <code>&lt;</code> <code>==</code> <code>&gt;=</code> <code>&lt;=</code> <code>!=</code></td>
</tr>
<tr>
<td align="left">逻辑运算符</td>
<td align="left"><code>&amp;</code> `</td>
</tr>
<tr>
<td align="left">三元运算符</td>
<td align="left"><code>数据类型 变量名 = 条件判断？表达式A：表达式B</code></td>
</tr>
</tbody></table>
<blockquote>
<p>运算符注意事项：</p>
<ol>
<li>除法，不会出现小数，会将小数部分舍弃</li>
<li><code>+</code> 符号在遇到字符串的时候，表示<strong>连接、拼接</strong>的含义</li>
<li>比较运算符返回的一定是布尔值true、false</li>
<li>逻辑运算符符号两边一定是布尔值</li>
<li>短路效果：如果已经得到结果，那么不会进行后面的操作（双写<code>&amp;</code> <code>|</code> 得到短路效果）</li>
<li>三元运算符的结果<strong>必须被使用</strong>，必须同时保证表达式A和表达式B都<strong>符合左侧数据类型</strong>的要求。</li>
</ol>
</blockquote>
<h4 id="8-、–的使用场景"><a href="#8-、–的使用场景" class="headerlink" title="8. ++、–的使用场景"></a>8. ++、–的使用场景</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">单独操作: 就是自身完成+1或者是-1的动作;</span><br><span class="line"></span><br><span class="line">参数运算：++在前, 先自增, 再赋值；++在后, 先赋值, 再自增。</span><br></pre></td></tr></table></figure>

<h4 id="9-a-1和a-a-1的区别"><a href="#9-a-1和a-a-1的区别" class="headerlink" title="9. a += 1和a = a + 1的区别"></a>9. a += 1和a = a + 1的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a += 1 等价于 a = (a的数据类型)(a+1)，当中存在隐含了一个强制类型转换的过程</span><br></pre></td></tr></table></figure>

<h4 id="10-定义方法的好处"><a href="#10-定义方法的好处" class="headerlink" title="10. 定义方法的好处"></a>10. 定义方法的好处</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将代码按照功能进行划分，提高代码的可读性</span><br><span class="line"></span><br><span class="line">2. 提高代码的复用性</span><br></pre></td></tr></table></figure>

<h4 id="11-方法定义和调用的注意事项"><a href="#11-方法定义和调用的注意事项" class="headerlink" title="11. 方法定义和调用的注意事项"></a>11. 方法定义和调用的注意事项</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 不能嵌套定义，方法中不能定义方法</span><br><span class="line"></span><br><span class="line">2. 方法的执行顺序和定义顺序无关，和调用顺序有关</span><br><span class="line"></span><br><span class="line">3. 方法不调用就不执行,main方法不能人为调用</span><br><span class="line"></span><br><span class="line">4. 在定义方法形式参数的时候,参数需要用逗号隔开</span><br></pre></td></tr></table></figure>

<h2 id="【流程控制语句】"><a href="#【流程控制语句】" class="headerlink" title="【流程控制语句】"></a>【流程控制语句】</h2><h4 id="1-if语句的三种格式"><a href="#1-if语句的三种格式" class="headerlink" title="1. if语句的三种格式"></a>1. if语句的三种格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.if--一种情况的判断</span><br><span class="line"></span><br><span class="line">2.if...else两种情况的判断</span><br><span class="line"></span><br><span class="line">3.if...else if...else多种情况判断</span><br></pre></td></tr></table></figure>

<h4 id="2-程序的健壮性"><a href="#2-程序的健壮性" class="headerlink" title="2. 程序的健壮性"></a>2. 程序的健壮性</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">健壮性：我们需要尽可能多的考虑程序出现的情况，并给出解决方案</span><br></pre></td></tr></table></figure>

<h4 id="3-switch语句的格式"><a href="#3-switch语句的格式" class="headerlink" title="3. switch语句的格式"></a>3. switch语句的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">switch</span> (num) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                System.out.println(<span class="string">"春天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                System.out.println(<span class="string">"夏天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                System.out.println(<span class="string">"秋天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                System.out.println(<span class="string">"冬天"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">                System.out.println(<span class="string">"输入数据超出范围"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>switch语句的注意事项：</strong></p>
<ol>
<li>switch可以接受的4+2种数据类型：4种基本：byte/short/char/int ；  2种引用：String/enum</li>
<li>case后面的表达式不能重复</li>
<li>case语句的穿透效果：没有break会往下穿透</li>
<li>switch语句很灵活，前后顺序可颠倒</li>
</ol>
</blockquote>
<h4 id="4-三种循环语句的格式"><a href="#4-三种循环语句的格式" class="headerlink" title="4. 三种循环语句的格式"></a>4. 三种循环语句的格式</h4><h5 id="（1）for循环"><a href="#（1）for循环" class="headerlink" title="（1）for循环"></a>（1）for循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">格式： <span class="keyword">for</span>(初始化语句;条件判断语句;步进语句)&#123;</span><br><span class="line">		循环体;</span><br><span class="line">	  &#125;</span><br><span class="line"></span><br><span class="line">示例：	<span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">10</span>; i++)&#123;</span><br><span class="line">		sop(i);	</span><br><span class="line">	  &#125;</span><br></pre></td></tr></table></figure>

<h5 id="（2）while循环"><a href="#（2）while循环" class="headerlink" title="（2）while循环"></a>（2）while循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：   初始化语句;</span><br><span class="line">		<span class="keyword">while</span>(条件判断语句)&#123;</span><br><span class="line">		循环体;</span><br><span class="line">		步进语句;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">示例：	  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">while</span>(i &lt;= <span class="number">10</span>)&#123;</span><br><span class="line">  		  sop(i);</span><br><span class="line">          i++;</span><br><span class="line">		&#125;</span><br></pre></td></tr></table></figure>

<h5 id="（3）do-while循环"><a href="#（3）do-while循环" class="headerlink" title="（3）do..while循环"></a>（3）do..while循环</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">格式：	  初始化语句;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			循环体;</span><br><span class="line">			步进语句;</span><br><span class="line">		&#125;<span class="keyword">while</span>(条件判断语句);</span><br><span class="line"></span><br><span class="line">示例：   <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">   			 sop(i);</span><br><span class="line">    		 i++;</span><br><span class="line">		&#125;<span class="keyword">while</span>(i &lt;= <span class="number">10</span>);</span><br></pre></td></tr></table></figure>

<h4 id="5-三种循环语句的区别"><a href="#5-三种循环语句的区别" class="headerlink" title="5. 三种循环语句的区别"></a>5. 三种循环语句的区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. for循环的初始化表达式出了循环不能使用，while循环可以使用</span><br><span class="line"></span><br><span class="line">2. for循环和while循环条件不满足，一次不会执行；do...while循环无论如何执行一次</span><br><span class="line"></span><br><span class="line">3. 当已知循环次数的情况下，建议使用for循环，不知道次数建议使用while循环</span><br></pre></td></tr></table></figure>

<h4 id="6-break和continue"><a href="#6-break和continue" class="headerlink" title="6. break和continue"></a>6. break和continue</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">break：在switch语句中，表示遇到break，switch语句结束；在循环语句中，表示跳出循环，继续往下执行代码</span><br><span class="line"></span><br><span class="line">continue：结束本次循环，进入下一次循环</span><br></pre></td></tr></table></figure>

<h4 id="7-死循环的格式"><a href="#7-死循环的格式" class="headerlink" title="7. 死循环的格式"></a>7. 死循环的格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(;;);</span><br></pre></td></tr></table></figure>

<h2 id="【Idea、方法】"><a href="#【Idea、方法】" class="headerlink" title="【Idea、方法】"></a>【Idea、方法】</h2><h4 id="1-什么是方法"><a href="#1-什么是方法" class="headerlink" title="1. 什么是方法"></a>1. 什么是方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">方法就是经常使用的一部分代码抽取成的代码块</span><br><span class="line"></span><br><span class="line">方法可以理解为工厂，给方法一些参数，方法换给我们一个结果</span><br><span class="line"></span><br><span class="line">方法可以理解为模板，方法是写的通用的逻辑，可以重复调用多次，根据传入的参数不同，返回的结果也不同</span><br></pre></td></tr></table></figure>

<h4 id="2-方法的定义格式"><a href="#2-方法的定义格式" class="headerlink" title="2. 方法的定义格式"></a>2. 方法的定义格式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">修饰符  返回值类型  方法名（参数列表）&#123;</span><br><span class="line"></span><br><span class="line">	方法体；</span><br><span class="line"></span><br><span class="line">	return  (返回值）；</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-return的作用"><a href="#3-return的作用" class="headerlink" title="3. return的作用"></a>3. return的作用</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. 将返回值返回给方法的调用处</span><br><span class="line"></span><br><span class="line">2. 结束方法</span><br></pre></td></tr></table></figure>

<h4 id="4-方法的调用的方式"><a href="#4-方法的调用的方式" class="headerlink" title="4.方法的调用的方式"></a>4.方法的调用的方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 单独调用：适用于有返回值的和无返回值的方法，有返回值的方法单独调用没有意义</span><br><span class="line"></span><br><span class="line">2. 打印调用：只适用于有返回值的方法，打印调用返回值结果只能使用一次</span><br><span class="line"></span><br><span class="line">3. 赋值调用：只适用于有返回值的方法，返回值使用变量接收，可以使用多次</span><br></pre></td></tr></table></figure>

<h4 id="5-方法的执行流程"><a href="#5-方法的执行流程" class="headerlink" title="5. 方法的执行流程"></a>5. 方法的执行流程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1. 以main方法为起点，虚拟机调用main方法，main方法中调用其他方法</span><br><span class="line"></span><br><span class="line">2. 调用方法，传递参数</span><br><span class="line"></span><br><span class="line">3. 将传递的实参给方法中定义的形参进行赋值 ，执行方法体</span><br><span class="line"></span><br><span class="line">4. 使用return语句将返回值，返回给方法的调用处</span><br></pre></td></tr></table></figure>

<h4 id="6-方法的三要素"><a href="#6-方法的三要素" class="headerlink" title="6. 方法的三要素"></a>6. 方法的三要素</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1. 返回值类型：看需求，说是想让你给出结果，还是直接在方法中打印</span><br><span class="line"></span><br><span class="line">2. 参数列表：看该方法完成任务，需不需要外部提供的参数</span><br><span class="line"></span><br><span class="line">3. 方法名：小驼峰命名规则，见名知意</span><br></pre></td></tr></table></figure>

<h4 id="7-方法的重载"><a href="#7-方法的重载" class="headerlink" title="7. 方法的重载"></a>7. 方法的重载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">方法的重载：是指方法名称相同，但参数列表不同的一组方法。用户希望相似的功能，只需要记一个方法名称。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法重载的三个相关</strong>：</p>
<ol>
<li>参数列表的个数</li>
<li>参数列表的数据类型</li>
<li>参数列表的参数顺序</li>
</ol>
</blockquote>
<blockquote>
<p><strong>方法重载的三个无关：</strong></p>
<ol>
<li>和参数的变量名称无关</li>
<li>和方法的返回值类型无关</li>
<li>和方法的修饰符无关</li>
</ol>
</blockquote>
<h4 id="8-IDEA-常用快捷键"><a href="#8-IDEA-常用快捷键" class="headerlink" title="8. IDEA 常用快捷键"></a>8. IDEA 常用快捷键</h4><table>
<thead>
<tr>
<th>功能</th>
<th>快捷键</th>
</tr>
</thead>
<tbody><tr>
<td>调出结果窗口</td>
<td>Alt + 4</td>
</tr>
<tr>
<td>自动导包+修正代码</td>
<td>Alt + Enter</td>
</tr>
<tr>
<td>删除光标所在行</td>
<td>Ctrl + Y</td>
</tr>
<tr>
<td>往下复制一行</td>
<td>Ctrl + D</td>
</tr>
<tr>
<td>格式化代码</td>
<td>Ctrl + Alt + L</td>
</tr>
<tr>
<td>自动生成常用方法</td>
<td>Alt + Insert</td>
</tr>
<tr>
<td>移动当前代码行</td>
<td>Alt + Shift + 上下箭头</td>
</tr>
<tr>
<td>选中一个变量的所有使用处</td>
<td>Shift + F6</td>
</tr>
<tr>
<td>快速生成for循环</td>
<td>XXX.fori</td>
</tr>
</tbody></table>
<h2 id="【数组】"><a href="#【数组】" class="headerlink" title="【数组】"></a>【数组】</h2><h4 id="1-什么是数组"><a href="#1-什么是数组" class="headerlink" title="1. 什么是数组"></a>1. 什么是数组</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是Java中的一种容器，用于存储数据</span><br></pre></td></tr></table></figure>

<blockquote>
<ol>
<li>数组中存储的数据类型一致</li>
<li>数组是引用数据类型</li>
<li>数组的长度一旦确定，不可改变</li>
</ol>
</blockquote>
<h4 id="2-数组的初始化"><a href="#2-数组的初始化" class="headerlink" title="2. 数组的初始化"></a>2. 数组的初始化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">动态初始化：<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">静态初始化：<span class="keyword">int</span>[] array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">静态初始化的省略格式：<span class="keyword">int</span>[] array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">动态初始化的拆分：</span><br><span class="line"><span class="keyword">int</span>[] array;  </span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">3</span>];</span><br><span class="line">静态初始化拆分：</span><br><span class="line"><span class="keyword">int</span>[] array;  </span><br><span class="line">array = <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;  </span><br><span class="line">(拆分后不能使用省略格式进行初始化：array = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;)</span><br></pre></td></tr></table></figure>

<h4 id="3-索引"><a href="#3-索引" class="headerlink" title="3. 索引"></a>3. 索引</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">索引就是数组元素的编号，从0开始，到length-1为止</span><br></pre></td></tr></table></figure>

<blockquote>
<p>赋值：数组名[索引值] = 值；</p>
<p>访问：数据类型 变量名 = 数组名[索引值]；</p>
</blockquote>
<h4 id="4-Java内存的5个组成部分"><a href="#4-Java内存的5个组成部分" class="headerlink" title="4. Java内存的5个组成部分"></a>4. Java内存的5个组成部分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1.栈(Stack)：方法运行时使用的内存，比如main方法运行，进入方法栈中执行，存放方法中的局部变量。</span><br><span class="line">2.堆(Heap)：存储对象或者数组，new来创建的，都存储在堆内存</span><br><span class="line">3.方法区(Method Area)：存储可以运行的class文件</span><br><span class="line">4.本地方法栈(Native Method Stack)：JVM在使用操作系统功能的时候使用，和开发无关</span><br><span class="line">5.寄存器(pc Register)：与CPU相关，性能极高，和开发无关</span><br></pre></td></tr></table></figure>

<h4 id="5-数组越界索引异常"><a href="#5-数组越界索引异常" class="headerlink" title="5. 数组越界索引异常"></a>5. 数组越界索引异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">系统访问了数组中不存在的索引，将抛出数组越界索引异常。</span><br><span class="line">(ArrayIndexOutOfBoundsException)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	System.out.println(arr[<span class="number">3</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-数组空指针异常"><a href="#6-数组空指针异常" class="headerlink" title="6. 数组空指针异常"></a>6. 数组空指针异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给数组赋值null之后，数组将不会保存数组的内存地址，也不允许再操作数组了，运行时会抛出空指针异常。</span><br><span class="line">(NullPointerException)</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	arr = <span class="keyword">null</span>;</span><br><span class="line">	System.out.println(arr[<span class="number">0</span>]);</span><br><span class="line">｝</span><br></pre></td></tr></table></figure>

<h4 id="7-方法的参数类型区别"><a href="#7-方法的参数类型区别" class="headerlink" title="7. 方法的参数类型区别"></a>7. 方法的参数类型区别</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">方法的参数为基本类型时,传递的是数据值，值不会受到影响；方法的参数为引用类型时,传递的是地址值，所以在方法中</span><br><span class="line"></span><br><span class="line">将引用数据类型中的值进行修改，那么会永久性的修改</span><br></pre></td></tr></table></figure>

<h4 id="8-数组的直接打印"><a href="#8-数组的直接打印" class="headerlink" title="8. 数组的直接打印"></a>8. 数组的直接打印</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">直接打印数组名称，得到的是数组对应的内存地址哈希值</span><br><span class="line">[I@7575412c2f  </span><br><span class="line">其中[代表数组，I代表int</span><br></pre></td></tr></table></figure>

<h4 id="9-数组的内存执行流程"><a href="#9-数组的内存执行流程" class="headerlink" title="9. 数组的内存执行流程"></a>9. 数组的内存执行流程</h4><blockquote>
<ol>
<li>编写代码，编译代码，生成.class字节码文件</li>
<li>字节码文件，将信息加载到方法区中，方法区中有类的方法信息</li>
<li>JVM虚拟机去找程序的入口——main方法</li>
<li>main方法进栈执行</li>
<li>main方法中定义的变量，会在栈内存中生成</li>
<li>在堆内存中，开辟了一块空间，将空间中的数值赋默认值，JVM将数组的内存地址赋值给引用类型变量</li>
<li>打印数组名称，找到堆内存中的地址值.</li>
<li>先通过数组名找到堆内存中的地址值，然后通过索引值找到对应的数据值，在数据值进行修改</li>
<li>main方法会出栈/弹栈</li>
<li>堆内存中的两块区域，没有变量去引用了，堆内存中的内容会被JVM垃圾回收机制回收</li>
</ol>
</blockquote>
<h4 id="10-数组的反转"><a href="#10-数组的反转" class="headerlink" title="10. 数组的反转"></a>10. 数组的反转</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> min = <span class="number">0</span>, max = arr.length ‐ <span class="number">1</span>; min &lt;= max; min++, max‐‐) &#123;</span><br><span class="line">	<span class="comment">//利用第三方变量完成数组中的元素交换</span></span><br><span class="line">		<span class="keyword">int</span> temp = arr[min];</span><br><span class="line">		arr[min] = arr[max];</span><br><span class="line">		arr[max] = temp;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 反转后，遍历数组</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">		System.out.println(arr[i]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【类与对象、封装、构造方法】"><a href="#【类与对象、封装、构造方法】" class="headerlink" title="【类与对象、封装、构造方法】"></a>【类与对象、封装、构造方法】</h2><h4 id="1-面向对象"><a href="#1-面向对象" class="headerlink" title="1. 面向对象"></a>1. 面向对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就是当我们需要做一件事情的时候，不是去自己亲力亲为的考虑每一个细节，而是找到能做这件事情的人，帮我们做事</span><br><span class="line"></span><br><span class="line">在代码中，就是找到能完成这个功能的类，并调用这个类中的方法。</span><br></pre></td></tr></table></figure>

<h4 id="2-类与对象"><a href="#2-类与对象" class="headerlink" title="2. 类与对象"></a>2. 类与对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">类：是一个模板，描述了现实事物的信息</span><br><span class="line"></span><br><span class="line">对象：是根据类这个模板生成的一个实体，会在堆内存中开辟空间</span><br></pre></td></tr></table></figure>

<blockquote>
<p>类是对象的模板，对象是类的实体</p>
</blockquote>
<h4 id="3-类描述的信息"><a href="#3-类描述的信息" class="headerlink" title="3. 类描述的信息"></a>3. 类描述的信息</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">属性：事物具备什么特征，在代码中叫做成员变量</span><br><span class="line"></span><br><span class="line">行为：事物能做什么事情，在代码中叫做成员方法</span><br></pre></td></tr></table></figure>

<h4 id="4-对象的使用方式"><a href="#4-对象的使用方式" class="headerlink" title="4. 对象的使用方式"></a>4. 对象的使用方式</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">导包：通常不用考虑，IDEA会进行自动导包</span><br><span class="line"></span><br><span class="line">创建对象：根据类生成一个对象实例</span><br><span class="line"></span><br><span class="line">使用：给对象中的成员变量进行赋值，调用方法</span><br></pre></td></tr></table></figure>

<h4 id="5-成员变量和局部变量区别"><a href="#5-成员变量和局部变量区别" class="headerlink" title="5. 成员变量和局部变量区别"></a>5. 成员变量和局部变量区别</h4><table>
<thead>
<tr>
<th></th>
<th>成员变量</th>
<th>局部变量</th>
</tr>
</thead>
<tbody><tr>
<td>类中位置</td>
<td>类中，方法外</td>
<td>方法内</td>
</tr>
<tr>
<td>作用范围</td>
<td>类中</td>
<td>方法中</td>
</tr>
<tr>
<td>初始化值</td>
<td>有默认值</td>
<td>无默认值</td>
</tr>
<tr>
<td>内存中位置</td>
<td>堆内存</td>
<td>栈内存</td>
</tr>
<tr>
<td>生命周期</td>
<td>随着对象存在</td>
<td>随着方法存在</td>
</tr>
</tbody></table>
<h4 id="6-封装"><a href="#6-封装" class="headerlink" title="6. 封装"></a>6. 封装</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">就是将细节隐藏起来，对外只暴露实现方式</span><br><span class="line"></span><br><span class="line">（1）方法是一种封装</span><br><span class="line"></span><br><span class="line">（2）private关键字也是一种封装</span><br></pre></td></tr></table></figure>

<h4 id="7-private关键字"><a href="#7-private关键字" class="headerlink" title="7. private关键字"></a>7. private关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将成员变量私有，只允许本类访问，不允许外界访问，对外提供Getter/Setter方法</span><br></pre></td></tr></table></figure>

<h4 id="8-this关键字"><a href="#8-this关键字" class="headerlink" title="8. this关键字"></a>8. this关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">this代表所在类的当前对象的引用（地址值），即对象自己的引用。</span><br><span class="line"></span><br><span class="line">方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。</span><br></pre></td></tr></table></figure>

<h4 id="9-成员变量的默认值"><a href="#9-成员变量的默认值" class="headerlink" title="9. 成员变量的默认值"></a>9. 成员变量的默认值</h4><table>
<thead>
<tr>
<th></th>
<th>数据类型</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>基本类型</td>
<td>整数</td>
<td>0</td>
</tr>
<tr>
<td></td>
<td>浮点数</td>
<td>0.0</td>
</tr>
<tr>
<td></td>
<td>字符</td>
<td>‘/u0000’</td>
</tr>
<tr>
<td></td>
<td>布尔</td>
<td>false</td>
</tr>
<tr>
<td>引用类型</td>
<td>数组，类，接口</td>
<td>null</td>
</tr>
</tbody></table>
<h4 id="10-构造方法注意事项"><a href="#10-构造方法注意事项" class="headerlink" title="10. 构造方法注意事项"></a>10. 构造方法注意事项</h4><blockquote>
<ol>
<li>构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样</li>
<li>构造方法不要写返回值类型，连void都不写</li>
<li>构造方法不能return一个具体的返回值</li>
<li>如果你不提供构造方法，系统会给出无参数构造方法。</li>
<li>如果你提供了构造方法，系统将不再提供无参数构造方法。</li>
<li>构造方法是可以重载的，既可以定义参数，也可以不定义参数。</li>
</ol>
</blockquote>
<h4 id="11-标准代码——JavaBean"><a href="#11-标准代码——JavaBean" class="headerlink" title="11. 标准代码——JavaBean"></a>11. 标准代码——JavaBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">    <span class="comment">//成员变量</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="comment">//构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name,<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//成员方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="12-对象的内存图流程"><a href="#12-对象的内存图流程" class="headerlink" title="12. 对象的内存图流程"></a>12. 对象的内存图流程</h4><blockquote>
<ol>
<li>方法区加载类的方法信息</li>
<li>JVM去找main方法，main方法进栈执行</li>
<li>在栈内存中生成一个变量Phone one，在堆内存中开辟一块空间，内含成员变量和成员方法</li>
<li>对成员变量进行赋值</li>
<li>调用成员方法，方法进栈执行，执行完毕之后，方法出栈</li>
<li>最后main方法出栈</li>
<li>垃圾回收机制回收堆内存中的两块区域</li>
</ol>
</blockquote>
<h2 id="【Scanner类、Random类、ArrayList类】"><a href="#【Scanner类、Random类、ArrayList类】" class="headerlink" title="【Scanner类、Random类、ArrayList类】"></a>【Scanner类、Random类、ArrayList类】</h2><h4 id="1-API的使用方式"><a href="#1-API的使用方式" class="headerlink" title="1. API的使用方式"></a>1. API的使用方式</h4><blockquote>
<p>（Application Programming Interface） 应用程序编程接口</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）看包路径 --&gt;导包</span><br><span class="line"></span><br><span class="line">（2）构造方法--&gt;创建</span><br><span class="line"></span><br><span class="line">（3）成员方法--&gt;使用</span><br></pre></td></tr></table></figure>

<h4 id="2-Scanner类使用步骤"><a href="#2-Scanner类使用步骤" class="headerlink" title="2. Scanner类使用步骤"></a>2. Scanner类使用步骤</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Scanner sc = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line"></span><br><span class="line">sc.nextInt();录入整数</span><br><span class="line"></span><br><span class="line">sc.next();录入字符串，不含空格，Tab。有效字符之前的空格、Tab被视为无效；之后的空格、Tab视为结束符号</span><br><span class="line"></span><br><span class="line">sc.nextLine();可以包含空格和Tab,只以回车为结束符号</span><br></pre></td></tr></table></figure>

<h4 id="3-Random类使用步骤"><a href="#3-Random类使用步骤" class="headerlink" title="3. Random类使用步骤"></a>3. Random类使用步骤</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Random ran = new Random();</span><br><span class="line"></span><br><span class="line">ran.nextInt()；生成一个int范围的随机数</span><br><span class="line"></span><br><span class="line">生成(a~b)范围的随机数: ran.nextInt(b-a+1)+a</span><br></pre></td></tr></table></figure>

<h4 id="4-匿名对象"><a href="#4-匿名对象" class="headerlink" title="4. 匿名对象"></a>4. 匿名对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">匿名对象就是没有变量名接受的对象，new  类名（）；</span><br><span class="line"></span><br><span class="line">优点：省略变量名，减少代码的编写</span><br><span class="line"></span><br><span class="line">缺点：对象只能使用一次</span><br></pre></td></tr></table></figure>

<h4 id="5-数组与集合的不同"><a href="#5-数组与集合的不同" class="headerlink" title="5. 数组与集合的不同"></a>5. 数组与集合的不同</h4><table>
<thead>
<tr>
<th align="left"></th>
<th>数组</th>
<th align="left">集合</th>
</tr>
</thead>
<tbody><tr>
<td align="left">运行期间长度</td>
<td>不可变</td>
<td align="left">可变</td>
</tr>
<tr>
<td align="left">存储数据类型</td>
<td>基本+引用数据类型</td>
<td align="left">引用数据类型</td>
</tr>
<tr>
<td align="left">直接打印</td>
<td>地址值</td>
<td align="left">集合的内容</td>
</tr>
<tr>
<td align="left">可操作方法</td>
<td>查、改</td>
<td align="left">增、删、改、查</td>
</tr>
<tr>
<td align="left">获取长度</td>
<td>数组名.length</td>
<td align="left">集合名称.size()</td>
</tr>
</tbody></table>
<h4 id="6-ArrayList类"><a href="#6-ArrayList类" class="headerlink" title="6. ArrayList类"></a>6. ArrayList类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ArrayList集合是Java中的一种容器，底层是数组，默认初始长度是10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<ol>
<li>长度是可变的</li>
<li>只能存储引用数据类型，如果想存储基本数据类型，要使用其包装类</li>
<li>直接打印显示的是集合的内容</li>
</ol>
</blockquote>
<h4 id="7-ArrayList中的常用方法"><a href="#7-ArrayList中的常用方法" class="headerlink" title="7. ArrayList中的常用方法"></a>7. ArrayList中的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span>：向集合当中添加元素，参数的类型和泛型一致，返回值是<span class="title">boolean</span><span class="params">(Always <span class="keyword">true</span>)</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>: 用指定的元素替代此列表中指定位置上的元素,返回被替代的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span>: 获取集合的尺寸长度，返回值就是集合中包含的元素个数</span></span><br></pre></td></tr></table></figure>

<h4 id="8-包装类"><a href="#8-包装类" class="headerlink" title="8. 包装类"></a>8. 包装类</h4><table>
<thead>
<tr>
<th align="center">基本类型</th>
<th align="center">基本类型包装类</th>
</tr>
</thead>
<tbody><tr>
<td align="center">byte</td>
<td align="center">Byte</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">Short</td>
</tr>
<tr>
<td align="center">int</td>
<td align="center">Integer</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">Long</td>
</tr>
<tr>
<td align="center">float</td>
<td align="center">Float</td>
</tr>
<tr>
<td align="center">double</td>
<td align="center">Double</td>
</tr>
<tr>
<td align="center">char</td>
<td align="center">Character</td>
</tr>
<tr>
<td align="center">boolean</td>
<td align="center">Boolean</td>
</tr>
</tbody></table>
<blockquote>
<p>自动装箱：基本类型 –&gt;包装类型<br>自动拆箱：包装类型 –&gt;基本类型</p>
</blockquote>
<h2 id="【String类、static关键字、Arrays类、Math类】"><a href="#【String类、static关键字、Arrays类、Math类】" class="headerlink" title="【String类、static关键字、Arrays类、Math类】"></a>【String类、static关键字、Arrays类、Math类】</h2><h4 id="1-String类的三个特点"><a href="#1-String类的三个特点" class="headerlink" title="1. String类的三个特点"></a>1. String类的三个特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 字符串不变：字符串的值在创建后不能被更改。</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 因为String对象是不可变的，所以它们可以被共享。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. <span class="string">"abc"</span> 等效于 <span class="keyword">char</span>[] data=&#123;<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>&#125;，底层原理是<span class="keyword">byte</span>[]字节数组。</span><br></pre></td></tr></table></figure>

<h4 id="2-创建字符串的1-3种方法"><a href="#2-创建字符串的1-3种方法" class="headerlink" title="2. 创建字符串的1+3种方法"></a>2. 创建字符串的1+3种方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">一种直接创建：直接写上双引号，就是字符串对象</span><br><span class="line"></span><br><span class="line">三种构造方法：</span><br><span class="line"><span class="number">1</span>. <span class="function"><span class="keyword">public</span> <span class="title">String</span><span class="params">()</span>：初始化新创建的 String对象，以使其表示空字符序列</span></span><br><span class="line"><span class="function">2. <span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">char</span>[] array)</span>：根据字符数组的内容，来创建对应的字符串</span></span><br><span class="line"><span class="function">3. <span class="keyword">public</span> <span class="title">String</span><span class="params">(<span class="keyword">byte</span>[] array)</span>：根据字节数组的内容，来创建对应的字符串</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>字符串常量池：直接写“ ”的字符串，在常量池中，如果常量池中有相同的字符串，那么不会创建新的，而是使用以前的。双引号直接写的字符串在常量池当中，new出来的不在池当中。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">"Java"</span>;</span><br><span class="line">        String s2 = <span class="string">"Java"</span>;</span><br><span class="line">        <span class="keyword">char</span>[] chars = &#123;<span class="string">'J'</span>, <span class="string">'a'</span>, <span class="string">'v'</span>, <span class="string">'a'</span>&#125;;</span><br><span class="line">        String s3 = <span class="keyword">new</span> String(chars);</span><br><span class="line">        System.out.println(<span class="string">"s1和s2是否直接相等"</span> + (s1 == s2));  <span class="comment">//true</span></span><br><span class="line">        System.out.println(<span class="string">"s1和s3是否直接相等"</span> + (s1 == s3));	 <span class="comment">//false</span></span><br></pre></td></tr></table></figure>

<h4 id="3-String常用方法"><a href="#3-String常用方法" class="headerlink" title="3.String常用方法"></a>3.String常用方法</h4><h5 id="判断"><a href="#判断" class="headerlink" title="判断"></a>判断</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object anObject)</span>：将此字符串与指定对象进行比较。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equalsIgnoreCase</span><span class="params">(String anotherString)</span>：将此字符串与指定对象进行比较，忽略大小写。</span></span><br></pre></td></tr></table></figure>

<h5 id="获取"><a href="#获取" class="headerlink" title="获取"></a>获取</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span> <span class="params">()</span> ：返回此字符串的长度。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">concat</span> <span class="params">(String str)</span> ：将指定的字符串连接到该字符串的末尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">charAt</span> <span class="params">(<span class="keyword">int</span> index)</span> ：返回指定索引处的 <span class="keyword">char</span>值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span> <span class="params">(String str)</span> ：返回指定子字符串第一次出现在该字符串内的索引。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> begin)</span> ：返回一个子字符串，从begin开始截取字符串到字符串结尾。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">substring</span> <span class="params">(<span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> ：返回一个子字符串，从[begin,end)截取字符串。</span></span><br></pre></td></tr></table></figure>

<h5 id="转换"><a href="#转换" class="headerlink" title="转换"></a>转换</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">char</span>[] toCharArray () ：将此字符串转换为新的字符数组。</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">replace</span> <span class="params">(CharSequence target, CharSequence replacement)</span> ：将与target匹配的字符串使用replacement字符串替换。</span></span><br></pre></td></tr></table></figure>

<h5 id="分割"><a href="#分割" class="headerlink" title="分割"></a>分割</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>String可以比，接，截，割，替，从内容获取索引，从索引获取内容</p>
<p>equal, concat, substring, split, replace, indexof, charAt</p>
</blockquote>
<h4 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4. 正则表达式"></a>4. 正则表达式</h4><blockquote>
<p>正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则</p>
</blockquote>
<table>
<thead>
<tr>
<th align="center">表达式</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">x</td>
<td align="center">字符 x</td>
</tr>
<tr>
<td align="center">\\</td>
<td align="center">反斜线字符</td>
</tr>
<tr>
<td align="center">[abc]</td>
<td align="center">a、b 或 c（简单类）</td>
</tr>
<tr>
<td align="center">[^abc]</td>
<td align="center">任何字符，除了 a、b 或 c（否定）</td>
</tr>
<tr>
<td align="center">[a-zA-Z]</td>
<td align="center">a 到 z 或 A 到 Z，两头的字母包括在内（范围）</td>
</tr>
<tr>
<td align="center">\w</td>
<td align="center">单词字符：[a-zA-Z_0-9]</td>
</tr>
<tr>
<td align="center">X?</td>
<td align="center">X，一次或一次也没有</td>
</tr>
<tr>
<td align="center">X*</td>
<td align="center">X，零次或多次</td>
</tr>
<tr>
<td align="center">X+</td>
<td align="center">X，一次或多次</td>
</tr>
<tr>
<td align="center">X{n}</td>
<td align="center">X，恰好 n 次</td>
</tr>
<tr>
<td align="center">X{n,}</td>
<td align="center">X，至少 n 次</td>
</tr>
<tr>
<td align="center">X{n,m}</td>
<td align="center">X，至少 n 次，但是不超过 m 次</td>
</tr>
</tbody></table>
<h4 id="5-static关键字"><a href="#5-static关键字" class="headerlink" title="5. static关键字"></a>5. static关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>关键字可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。</span><br><span class="line"></span><br><span class="line">也就是说，既然属于类，就可以不靠创建对象来调用了。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>静态存储在方法区中，既不在堆中，也不在栈中（方法中有一块独立的静态区）</p>
</blockquote>
<h5 id="类变量"><a href="#类变量" class="headerlink" title="类变量"></a>类变量</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。</span><br><span class="line"></span><br><span class="line">任何对象都可以更改该类变量的值，也可以在不创建该类的对象的情况下对类变量进行操作。</span><br></pre></td></tr></table></figure>

<h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当static修饰成员方法时，该方法称为类方法,习惯称为静态方法。建议使用类名来调用，而不需要创建类的对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>静态方法调用的注意事项：</strong></p>
<ol>
<li>静态方法可以直接访问类变量和静态方法。</li>
<li>静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。</li>
<li>静态方法中，不能使用this关键字。</li>
</ol>
</blockquote>
<h5 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类中方法外，使用static修饰的代码块&#123; &#125;。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>当第一次用到本类时，静态代码块执行唯一的一次，优先于main方法和构造方法的执行。</p>
<p>作用：给类变量进行初始化赋值。</p>
</blockquote>
<h4 id="6-Arrays类"><a href="#6-Arrays类" class="headerlink" title="6. Arrays类"></a>6. Arrays类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">toString</span><span class="params">(<span class="keyword">int</span>[] a)</span> ：返回指定数组内容的字符串表示形式。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] a)</span> ：对指定的 <span class="keyword">int</span> 型数组按数字升序进行排序。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] arr = &#123;<span class="number">2</span>,<span class="number">34</span>,<span class="number">35</span>,<span class="number">4</span>,<span class="number">657</span>,<span class="number">8</span>,<span class="number">69</span>,<span class="number">9</span>&#125;;</span><br><span class="line">        System.out.println(arr); <span class="comment">// [I@2ac1fdc4</span></span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">// [2, 34, 35, 4, 657, 8, 69, 9]</span></span><br><span class="line">        Arrays.sort(arr);</span><br><span class="line">        System.out.println(Arrays.toString(arr)); <span class="comment">//[2, 4, 8, 9, 34, 35, 69, 657]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注：如果是数值，sort方法默认按照升序从小到大<br>如果是字符串，sort方法默认按照字母升序<br>如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 冒泡排序法代码</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">mySort</span><span class="params">(<span class="keyword">int</span>[] arr)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; arr[j] &lt; arr[j-<span class="number">1</span>] ; j--) &#123;</span><br><span class="line">                 <span class="keyword">int</span> temp = arr[j];</span><br><span class="line">       			 arr[j] = arr[j-<span class="number">1</span>];</span><br><span class="line">      			 arr[j-<span class="number">1</span>] = temp;&#125; &#125; &#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-Math类"><a href="#7-Math类" class="headerlink" title="7. Math类"></a>7. Math类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">abs</span><span class="params">(<span class="keyword">double</span> a)</span>：获取绝对值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">ceil</span><span class="params">(<span class="keyword">double</span> a)</span>：向上取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">floor</span><span class="params">(<span class="keyword">double</span> a)</span>：向下取整</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">round</span><span class="params">(<span class="keyword">double</span> a)</span>：四舍五入</span></span><br></pre></td></tr></table></figure>

<h2 id="【继承、super、this、抽象类】"><a href="#【继承、super、this、抽象类】" class="headerlink" title="【继承、super、this、抽象类】"></a>【继承、super、this、抽象类】</h2><h4 id="1-继承"><a href="#1-继承" class="headerlink" title="1. 继承"></a>1. 继承</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。</span><br><span class="line"></span><br><span class="line">子类可以直接访问父类中的非私有的属性和行为。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>语法格式</strong>：子类 extends 父类</p>
<p><strong>继承的作用</strong>：提高代码复用性，类与类之间产生了关系，是多态的前提。</p>
<p><strong>继承的特点：</strong></p>
<ol>
<li>一个子类只能有一个直接父类，不能有多个直接父类</li>
<li>继承可以支持多级继承，一个子类只能有一个直接父类，但可以有多个间接父类</li>
<li>一个父类可以有多个子类</li>
</ol>
</blockquote>
<h4 id="2-抽象类"><a href="#2-抽象类" class="headerlink" title="2. 抽象类"></a>2. 抽象类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">对子类共性的内容进行抽取，有可能包含抽象方法的类</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>语法格式：</strong>abstract关键字</p>
<p><strong>抽象类的作用：</strong></p>
<ol>
<li>为子类提供便利：抽象类中可以定义一些方法，子类继承之后可以直接使用</li>
<li>对子类进行约束：抽象类中的抽象方法，子类继承之后，必须重写，否则子类也是一个抽象类</li>
</ol>
<p><strong>注意事项：</strong></p>
<ol>
<li>抽象类不能创建对象，如果要创建，需要创建的是子类（抽象类的对象调用方法无方法体，无意义）</li>
<li>抽象类中可以包含构造方法，用于初始化父类成员</li>
<li>抽象类中可以没有抽象方法，但是只要类中有抽象方法，那这个类一定是一个抽象类</li>
<li>子类继承抽象类必须重写全部抽象方法，否则该子类也是一个抽象类</li>
</ol>
</blockquote>
<h4 id="3-继承后的特点"><a href="#3-继承后的特点" class="headerlink" title="3. 继承后的特点"></a>3. 继承后的特点</h4><h5 id="成员变量重名"><a href="#成员变量重名" class="headerlink" title="成员变量重名"></a>成员变量重名</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用super关键字区分</span><br></pre></td></tr></table></figure>

<h5 id="成员方法重名——重写-Override"><a href="#成员方法重名——重写-Override" class="headerlink" title="成员方法重名——重写(Override)"></a>成员方法重名——重写(Override)</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>方法重写的注意事项：</strong></p>
<ol>
<li>必须保证父子类之间方法的名称相同，参数列表也相同。</li>
<li>@Override:写在方法前面，用来检测是不是有效的正确覆盖重写，也可以不写。</li>
<li>子类方法的返回值必须【小于等于】父类方法返回值的范围。</li>
<li>子类方法的权限必须【大于等于】父类方法的权限修饰符。</li>
</ol>
<p>备注：public &gt; protected &gt;(default) &gt; private，（default）不是关键字，是什么都不写，留空。</p>
</blockquote>
<h5 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h5><blockquote>
<p><strong>构造方法注意事项：</strong></p>
<ol>
<li>子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。</li>
<li>子类构造可以通过super关键字来调用父类重载构造。</li>
<li>super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。</li>
</ol>
</blockquote>
<h4 id="4-super关键字的三种用法"><a href="#4-super关键字的三种用法" class="headerlink" title="4. super关键字的三种用法"></a>4. super关键字的三种用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）在子类的成员方法中，访问父类的成员变量</span><br><span class="line"></span><br><span class="line">（2）在子类的成员方法中，访问父类的成员方法</span><br><span class="line"></span><br><span class="line">（3）在子类的构造方法中，访问父类的构造方法</span><br></pre></td></tr></table></figure>

<h4 id="5-this关键字的三种用法"><a href="#5-this关键字的三种用法" class="headerlink" title="5. this关键字的三种用法"></a>5. this关键字的三种用法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">（1）在本类的成员方法中，访问本类的成员变量</span><br><span class="line"></span><br><span class="line">（2）在本类的成员方法中，访问本类的成员方法</span><br><span class="line"></span><br><span class="line">（3）在本类的构造方法中，访问本类的另一种重载的构造方法</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。</p>
</blockquote>
<h2 id="【接口、多态】"><a href="#【接口、多态】" class="headerlink" title="【接口、多态】"></a>【接口、多态】</h2><h4 id="1-接口的定义"><a href="#1-接口的定义" class="headerlink" title="1. 接口的定义"></a>1. 接口的定义</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">接口，是Java语言中一种引用类型，是方法的集合，使用<span class="class"><span class="keyword">interface</span>关键字，是一种公共的规范标准。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用：（1）提供功能的拓展（2）提出约束</p>
<p>定义格式：public interface   接口名称{接口内容}</p>
<p>注意：接口也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。</p>
</blockquote>
<h4 id="2-接口包含的内容"><a href="#2-接口包含的内容" class="headerlink" title="2. 接口包含的内容"></a>2. 接口包含的内容</h4><h5 id="常量（Java-7）"><a href="#常量（Java-7）" class="headerlink" title="常量（Java 7）"></a>常量（Java 7）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">接口当中也可以定义“成员变量”，但是必须使用<span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span>三个关键字进行修饰。</span><br><span class="line"></span><br><span class="line">一旦赋值，不可以修改，从效果上看，这其实就是接口的【常量】。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<ol>
<li>三个修饰符可以省略，但是不写也默认有</li>
<li>接口当中的常量，必须进行赋值；不能不赋值。</li>
<li>接口中常量的名称，使用完全大写的字母，用下划线进行分割：</li>
</ol>
<p><code>public static final int NUM_OF_PEOPLE = 10</code>;</p>
</blockquote>
<h5 id="抽象方法（Java-7）"><a href="#抽象方法（Java-7）" class="headerlink" title="抽象方法（Java 7）"></a>抽象方法（Java 7）</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span>  返回值  方法名称（参数列表）;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>public abstract 可以省略不写</p>
</blockquote>
<h5 id="默认方法-Java-8"><a href="#默认方法-Java-8" class="headerlink" title="默认方法(Java 8)"></a>默认方法(Java 8)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">default</span> 返回值类型 方法名称（参数列表）&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>接口中的默认方法用于接口的升级和修改，可以保证所有的实现类不必被强制要求重写抽象方法。</p>
<p>如果重写使用重写的方法，如果不重写使用默认方法。</p>
</blockquote>
<h5 id="静态方法-Java-8"><a href="#静态方法-Java-8" class="headerlink" title="静态方法(Java 8)"></a>静态方法(Java 8)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> 返回值类型 方法名称（参数列表）&#123;方法体&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：不能通过接口实现类的对象来调用接口当中的静态方法！因为一个实现类可能实现多个接口，通过对象调用接口的静态方法有可能方法名重复导致冲突。正确用法：通过接口名称，直接调用其中的静态方法。</p>
</blockquote>
<h5 id="私有方法-Java-9"><a href="#私有方法-Java-9" class="headerlink" title="私有方法(Java 9)"></a>私有方法(Java 9)</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）普通私有方法：<span class="keyword">private</span>  返回值  方法名称（参数列表）&#123;&#125;</span><br><span class="line"></span><br><span class="line">（<span class="number">2</span>）静态私有方法：<span class="keyword">private</span> <span class="keyword">static</span>   返回值  方法名称（参数列表）&#123;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>解决多个默认方法和静态方法代码重复度过高问题，同时避免该方法被接口的实现类使用。</p>
<p>从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。</p>
</blockquote>
<h4 id="3-接口的多实现"><a href="#3-接口的多实现" class="headerlink" title="3. 接口的多实现"></a>3. 接口的多实现</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个类可以实现多个接口</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意事项：</strong></p>
<ol>
<li>有多个<strong>抽象方法</strong>时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。</li>
<li>有多个<strong>默认方法</strong>时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。</li>
<li>存在同名的<strong>静态方法</strong>并不会冲突，原因是只能通过各自接口名访问静态方法。</li>
<li>当一个类既继承一个父类，又实现若干个接口时，<strong>父类中的成员方法</strong>与接口中的默认方法重名，子类就近</li>
</ol>
<p>选择执行父类的成员方法。</p>
</blockquote>
<h4 id="4-接口的特点"><a href="#4-接口的特点" class="headerlink" title="4. 接口的特点"></a>4. 接口的特点</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. 一个接口能继承另一个或者多个接口，使用 extends 关键字，子接口继承父接口的方法。</span><br><span class="line"></span><br><span class="line">2. 如果父接口中的默认方法有重名的，那么子接口需要重写一次。</span><br><span class="line"></span><br><span class="line">3. 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。</span><br><span class="line"></span><br><span class="line">4. 接口中，没有构造方法，不能创建对象。</span><br><span class="line"></span><br><span class="line">5. 接口中，没有静态代码块。</span><br></pre></td></tr></table></figure>

<h4 id="5-多态"><a href="#5-多态" class="headerlink" title="5. 多态"></a>5. 多态</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">父类引用指向子类对象，一个对象的多种形态</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>多态使用的前提条件</strong>：必须以继承或者实现为前提条件（用父类或者接口去接收对象都行）</p>
<p><strong>多态的表现形式：</strong>父类类型  变量名 = new  子类（）;     接口类型  变量名 = new 实现类（）;</p>
</blockquote>
<h4 id="6-多态成员的访问"><a href="#6-多态成员的访问" class="headerlink" title="6. 多态成员的访问"></a>6. 多态成员的访问</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">多态成员变量的访问方式：编译看左边，运行也看左边</span><br><span class="line"></span><br><span class="line">（1）直接访问：看等号左边是谁就优先用谁，没有向上找</span><br><span class="line"></span><br><span class="line">（2）间接访问：方法属于谁，就优先用谁，没有向上找</span><br><span class="line"></span><br><span class="line">多态成员方法的访问方式：编译看左边，运行看右边</span><br><span class="line"></span><br><span class="line">看等号右边对象创建的是谁，就优先用谁，没有向上找</span><br></pre></td></tr></table></figure>

<h4 id="7-多态的好处和弊端"><a href="#7-多态的好处和弊端" class="headerlink" title="7. 多态的好处和弊端"></a>7. 多态的好处和弊端</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">好处：提高代码复用性</span><br><span class="line"></span><br><span class="line">弊端：不能使用子类独有的方法</span><br></pre></td></tr></table></figure>

<h4 id="8-引用、对象、对象名称的区分"><a href="#8-引用、对象、对象名称的区分" class="headerlink" title="8. 引用、对象、对象名称的区分"></a>8. 引用、对象、对象名称的区分</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Animal a = new Cat();</span><br><span class="line"></span><br><span class="line">引用：等号左侧的数据类型叫引用（Animal）</span><br><span class="line"></span><br><span class="line">对象：等号右边new的就是对象（new Cat()）</span><br><span class="line"></span><br><span class="line">对象名称：变量名称就叫对象名称（a）</span><br></pre></td></tr></table></figure>

<h4 id="9-向上转型和向下转型"><a href="#9-向上转型和向下转型" class="headerlink" title="9. 向上转型和向下转型"></a>9. 向上转型和向下转型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">向上转型：向上转型一定是安全的，因为左父右子，从小范围转向了大范围 </span><br><span class="line"></span><br><span class="line">向下转型：子类类型  变量名 = （子类类型）父类对象；不安全</span><br></pre></td></tr></table></figure>

<blockquote>
<p>对象的向下转型，其实是一个【还原】的动作。由哪个子类转成的父类类型，再转回去要注意，不能转为其</p>
<p>他子类类型，否则会报错。(ClassCastException)</p>
</blockquote>
<h4 id="10-instanceof-关键字"><a href="#10-instanceof-关键字" class="headerlink" title="10. instanceof 关键字"></a>10. instanceof 关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">格式：变量名 <span class="keyword">instanceof</span> 数据类型</span><br><span class="line"></span><br><span class="line">如果变量属于该数据类型，返回<span class="keyword">true</span>；如果变量不属于该数据类型，返回<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>instanceof 可用于判断对象属于哪一个实例，一般都在方法中使用。</p>
<p>对传入的父类类型的对象进行实例判断，强转回子类，目的是调用子类特有的方法</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 向上转型</span></span><br><span class="line">		Animal a = <span class="keyword">new</span> Cat();</span><br><span class="line">		<span class="keyword">if</span> (a <span class="keyword">instanceof</span> Cat)&#123;</span><br><span class="line">			Cat c = (Cat)a;</span><br><span class="line">			c.catchMouse(); <span class="comment">// 调用的是 Cat 的 catchMouse</span></span><br><span class="line">		&#125; <span class="keyword">else</span> <span class="keyword">if</span> (a <span class="keyword">instanceof</span> Dog)&#123;</span><br><span class="line">			Dog d = (Dog)a;</span><br><span class="line">			d.watchHouse(); <span class="comment">// 调用的是 Dog 的 watchHouse</span></span><br></pre></td></tr></table></figure>

<h2 id="【final、权限、内部类、引用类型】"><a href="#【final、权限、内部类、引用类型】" class="headerlink" title="【final、权限、内部类、引用类型】"></a>【final、权限、内部类、引用类型】</h2><h4 id="1-final-关键字"><a href="#1-final-关键字" class="headerlink" title="1. final 关键字"></a>1. final 关键字</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">被final关键字修饰的类、方法和变量不可改变。有以下四种主要用法：</span><br></pre></td></tr></table></figure>

<h5 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> 类名 </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修饰符 <span class="keyword">final</span> 返回值类型 方法名(参数列表)&#123;</span><br><span class="line">	<span class="comment">//方法体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰局部变量"><a href="#修饰局部变量" class="headerlink" title="修饰局部变量"></a>修饰局部变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为局部变量无初始化默认值，可以先定义后赋值。&#123;<span class="keyword">final</span> <span class="keyword">int</span> a; a = <span class="number">10</span>;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="修饰成员变量"><a href="#修饰成员变量" class="headerlink" title="修饰成员变量"></a>修饰成员变量</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. 由于成员变量具有默认值，所以用了<span class="keyword">final</span>之后必须手动赋值，不会再给默认值了。&#123;<span class="keyword">final</span> <span class="keyword">int</span> a = <span class="number">10</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 对于<span class="keyword">final</span>的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。</span><br><span class="line"></span><br><span class="line"><span class="number">3</span>. 必须保证类当中所有重载的构造方法，都最终会对<span class="keyword">final</span>的成员变量进行赋值。</span><br></pre></td></tr></table></figure>

<h4 id="2-权限修饰符"><a href="#2-权限修饰符" class="headerlink" title="2. 权限修饰符"></a>2. 权限修饰符</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">public</th>
<th align="center">protected</th>
<th align="center">(default)</th>
<th align="center">private</th>
</tr>
</thead>
<tbody><tr>
<td align="center">同一类中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
</tr>
<tr>
<td align="center">同一包中</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包的子类</td>
<td align="center">√</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
</tr>
<tr>
<td align="center">不同包的无关类</td>
<td align="center">√</td>
<td align="center"></td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h4 id="3-成员内部类"><a href="#3-成员内部类" class="headerlink" title="3. 成员内部类"></a>3. 成员内部类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">定义在类中方法外的类。</span><br><span class="line"><span class="class"><span class="keyword">class</span> 外部类 </span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">class</span> 内部类</span>&#123;</span><br><span class="line">	</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>访问特点</strong>：</p>
<ol>
<li>内部类可以直接访问外部类的成员，包括私有成员。</li>
<li>外部类要访问内部类的成员，必须要建立内部类的对象。</li>
<li>创建内部类对象格式：<code>外部类名.内部类名 对象名 = new 外部类型().new 内部类型()；</code></li>
</ol>
</blockquote>
<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Outer$Heart.class</li>
<li>如果内部类和外部类的变量出现了重名现象，那么在内部类调用外部类变量的格式是：</li>
</ol>
<p><code>外部类名称.this.对象名</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 外部类的成员变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> num = <span class="number">20</span>; <span class="comment">// 内部类的成员变量</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> num = <span class="number">30</span>; <span class="comment">// 内部类方法的局部变量</span></span><br><span class="line">            System.out.println(num); <span class="comment">// 30 局部变量，就近原则</span></span><br><span class="line">            System.out.println(<span class="keyword">this</span>.num); <span class="comment">// 20 内部类的成员变量</span></span><br><span class="line">            System.out.println(Outer.<span class="keyword">this</span>.num); <span class="comment">// 10 外部类的成员变量</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-类的权限修饰符"><a href="#4-类的权限修饰符" class="headerlink" title="4. 类的权限修饰符"></a>4. 类的权限修饰符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定义一个类的时候，权限修饰符规则：</span><br><span class="line"></span><br><span class="line">1. 外部类：public/(default)</span><br><span class="line"></span><br><span class="line">2. 成员内部类：四个都行</span><br><span class="line"></span><br><span class="line">3. 局部内部类：什么都不能写</span><br></pre></td></tr></table></figure>

<h4 id="5-局部内部类的final问题"><a href="#5-局部内部类的final问题" class="headerlink" title="5. 局部内部类的final问题"></a>5. 局部内部类的final问题</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodOuter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = <span class="number">10</span>; <span class="comment">// 所在方法的局部变量,从Java 8+开始,只要局部变量事实不变,那么final关键字可以省略			</span></span><br><span class="line">	<span class="class"><span class="keyword">class</span> <span class="title">MyInner</span> </span>&#123;</span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">methodInner</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		System.out.println(num);</span><br><span class="line">    	&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>原因：</strong></p>
<ol>
<li>new出来的对象在堆内存当中。</li>
<li>局部变量是跟着方法走的，在栈内存当中。</li>
<li>方法运行结束之后，立刻出栈，局部变量就会立刻消失。</li>
<li>但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。</li>
</ol>
</blockquote>
<h4 id="6-匿名内部类"><a href="#6-匿名内部类" class="headerlink" title="6. 匿名内部类"></a>6. 匿名内部类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是内部类的简化写法。它的本质是一个带具体实现的【父类或者父接口的】匿名的子类对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式</span></span><br><span class="line"><span class="keyword">new</span> 父类名或者接口名()&#123;</span><br><span class="line">	<span class="comment">// 方法重写</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 执行语句</span></span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>匿名内部类特点：</p>
<p>匿名内部类的好处：不用编写实现类，就能创建实现类对象。</p>
<p>匿名内部类的弊端：创建的这个实现类对象，模板只能使用一次。</p>
<p>匿名内部类和匿名对象不是一回事，但是可以【匿名内部类】+【匿名对象】组合使用</p>
</blockquote>
<h2 id="【Object类、常用API】"><a href="#【Object类、常用API】" class="headerlink" title="【Object类、常用API】"></a>【Object类、常用API】</h2><h4 id="1-Object类"><a href="#1-Object类" class="headerlink" title="1. Object类"></a>1. Object类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。如果一个类没有特别指定父类， 那么默认则继承自Object类。</span><br></pre></td></tr></table></figure>

<h4 id="2-toString方法"><a href="#2-toString方法" class="headerlink" title="2. toString方法"></a>2. toString方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。</span><br><span class="line">直接打印对象的名字，其实就是调用对象的toString方法。toString方法可以通过快捷键快速覆盖重写。</span><br></pre></td></tr></table></figure>

<h4 id="3-equals方法"><a href="#3-equals方法" class="headerlink" title="3. equals方法"></a>3. equals方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。</span><br><span class="line">默认进行的比较是 == 运算符的对象地址比较，只要不是同一个对象，结果必然为<span class="keyword">false</span>。</span><br><span class="line">希望进行对象内容的比较时，可以通过重写进行对象内容的比较：</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象地址一样，则认为相同</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> == o) <span class="keyword">return</span> <span class="keyword">true</span>;  </span><br><span class="line">        <span class="comment">// 如果参数为空，或者类型信息不一样，则认为不同</span></span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span> || getClass() != o.getClass()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//向下转型</span></span><br><span class="line">        Student student = (Student) o;</span><br><span class="line">        <span class="comment">// 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果</span></span><br><span class="line">        <span class="keyword">return</span> age == student.age &amp;&amp; Objects.equals(name, student.name);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Objects类"><a href="#4-Objects类" class="headerlink" title="4. Objects类"></a>4. Objects类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在JDK7添加了一个Objects工具类，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>public static boolean equals(Object a, Object b)</code> :判断两个对象是否相等</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object a, Object b)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//短路与，若a为null，则避免了a.equals(b)的执行</span></span><br><span class="line">    <span class="keyword">return</span> (a == b) || (a != <span class="keyword">null</span> &amp;&amp; a.equals(b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Date类"><a href="#5-Date类" class="headerlink" title="5. Date类"></a>5. Date类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">表示特定的瞬间，精确到毫秒。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>时间原点：1970年1月1日 00:00:00（英国格林威治时间）</li>
<li>中国属于东八区，会把时间增加8个小时</li>
</ol>
</blockquote>
<blockquote>
<p>两个构造方法：</p>
<ol>
<li>Date():返回当前时间的日期对象</li>
<li>Date(long date):返回一个从1970年1月1日 0点0分0秒 + 毫秒值 所对应的日期对象</li>
</ol>
<p>一个成员方法：</p>
<ol>
<li>getTime():将一个日期对象，转为对象的毫秒值表示</li>
</ol>
</blockquote>
<h4 id="6-DateFormat类"><a href="#6-DateFormat类" class="headerlink" title="6. DateFormat类"></a>6. DateFormat类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DateFormat用于将日期对象格式化成指定的字符串表示，或者将一个字符串解析成Date对象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造方法：public SimpleDateFormat(String pattern)</p>
<p>格式化：按照指定的格式，从Date对象转换为String对象： <code>public String format(Date date)</code></p>
<p>解析：按照指定的格式，从String对象转换为Date对象： <code>public Date parse(String source)</code></p>
</blockquote>
<p><strong>格式规则</strong></p>
<table>
<thead>
<tr>
<th align="center">字母</th>
<th align="center">日期或时间元素</th>
</tr>
</thead>
<tbody><tr>
<td align="center">y</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">M</td>
<td align="center">年中的月份</td>
</tr>
<tr>
<td align="center">D</td>
<td align="center">年中的天数</td>
</tr>
<tr>
<td align="center">d</td>
<td align="center">月份中的天数</td>
</tr>
<tr>
<td align="center">E</td>
<td align="center">星期中的天数</td>
</tr>
<tr>
<td align="center">H</td>
<td align="center">一天中的小时数（0-23）</td>
</tr>
<tr>
<td align="center">m</td>
<td align="center">小时中的分钟数</td>
</tr>
<tr>
<td align="center">s</td>
<td align="center">分钟中的秒数</td>
</tr>
<tr>
<td align="center">S</td>
<td align="center">毫秒数</td>
</tr>
</tbody></table>
<h4 id="7-Calendar类"><a href="#7-Calendar类" class="headerlink" title="7. Calendar类"></a>7. Calendar类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>常用方法：</strong></p>
<ol>
<li><code>public static Calendar getInstance()</code>： 通过静态方法创建对象</li>
<li><code>public int get(int field)</code>：返回给定日历字段的值</li>
<li><code>public abstract void add(int field, int amount)</code> ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。</li>
<li><code>public Date getTime()</code>：返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象。</li>
<li><code>public void set(int field, int value)</code>：将给定的日历字段设置为给定值。 （也可以同时设置年月日：<code>set(int year, int month, int day)</code>）</li>
</ol>
</blockquote>
<p>Calendar类中提供很多成员常量，代表给定的日历字段：</p>
<table>
<thead>
<tr>
<th align="center">字段值</th>
<th align="center">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="center">YEAR</td>
<td align="center">年</td>
</tr>
<tr>
<td align="center">MONTH</td>
<td align="center">月（月份特殊，西方是0-11表示12个月，可以+1使用）</td>
</tr>
<tr>
<td align="center">DAY_OF_MONTH</td>
<td align="center">月中的天（几号）</td>
</tr>
<tr>
<td align="center">HOUR</td>
<td align="center">时（12小时制）</td>
</tr>
<tr>
<td align="center">HOUR_OF_DAY</td>
<td align="center">时（24小时制）</td>
</tr>
<tr>
<td align="center">MINUTE</td>
<td align="center">分</td>
</tr>
<tr>
<td align="center">SECOND</td>
<td align="center">秒</td>
</tr>
<tr>
<td align="center">DAY_OF_WEEK</td>
<td align="center">周中的天（西方是从星期日开始每周的第一天，可以-1使用）</td>
</tr>
</tbody></table>
<h4 id="8-日期、字符串、毫秒值和日历的相互转换"><a href="#8-日期、字符串、毫秒值和日历的相互转换" class="headerlink" title="8. 日期、字符串、毫秒值和日历的相互转换"></a>8. 日期、字符串、毫秒值和日历的相互转换</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">             SimpleDateFormat.parse(s)                 Date.getTime(d)    </span><br><span class="line">字符串		------------------------&gt;	  日期	-----------------------&gt;   毫秒值</span><br><span class="line">  (String)   &lt;------------------------    (Date)  &lt;-----------------------   (<span class="keyword">long</span>)</span><br><span class="line">            SimpleDateFormat.format(d)   /|\   |          <span class="keyword">new</span> Date(l)</span><br><span class="line">                                          |    |</span><br><span class="line">                               getTime()  |	|  setTime(Date date)</span><br><span class="line">                                          |	|   </span><br><span class="line">                                          |   \|/</span><br><span class="line">                                      日历（Calendar）</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>Date类是另外三种时间格式连接的桥梁，相互之间转换时都需要通过Date类。</strong></p>
</blockquote>
<h4 id="9-System类"><a href="#9-System类" class="headerlink" title="9. System类"></a>9. System类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">currentTimeMillis</span><span class="params">()</span> ：返回以毫秒为单位的当前时间，经常用来测试程序性能。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span> ：将源数组中指定的数据拷贝到目标数组中。数组的拷贝动作是系统级的，性能很高。</span></span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th>参数名称</th>
<th>参数类型</th>
<th>参数含义</th>
</tr>
</thead>
<tbody><tr>
<td>src</td>
<td>Object</td>
<td>源数组</td>
</tr>
<tr>
<td>srcPos</td>
<td>int</td>
<td>源数组索引起始位置</td>
</tr>
<tr>
<td>dest</td>
<td>Object</td>
<td>目标数组</td>
</tr>
<tr>
<td>destPos</td>
<td>int</td>
<td>目标数组索引起始位置</td>
</tr>
<tr>
<td>length</td>
<td>int</td>
<td>复制元素个数</td>
</tr>
</tbody></table>
<h4 id="10-StringBuilder类"><a href="#10-StringBuilder类" class="headerlink" title="10. StringBuilder类"></a>10. StringBuilder类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder又称为可变字符序列，它是一个类似于String的字符串缓冲区，支持可变的字符串，可以提高字符串的操作效率。底层也是一个数组，但是没有被final修饰，可以改变长度在数组中加入新内容。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>构造方法：</p>
<ol>
<li><code>public StringBuilder()</code> ：构造一个空的StringBuilder容器。</li>
<li><code>public StringBuilder(String str)</code>：构造一个StringBuilder容器，并将字符串添加进去。  </li>
</ol>
<p>常用方法：</p>
<ol>
<li>public StringBuilder append(…) ：添加任意类型数据的字符串形式，并返回当前对象自身。 </li>
<li>public String toString() ：将当前StringBuilder对象转换为String对象。 </li>
</ol>
</blockquote>
<h4 id="11-基本类型与字符串之间的转换"><a href="#11-基本类型与字符串之间的转换" class="headerlink" title="11. 基本类型与字符串之间的转换"></a>11. 基本类型与字符串之间的转换</h4><blockquote>
<p><strong>基本类型转换为String</strong></p>
<ol>
<li>基本类型的值 + “”  (推荐方法）</li>
<li><code>static String toString(基本数据类型):String s = Integer.toString(int i)</code></li>
<li><code>static String valueOf(基本数据类型):String s = String.valueOf(int i)</code></li>
</ol>
<p><strong>String转换为基本类型</strong></p>
<p>除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型。</p>
<p>例如：Integer类: <code>static int parseInt(String s)</code></p>
</blockquote>
<h2 id="【Collection、泛型】"><a href="#【Collection、泛型】" class="headerlink" title="【Collection、泛型】"></a>【Collection、泛型】</h2><h4 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1. Collection"></a>1. Collection</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">单列集合类的根接口，有两个重要的子接口，分别是java.util.List和java.util.Set</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>List</strong></p>
<p>特点：元素有序、元素可重复</p>
<p>主要实现类：<code>java.util.ArrayList</code>和<code>java.util.LinkedList</code></p>
</blockquote>
<blockquote>
<p><strong>Set</strong></p>
<p>特点：元素无序，而且不可重复</p>
<p>主要实现类：<code>java.util.HashSet</code>和<code>java.util.LinkedHashSet</code></p>
</blockquote>
<h4 id="2-集合和数组的区别"><a href="#2-集合和数组的区别" class="headerlink" title="2. 集合和数组的区别"></a>2. 集合和数组的区别</h4><blockquote>
<p><strong>长度不同</strong></p>
<ul>
<li>集合：集合的长度是可变的，因为集合的底层就是数组，当增删元素的时候，会进行数组的扩容</li>
<li>数组：数组的长度在运行期间不可变，一旦创建，就固定</li>
</ul>
</blockquote>
<blockquote>
<p><strong>存储的数据类型不同</strong></p>
<ul>
<li>集合：只能存储引用数据类型，如果想存储基本数据类型，需要存储对应的包装类</li>
<li>数组：基本数据类型和引用数据类型都可以存储</li>
</ul>
</blockquote>
<h4 id="3-Collection-常用功能"><a href="#3-Collection-常用功能" class="headerlink" title="3. Collection 常用功能"></a>3. Collection 常用功能</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合:</span><br></pre></td></tr></table></figure>

<ul>
<li><code>public boolean add(E e)</code>：  把给定的对象添加到当前集合中 。</li>
<li><code>public void clear()</code> :清空集合中所有的元素。</li>
<li><code>public boolean remove(E e)</code>: 把给定的对象在当前集合中删除。</li>
<li><code>public boolean contains(E e)</code>: 判断当前集合中是否包含给定的对象。</li>
<li><code>public boolean isEmpty()</code>: 判断当前集合是否为空。</li>
<li><code>public int size()</code>: 返回集合中元素的个数。</li>
<li><code>public Object[] toArray()</code>: 把集合中的元素，存储到数组中。</li>
</ul>
<h4 id="4-Iterator接口"><a href="#4-Iterator接口" class="headerlink" title="4.  Iterator接口"></a>4.  Iterator接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">【迭代器】Iterator是一种通用的Collection集合元素的获取方式，通过判断集合中是否有元素，有则取出，继续判断，直到把集合中的元素全部取出为止。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>获取迭代器的方法：</p>
<ul>
<li><code>collection.iterator()</code>:由于接口不能直接实例化，使用集合的Iterator方法获取</li>
</ul>
<p>常用的两个方法：</p>
<ul>
<li><code>public E next()</code>:返回迭代的下一个元素。</li>
<li><code>public boolean hasNext()</code>:如果仍有元素可以迭代，则返回 true。</li>
</ul>
<p><strong>并发修改异常</strong>：迭代器的底层实现原理，运用到指针。在使用迭代器的过程中，修改了集合的长度，就会抛出该异常。使用Iterator接口的一个子接口ListIterator接口可以解决这个问题。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	Collection&lt;String&gt; coll = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">	Iterator&lt;String&gt; it = coll.iterator(); <span class="comment">//通过集合获取迭代器</span></span><br><span class="line">	<span class="keyword">while</span>(it.hasNext())&#123; <span class="comment">//判断是否有迭代元素</span></span><br><span class="line">		String s = it.next();<span class="comment">//获取迭代出的元素</span></span><br><span class="line">		System.out.println(s);&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-ListIterator接口"><a href="#5-ListIterator接口" class="headerlink" title="5. ListIterator接口"></a>5. ListIterator接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Iterator接口有一个子接口ListIterator接口，其中定义了add方法和remove方法，可以对集合添加\删除元素。由迭代器自己添加\删除的不会抛出异常。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用步骤：</p>
<ol>
<li>创建的集合首先不能使用Collection，因为Collection获取不了ListIterator接口，需要使用List接口获取ListIterator接口实现类</li>
<li>调用listIterator（）方法，获取listIterator接口实现类</li>
<li>使用hasNext和next方法进行迭代</li>
<li>使用接口实现类的add方法进行添加，remove方法进行删除元素。注意：不要使用集合进行添加删除</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    list.add(<span class="string">"黑马"</span>);</span><br><span class="line">	ListIterator&lt;String&gt; lit = list.listIterator();</span><br><span class="line">	<span class="keyword">while</span> (lit.hasNext()) &#123;</span><br><span class="line">		String s = lit.next();</span><br><span class="line">		System.out.println(s);</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"黑马"</span>.equals(s)) &#123;</span><br><span class="line">			lit.add(<span class="string">"金马"</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-增强for"><a href="#6-增强for" class="headerlink" title="6. 增强for"></a>6. 增强for</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">增强<span class="keyword">for</span>循环是基于迭代器设计的一种高级<span class="keyword">for</span>循环，专门用于遍历数组和集合。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式：</span><br><span class="line"><span class="keyword">for</span>(元素的数据类型  变量 : Collection集合or数组)&#123; </span><br><span class="line">  	<span class="comment">//写操作代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-泛型"><a href="#7-泛型" class="headerlink" title="7. 泛型"></a>7. 泛型</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在定义类或方法时，对于未知类型的数据进行占位，用于后期接收数据类型，以便预支使用的一种未知的数据类型。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>泛型的好处：</p>
<ol>
<li>避免了类型转换的麻烦，使用API时更加直观简洁。</li>
<li>把运行期异常，提升到了编译期</li>
</ol>
</blockquote>
<h5 id="含有泛型的类"><a href="#含有泛型的类" class="headerlink" title="含有泛型的类"></a>含有泛型的类</h5><blockquote>
<p>定义格式：<code>修饰符 class 类名&lt;代表泛型的变量&gt; {}</code></p>
<p>确定泛型：在创建对象的时候</p>
</blockquote>
<h5 id="含有泛型的方法"><a href="#含有泛型的方法" class="headerlink" title="含有泛型的方法"></a>含有泛型的方法</h5><blockquote>
<p>定义格式：<code>修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){}</code></p>
<p>确定泛型：调用方法时</p>
</blockquote>
<h5 id="含有泛型的接口"><a href="#含有泛型的接口" class="headerlink" title="含有泛型的接口"></a>含有泛型的接口</h5><blockquote>
<p>定义格式：<code>修饰符 interface 接口名&lt;代表泛型的变量&gt; {}</code></p>
<p>确定泛型：1、定义类时确定泛型的类型； 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型</p>
</blockquote>
<h4 id="8-泛型通配符"><a href="#8-泛型通配符" class="headerlink" title="8. 泛型通配符"></a>8. 泛型通配符</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">不知道使用什么类型来接收的时候,此时泛型可以使用“?”表示,“?”表示未知通配符。</span><br><span class="line">但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>受限泛型</strong>：泛型没有继承概念，JAVA的泛型中可以指定一个泛型的上限和下限。</p>
<p><strong>泛型的上限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? extends 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其子类</code></li>
</ul>
<p><strong>泛型的下限</strong>：</p>
<ul>
<li>格式： <code>类型名称 &lt;? super 类 &gt; 对象名称</code></li>
<li>意义： <code>只能接收该类型及其父类型</code></li>
</ul>
</blockquote>
<h2 id="【List、Set、数据结构、Collections】"><a href="#【List、Set、数据结构、Collections】" class="headerlink" title="【List、Set、数据结构、Collections】"></a>【List、Set、数据结构、Collections】</h2><h4 id="1-数据结构"><a href="#1-数据结构" class="headerlink" title="1. 数据结构"></a>1. 数据结构</h4><h5 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：先进后出</strong></p>
<ul>
<li>压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。</li>
<li>弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。</li>
</ul>
</blockquote>
<h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：先进先出</strong></p>
</blockquote>
<h5 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组是有序的元素序列，在内存中开辟一段连续的空间，并在此空间存放元素</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：有索引值，查询快，增删慢</strong></p>
</blockquote>
<h5 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">链表中的每一个元素也称之为一个节点，一个节点包含了一个数据源，两个指针域（存储地址）：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：查询慢，增删快</strong></p>
<ul>
<li>单项链表：链表中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致）</li>
<li>双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合</li>
</ul>
</blockquote>
<h5 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是一种比较平衡的二叉树</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>特点：速度特别快，</strong>趋近平衡树，查询叶子节点最大次数和最小次数不能超过2倍</p>
<p>约束：</p>
<ol>
<li>节点可以是红色的或者黑色的</li>
<li>根节点是黑色的</li>
<li>叶子节点(特指空节点)是黑色的</li>
<li>每个红色节点的子节点都是黑色的</li>
<li>任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同</li>
</ol>
</blockquote>
<h4 id="2-List-接口"><a href="#2-List-接口" class="headerlink" title="2. List 接口"></a>2. List 接口</h4><blockquote>
<p>特点：</p>
<ol>
<li>有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123)</li>
<li>有索引,包含了一些带索引的方法</li>
<li>允许存储重复的元素</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">常用方法：</span><br><span class="line">    - <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span>: 将指定的元素，添加到该集合中的指定位置上。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span>:返回集合中指定位置的元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span>: 移除列表中指定位置的元素, 返回的是被移除的元素。</span></span><br><span class="line"><span class="function">    - <span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span>:用指定元素替换集合中指定位置的元素,返回值的更新前的元素。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-LinkedList-集合"><a href="#3-LinkedList-集合" class="headerlink" title="3. LinkedList 集合"></a>3. LinkedList 集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">LinkedList是一个双向链表，查询慢，增删快，包含了大量操作首尾元素的方法。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span>:将指定元素插入此列表的开头。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span>:将指定元素添加到此列表的结尾。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span>:返回此列表的第一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span>:返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span>:移除并返回此列表的第一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span>:移除并返回此列表的最后一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> E <span class="title">pop</span><span class="params">()</span>:从此列表所表示的堆栈处弹出一个元素。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(E e)</span>:将元素推入此列表所表示的堆栈。</span></span><br><span class="line"><span class="function">- <span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span>：如果列表不包含元素，则返回<span class="keyword">true</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-HashSet-集合"><a href="#4-HashSet-集合" class="headerlink" title="4. HashSet 集合"></a>4. HashSet 集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">是Set接口的一个实现类，存储的元素不可重复，并且元素都是无序的(即存取顺序不一致),没有索引,不能使用普通的for循环遍历。HashSet根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>HashSet集合存储数据的结构（哈希表）</strong>：</p>
<ul>
<li>jdk1.8版本之前：哈希表 = 数组 + 链表</li>
<li>jdk1.8版本之后：哈希表 = 数组 +链表/红黑树；</li>
</ul>
<p>（当链表长度超过阈值（8）时，将链表转换为红黑树提高查询的速度）</p>
</blockquote>
<h4 id="5-LinkedHashSet-集合"><a href="#5-LinkedHashSet-集合" class="headerlink" title="5. LinkedHashSet 集合"></a>5. LinkedHashSet 集合</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HashSet是无序的，LinkedHashSet是有序的</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：底层是一个哈希表（数组+链表/红黑树）+ 链表：多了一条链表(记录元素的存储顺序)，保证元素有序</p>
</blockquote>
<h4 id="6-重写HashCode-方法"><a href="#6-重写HashCode-方法" class="headerlink" title="6. 重写HashCode()方法"></a>6. 重写HashCode()方法</h4><blockquote>
<p><strong>为什么需要重写HashCode()方法？</strong></p>
<p>如果两个对象需要判断是否内容相同，可以调用equals方法进行比较，但如果一个对象的字段过多，那就会偏频繁的进行字段的比较，非常的耗费性能。我们可以对Object类继承过来的hashCode方法进行覆盖重写，不让他生成地址值，而是<strong>根据我们对象的内容</strong>，生成hash值进行比较。因为比较hash值比equals方法容易得多。如果hash值相同，再调用equals方法进行内容比较。</p>
</blockquote>
<blockquote>
<p><strong>哈希值：</strong>是一个十进制的整数，由系统随机给出(就是对象的地址值，是一个逻辑地址，是模拟出来得到地址，不是数据实际存储的物理地址)</p>
</blockquote>
<blockquote>
<p><strong>重写HashCode()进行比较的步骤：</strong></p>
<ol>
<li>重写Object类中继承过来的HashCode()方法，自定义，根据对象的内容生成的哈希值</li>
<li>我们在进行集合元素存储的时候，比如向HashSet集合添加元素的时候，会先调用HashCode()方法，生成哈希值，不同对象生成的哈希值可能相同（虽然概率比较低）</li>
<li>哈希值不同，对象的内容肯定不同；哈希值相同，对象的内容有可能相同，有可能不同</li>
<li>比较哈希值，如果不同，直接存；如果相同，再调用equals方法进行内容比较</li>
</ol>
</blockquote>
<h4 id="7-可变参数"><a href="#7-可变参数" class="headerlink" title="7. 可变参数"></a>7. 可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数</span><br><span class="line">格式：修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>原理：可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个（不传递），1,2,…多个</p>
</blockquote>
<blockquote>
<p>注意事项：</p>
<ol>
<li>一个方法的参数列表，只能有一个可变参数</li>
<li>如果方法的参数有多个，那么可变参数必须写在参数列表的末尾</li>
<li>可变参数的终极写法：Object…obj </li>
</ol>
</blockquote>
<h4 id="8-Collections-工具类"><a href="#8-Collections-工具类" class="headerlink" title="8. Collections 工具类"></a>8. Collections 工具类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function"><span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? <span class="keyword">super</span> T&gt; c, T... elements)</span>：</span></span><br><span class="line"><span class="function">往集合中添加一些元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List&lt;?&gt; list)</span>：打乱集合顺序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list)</span>（&lt;T extends Comparable&lt;? <span class="keyword">super</span> T&gt;&gt;）：</span></span><br><span class="line"><span class="function">根据元素的自然顺序对指定列表按升序进行排序</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(List&lt;T&gt; list, Comparator&lt;? <span class="keyword">super</span> T&gt; c)</span>：</span></span><br><span class="line"><span class="function">根据指定比较器产生的顺序对指定列表进行排序</span></span><br></pre></td></tr></table></figure>

<h4 id="9-Comparable-Comparator-接口"><a href="#9-Comparable-Comparator-接口" class="headerlink" title="9. Comparable/Comparator 接口"></a>9. Comparable/Comparator 接口</h4><blockquote>
<p><strong>Comparable和Comparator的区别：</strong></p>
<ul>
<li>Comparable：自己(this)和别人(参数)比较,在源代码类中需要实现Comparable接口，重写比较的规则compareTo方法，耦合度太高</li>
<li>Comparator：在需要做排序的时候去选择的Comparator，相当于找一个第三方的裁判</li>
<li>排序规则：this - 参数：升序；参数 - this：降序</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparable使用示例，在源码类中实现Comparable接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">People</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">People</span>&gt; </span>&#123;</span><br><span class="line">    String name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(People o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age - o.age;</span><br><span class="line">    &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator使用示例，在Collections.sort方法中实现Comparator接口的匿名内部类</span></span><br><span class="line"> Collections.sort(list, <span class="keyword">new</span> Comparator&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(People o1, People o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1.age - o2.age;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Comparator如果想实现更多规则，示例如下：</span></span><br><span class="line">Collections.sort(list, <span class="keyword">new</span> Comparator&lt;People&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(People o1, People o2)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> result =  o1.age - o2.age;</span><br><span class="line">                <span class="keyword">if</span> (o1.age - o2.age == <span class="number">0</span>) &#123;</span><br><span class="line">                    result = o1.name.charAt(<span class="number">0</span>) - o2.name.charAt(<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure>

<h2 id="【Map、Debug】"><a href="#【Map、Debug】" class="headerlink" title="【Map、Debug】"></a>【Map、Debug】</h2><h4 id="1-Map接口"><a href="#1-Map接口" class="headerlink" title="1. Map接口"></a>1. Map接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Collection 中的集合称为单列集合， Map 中的集合称为双列集合。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>特点：</p>
<ol>
<li>是一个双列集合，一个元素包含两个值（一个key，一个value）</li>
<li>Map集合中的元素，key和value的数据类型可以相同，也可以不同</li>
<li>Map集合中的元素，key是不允许重复的，value是可以重复的</li>
<li>Map集合中的元素，key和value是一一对应的</li>
</ol>
</blockquote>
<h4 id="2-Map的常用子类"><a href="#2-Map的常用子类" class="headerlink" title="2. Map的常用子类"></a>2. Map的常用子类</h4><blockquote>
<p><strong>HashMap：</strong>存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需<br>要重写键的hashCode()方法、equals()方法。</p>
<p><strong>LinkedHashMap：</strong>存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。</p>
<p><strong>HashTable：</strong>底层也是一个哈希表，是一个线程安全的集合，单线程集合，速度慢。不能存储空值，空键。Hashtable和Vector集合一样，在jdk1.2版本之后被更先进的集合取代了。</p>
</blockquote>
<h4 id="3-Map的常用方法"><a href="#3-Map的常用方法" class="headerlink" title="3. Map的常用方法"></a>3. Map的常用方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> : 把指定的键与指定的值添加到Map集合中。</span></span><br><span class="line"><span class="function"><span class="comment">//返回值V的说明：存储键值对的时候，key不重复，返回值V是null;key重复，会使用新的value替换map中重复的value，返回被替换的value值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> : 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。如果不存在指定的键，则返回空。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> 根据指定的键，在Map集合中获取对应的值。如果不存在指定的键，则返回空。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">containsKey</span><span class="params">(Object key)</span>: 集合中是否包含指定的键</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;K&gt; <span class="title">keySet</span><span class="params">()</span> : 获取Map集合中所有的键，存储到Set集合中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span> : 获取到Map集合中所有的键值对对象的集合<span class="params">(Set集合)</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Entry键值对对象"><a href="#4-Entry键值对对象" class="headerlink" title="4. Entry键值对对象"></a>4. Entry键值对对象</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一对key(键)+value(值)称做Map中的一个Entry(项)，Entry将键值对的对应关系封装成了对象，即键值对对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Entry相关方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> K <span class="title">getKey</span><span class="params">()</span> ：获取Entry对象中的键。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">getValue</span><span class="params">()</span> ：获取Entry对象中的值。</span></span><br><span class="line"><span class="function">在Map集合中也提供了获取所有Entry对象的方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; <span class="title">entrySet</span><span class="params">()</span> : 获取到Map集合中所有的键值对对象的集合<span class="params">(Set集合)</span>。</span></span><br></pre></td></tr></table></figure>

<h4 id="5-Map的两种遍历方式"><a href="#5-Map的两种遍历方式" class="headerlink" title="5. Map的两种遍历方式"></a>5. Map的两种遍历方式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Map&lt;Integer, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        map.put(<span class="number">1</span>, <span class="string">"one"</span>);</span><br><span class="line">        map.put(<span class="number">2</span>, <span class="string">"two"</span>);</span><br><span class="line">        map.put(<span class="number">3</span>, <span class="string">"thr"</span>);</span><br><span class="line">		<span class="comment">//keySet遍历方式</span></span><br><span class="line">        <span class="keyword">for</span> (Integer key : map.keySet()) &#123;</span><br><span class="line">            System.out.println(key + <span class="string">" = "</span> + map.get(key));</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//entrySet遍历方式（更快）</span></span><br><span class="line">  		Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet();</span><br><span class="line">        <span class="keyword">for</span> (Map.Entry&lt;Integer, String&gt; entry : entries) &#123;</span><br><span class="line">            System.out.println(entry.getKey + <span class="string">"="</span> + entry.getValue());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-JDK9对集合添加的优化"><a href="#6-JDK9对集合添加的优化" class="headerlink" title="6. JDK9对集合添加的优化"></a>6. JDK9对集合添加的优化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java 9给List接口，Set接口和Map接口增加了一个静态的方法of，可以给集合一次性添加多个元素。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloJDK9</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">		Set&lt;String&gt; str1=Set.of(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>);</span><br><span class="line">		<span class="comment">//str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合</span></span><br><span class="line">		System.out.println(str1);</span><br><span class="line">		Map&lt;String,Integer&gt; str2=Map.of(<span class="string">"a"</span>,<span class="number">1</span>,<span class="string">"b"</span>,<span class="number">2</span>);</span><br><span class="line">		System.out.println(str2);</span><br><span class="line">		List&lt;String&gt; str3=List.of(<span class="string">"a"</span>,<span class="string">"b"</span>);</span><br><span class="line">		System.out.println(str3);</span><br><span class="line">	&#125;&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>注意：</strong></p>
<ol>
<li>of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如<br>HashSet，ArrayList等；</li>
<li>of方法的返回值时一个不能改变的集合，集合不能再使用add,put方法添加元素，会抛出异常；</li>
<li>Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常</li>
</ol>
</blockquote>
<h4 id="7-Debug追踪"><a href="#7-Debug追踪" class="headerlink" title="7. Debug追踪"></a>7. Debug追踪</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用IDEA的断点调试功能，可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>使用方式：</strong></p>
<ol>
<li>在行号的右边，鼠标左键单击，添加断点（哪里有bug添加到哪里）</li>
<li>右键选择Debug执行程序</li>
<li>程序就会停留在添加的第一个断点处</li>
</ol>
<p><strong>执行程序：</strong></p>
<ul>
<li>F7：逐句执行程序（进入到方法中）</li>
<li>F8：逐行执行程序（不进入方法中）</li>
<li>Shift + F8：跳出方法</li>
<li>F9：跳到下一个断点，如果没有下一个断点，那么就结束程序</li>
<li>Ctrl + F2：退出Debug模式，停止程序</li>
</ul>
</blockquote>
<h2 id="【异常、线程】"><a href="#【异常、线程】" class="headerlink" title="【异常、线程】"></a>【异常、线程】</h2><h4 id="1-异常"><a href="#1-异常" class="headerlink" title="1. 异常"></a>1. 异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处</span><br><span class="line">理异常的方式是中断处理。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行。</p>
</blockquote>
<h4 id="2-Throwable体系"><a href="#2-Throwable体系" class="headerlink" title="2. Throwable体系"></a>2. Throwable体系</h4><blockquote>
<ul>
<li><strong>Error</strong>：严重错误，无法通过处理的错误，只能事先避免，好比绝症。（内存不够用或和系统相关）</li>
<li><strong>Exception</strong>：异常，产生后程序员可以通过代码的方式纠正，使程序继续运行，好比感冒。</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Throwable常用方法：</span></span><br><span class="line"><span class="function">String <span class="title">getMessage</span><span class="params">()</span>：返回此throwable的简短描述,一般用于提示给用户</span></span><br><span class="line"><span class="function">String <span class="title">toString</span><span class="params">()</span>：返回此throwable的详细消息字符串</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printStackTrace</span><span class="params">()</span>:JVM打印异常对象，默认此方法，信息是最全面的，用于开发和调试阶段</span></span><br></pre></td></tr></table></figure>

<h4 id="3-异常的分类"><a href="#3-异常的分类" class="headerlink" title="3. 异常的分类"></a>3. 异常的分类</h4><blockquote>
<ul>
<li>编译时期异常：必须要处理。在编译时期就会检查，如果没有处理异常，则编译失败。</li>
<li>运行时期异常：可以不处理。在运行时期检查异常，在编译时期，运行异常不会被编译器报错。</li>
</ul>
</blockquote>
<h4 id="4-异常产生过程解析"><a href="#4-异常产生过程解析" class="headerlink" title="4. 异常产生过程解析"></a>4. 异常产生过程解析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义一个对给定的数组通过给定的索引获取元素的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getElement</span><span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> element = arr[index];</span><br><span class="line">	<span class="keyword">return</span> element;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 在主方法中调用getElement方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">	intnum = ArrayTools.getElement(arr, <span class="number">4</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>过程解析：getElement方法由于没有找到4索引，导致运行发生了异常，接下来JVM会：</p>
<ol>
<li>Jvm会根据异常产生的原因创建一个异常对象，这个对象包含了异常产生的（内容，原因，位置） new ArrayIndexOutOfBoundsException(“4”);</li>
<li>在getElement方法中，没有异常的处理逻辑（try…catch），那么JVM就会把异常对象抛出给方法的调用者main方法来处理这个异常</li>
<li>main方法接受后也没有处理异常的逻辑，继续把对象抛给main方法的调用者JVM处理</li>
<li>JVM收到这个异常对象，做了两件事：<ul>
<li>把异常对象（内容、原因、位置）以红色的字体打印在控制台</li>
<li>JVM会终止当前正在执行的Java程序—&gt;中断处理</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="5-throw关键字"><a href="#5-throw关键字" class="headerlink" title="5. throw关键字"></a>5. throw关键字</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span>用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。例如：</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"要访问的arr数组不存在"</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> ArrayIndexOutOfBoundsException(<span class="string">"该索引在数组中不存在，已超出范围"</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>throw将异常抛出，也就是将问题返回给该方法的调用者。对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用<strong>throws</strong>声明处理。</p>
</blockquote>
<blockquote>
<p>注意：</p>
<ol>
<li>throw关键字必须写在方法的内部</li>
<li>throw关键字后边new的对象必须是Exception或者Exception的子类对象</li>
<li>throw关键字抛出RuntimeException或者是其子类对象，我们可以不处理，默认交给JVM处理</li>
<li>throw关键字后边创建的是编译异常，我们就必须处理这个异常（try…catch）</li>
</ol>
</blockquote>
<h4 id="6-Objects非空判断"><a href="#6-Objects非空判断" class="headerlink" title="6. Objects非空判断"></a>6. Objects非空判断</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">T <span class="title">requireNonNull</span><span class="params">(T obj)</span> :查看指定引用对象不是<span class="keyword">null</span></span></span><br><span class="line"><span class="function"><span class="comment">//源码：</span></span></span><br><span class="line"><span class="function">	<span class="title">if</span> <span class="params">(obj == <span class="keyword">null</span>)</span></span></span><br><span class="line"><span class="function">		throw new <span class="title">NullPointerException</span><span class="params">()</span>  </span>;</span><br><span class="line">	<span class="keyword">return</span> obj;</span><br></pre></td></tr></table></figure>

<h4 id="7-throws声明异常"><a href="#7-throws声明异常" class="headerlink" title="7. throws声明异常"></a>7. throws声明异常</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">声明异常：如果方法内通过throw抛出编译时异常，而没有捕获处理，那么必须通过throws进行声明，将问题标识出来。</span><br><span class="line">抛出异常：关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	read(<span class="string">"a.txt"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span><span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!path.equals(<span class="string">"b.txt"</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>子父类的异常：子类抛出的异常在数量和继承关系上不能超出父类</p>
</blockquote>
<h4 id="8-try…catch捕获异常"><a href="#8-try…catch捕获异常" class="headerlink" title="8. try…catch捕获异常"></a>8. try…catch捕获异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型 e)&#123;</span><br><span class="line">	处理异常的代码</span><br><span class="line">	<span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		read(<span class="string">"b.txt"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		System.out.println(e);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(String path)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!path.equals(<span class="string">"a.txt"</span>)) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"文件不存在"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-finally代码块"><a href="#9-finally代码块" class="headerlink" title="9. finally代码块"></a>9. finally代码块</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">因为异常会引发程序跳转，导致有些语句执行不到。但有一些特定的代码必须执行，将这些代码放在finally代码块中是一定会被执行的。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		read(<span class="string">"a.txt"</span>);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		<span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		System.out.println(<span class="string">"不管程序怎样，这里都将会被执行。"</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	System.out.println(<span class="string">"over"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ul>
<li>finally不能单独使用。</li>
<li>如果finally有return语句,永远返回finally中的结果,避免该情况。</li>
<li>当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。</li>
</ul>
</blockquote>
<h4 id="10-多个异常使用捕获"><a href="#10-多个异常使用捕获" class="headerlink" title="10. 多个异常使用捕获"></a>10. 多个异常使用捕获</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一般多个异常一次捕获，多次处理。</span></span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">	编写可能会出现异常的代码</span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型A e)&#123; 当<span class="keyword">try</span>中出现A类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">	处理异常的代码</span><br><span class="line">	<span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;<span class="keyword">catch</span>(异常类型B e)&#123; 当<span class="keyword">try</span>中出现B类型异常,就用该<span class="keyword">catch</span>来捕获.</span><br><span class="line">	处理异常的代码</span><br><span class="line">	<span class="comment">//记录日志/打印异常信息/继续抛出异常</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异<br>常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。</p>
</blockquote>
<h4 id="11-自定义异常"><a href="#11-自定义异常" class="headerlink" title="11. 自定义异常"></a>11. 自定义异常</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">XXXException</span> <span class="keyword">extends</span> <span class="title">Exception</span>/<span class="title">RuntimeException</span></span>&#123;</span><br><span class="line">	<span class="comment">//空参数的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XXXException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//添加一个带异常信息的构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">XXXException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">		<span class="keyword">super</span>(message);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>自定义异常类一般都是以Exception结尾，说明该类是一个异常类</li>
<li>所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法</li>
<li>自定义异常类，必须继承Exception/RuntimeException<ul>
<li>继承RuntimeException：那么就是一个运行期异常，无需处理，交给虚拟机</li>
<li>继承Exception：那么就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch</li>
</ul>
</li>
</ol>
</blockquote>
<h4 id="12-并发与并行"><a href="#12-并发与并行" class="headerlink" title="12. 并发与并行"></a>12. 并发与并行</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">并发：指两个或多个事件在同一个时间段内发生（交替执行）。</span><br><span class="line">并行：指两个或多个事件在同一时刻发生（同时执行）。</span><br></pre></td></tr></table></figure>

<h4 id="13-线程与进程"><a href="#13-线程与进程" class="headerlink" title="13. 线程与进程"></a>13. 线程与进程</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程：一个应用程序可以同时运行多个进程，每个进程都有一个独立的内存空间，是系统运行程序的基本单位。</span><br><span class="line">线程：是CPU和任务之间的执行通道，是任务的执行单元，一个进程中可以有多个线程。</span><br><span class="line">一个应用程序可以有多个进程，一个进程可以有多个线程。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>线程调度：</p>
<ul>
<li>分时调度：<br>所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。</li>
<li>抢占式调度：<br>优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。</li>
</ul>
</blockquote>
<h2 id="【线程、同步】"><a href="#【线程、同步】" class="headerlink" title="【线程、同步】"></a>【线程、同步】</h2><h4 id="1-Thread类"><a href="#1-Thread类" class="headerlink" title="1. Thread类"></a>1. Thread类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> :分配一个新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(String name)</span> :分配一个指定名字的新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target)</span> :分配一个带有指定目标新的线程对象。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">(Runnable target,String name)</span> :分配一个带有指定目标新的线程对象并指定名字。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常用方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> :获取当前线程名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> :导致此线程开始执行</span>; Java虚拟机调用此线程的run方法。</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> :此线程要执行的任务在此处定义代码。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sleep</span><span class="params">(<span class="keyword">long</span> millis)</span> :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Thread <span class="title">currentThread</span><span class="params">()</span> :返回对当前正在执行的线程对象的引用。</span></span><br></pre></td></tr></table></figure>

<h4 id="2-创建线程-继承Thread类"><a href="#2-创建线程-继承Thread类" class="headerlink" title="2. 创建线程-继承Thread类"></a>2. 创建线程-继承Thread类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建多线程的第一种方式：创建Thread类的子类</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现步骤：</p>
<ol>
<li>创建一个Thread类的子类，并重写Thread类中的run方法，设置线程任务</li>
<li>创建Thread类的子类对象</li>
<li>调用线程对象的start()方法，开启新的线程，执行run方法</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//创建Thread类的子类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">		System.out.println(getName()+<span class="string">"：正在执行！"</span>+i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">	mt.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-创建线程-Runnable接口"><a href="#3-创建线程-Runnable接口" class="headerlink" title="3. 创建线程-Runnable接口"></a>3. 创建线程-Runnable接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">创建多线程的第二种方式：Thread构造器实现Runnable接口</span><br></pre></td></tr></table></figure>

<blockquote>
<p>实现步骤：</p>
<ol>
<li>创建一个Runnable接口的实现类</li>
<li>在实现类中重写Runnable接口的run方法，设置线程任务</li>
<li>创建一个Runnable接口的实现类对象</li>
<li>创建Thread类对象，构造方法中传递Runnable接口的实现类对象</li>
<li>调用Thread类中的start方法，开启新的线程执行run方法</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">//创建Runnable接口的实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; i++) &#123;</span><br><span class="line">			System.out.println(Thread.currentThread().getName()+<span class="string">" "</span>+i);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	MyRunnable mr = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">	Thread t = <span class="keyword">new</span> Thread(mr);</span><br><span class="line">	t.start();</span><br><span class="line">&#125;<span class="comment">//也可以使用匿名内部类方式实现线程的创建</span></span><br></pre></td></tr></table></figure>

<h4 id="4-Runnable接口具有的优势"><a href="#4-Runnable接口具有的优势" class="headerlink" title="4. Runnable接口具有的优势"></a>4. Runnable接口具有的优势</h4><ol>
<li>适合多个相同的程序代码的线程去共享同一个资源。</li>
<li>可以避免java中的单继承的局限性。</li>
<li>增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。</li>
<li>线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。</li>
</ol>
<h4 id="5-线程安全"><a href="#5-线程安全" class="headerlink" title="5. 线程安全"></a>5. 线程安全</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">当多个线程对象访问同一个资源，并且多个线程中对资源有写的操作，就容易产生线程安全问题。</span><br></pre></td></tr></table></figure>

<h4 id="6-同步代码块"><a href="#6-同步代码块" class="headerlink" title="6. 同步代码块"></a>6. 同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> 关键字可以用于方法中的某个区块中，表示对这个区块的资源实行互斥访问。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	Object lock = <span class="keyword">new</span> Object();</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			<span class="keyword">synchronized</span> (lock) &#123;  <span class="comment">//对卖票的操作进行锁</span></span><br><span class="line">				<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">					String name = Thread.currentThread().getName();</span><br><span class="line">					System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>同步锁：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁</strong></p>
<ol>
<li>锁对象可以是任意类型。</li>
<li>多个线程对象要使用同一把锁。</li>
<li>在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着。</li>
</ol>
</blockquote>
<h4 id="7-同步方法"><a href="#7-同步方法" class="headerlink" title="7. 同步方法"></a>7. 同步方法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用synchronized修饰的方法，就叫做同步方法，保证一个线程执行该方法的时候，其他线程只能在方法外等着。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">		sellTicket();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">sellTicket</span><span class="params">()</span></span>&#123;</span><br><span class="line">		<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">			String name = Thread.currentThread().getName();</span><br><span class="line">			System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>同步锁是谁?</strong></p>
<p>对于非static方法，同步锁就是<strong>this</strong>。</p>
<p>对于static方法，我们使用当前方法所在类的<strong>字节码对象</strong>(类名.class)。</p>
</blockquote>
<h4 id="8-Lock锁"><a href="#8-Lock锁" class="headerlink" title="8. Lock锁"></a>8. Lock锁</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外Lock更强大,更体现面向对象。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Ticket</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> ticket = <span class="number">100</span>;</span><br><span class="line">	Lock lock = <span class="keyword">new</span> ReentrantLock();	<span class="comment">//1.创建锁对象</span></span><br><span class="line">	<span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="keyword">while</span>(<span class="keyword">true</span>)&#123;</span><br><span class="line">			lock.lock();	<span class="comment">//2.加同步锁</span></span><br><span class="line">			<span class="keyword">if</span>(ticket&gt;<span class="number">0</span>)&#123;</span><br><span class="line">				String name = Thread.currentThread().getName();</span><br><span class="line">				System.out.println(name+<span class="string">"正在卖:"</span>+ticket‐‐);</span><br><span class="line">			&#125;</span><br><span class="line">			lock.unlock();	<span class="comment">//3.释放同步锁</span></span><br></pre></td></tr></table></figure>

<h4 id="9-六种线程状态"><a href="#9-六种线程状态" class="headerlink" title="9. 六种线程状态"></a>9. 六种线程状态</h4><table>
<thead>
<tr>
<th align="left">线程状态</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">新建状态(New)</td>
<td align="left">线程刚被创建，但是还没调用start方法启动。</td>
</tr>
<tr>
<td align="left">运行状态(Runnable)</td>
<td align="left">线程可以在java虚拟机中运行的状态。</td>
</tr>
<tr>
<td align="left">阻塞状态(Blockd)</td>
<td align="left">当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态。</td>
</tr>
<tr>
<td align="left">计时等待状态(Timed waiting)</td>
<td align="left">一个线程在等待另一个线程调用notify或者notifyAll方法（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的。</td>
</tr>
<tr>
<td align="left">无限等待状态(Waiting)</td>
<td align="left">同waiting状态，这一状态将一直保持到超时期满或者接收到唤醒通知。</td>
</tr>
<tr>
<td align="left">死亡状态(Terminated)</td>
<td align="left">因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</td>
</tr>
</tbody></table>
<h4 id="10-等待与唤醒方法"><a href="#10-等待与唤醒方法" class="headerlink" title="10. 等待与唤醒方法"></a>10. 等待与唤醒方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">进入到TimeWaiting(计时等待)有两种方式：</span><br><span class="line">    <span class="number">1</span>. sleep(<span class="keyword">long</span> m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态。sleep方法使用后线程失</span><br><span class="line">    去CPU执行权，但仍然拥有锁对象。</span><br><span class="line">    <span class="number">2</span>. wait(<span class="keyword">long</span> m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到</span><br><span class="line">    Runnable/Blocked状态。wait方法同时释放锁对象和cpu执行权。</span><br><span class="line">唤醒的两种方式:</span><br><span class="line">	<span class="number">1</span>. <span class="function"><span class="keyword">void</span> <span class="title">notify</span><span class="params">()</span> 唤醒在此对象监视器上等待的单个线程。</span></span><br><span class="line"><span class="function">	2. <span class="keyword">void</span> <span class="title">notifyAll</span><span class="params">()</span> 唤醒在此对象监视器上等待的所有线程。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>wait和notify方法是来源于Object类，不是Thread类，等待和唤醒都是Object的方法</p>
</blockquote>
<h2 id="【线程池、Lambda表达式】"><a href="#【线程池、Lambda表达式】" class="headerlink" title="【线程池、Lambda表达式】"></a>【线程池、Lambda表达式】</h2><h4 id="1-等待唤醒机制"><a href="#1-等待唤醒机制" class="headerlink" title="1. 等待唤醒机制"></a>1. 等待唤醒机制</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个线程进行了规定操作后，通过wait()方法进入等待状态，等待其他线程执行完他们的指定代码过后再通过notify()方法将其唤醒，是线程间的一种协作机制。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<ol>
<li>wait方法与notify方法必须要由同一个锁对象调用。</li>
<li>wait方法与notify方法必须要在同步代码块或者是同步函数中使用，因为要通过锁对象调用这2个方法。</li>
<li>被唤醒的线程不一定能立即恢复执行，需要再次获取锁后才能在从 wait() 方法之后的地方恢复执行。</li>
</ol>
</blockquote>
<h4 id="2-线程池"><a href="#2-线程池" class="headerlink" title="2. 线程池"></a>2. 线程池</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>线程池的好处：</strong></p>
<ol>
<li>降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。</li>
<li>提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li>提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>线程池使用步骤：</strong></p>
<ol>
<li>用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池</li>
<li>创建一个类，实现Runnable接口，重写run方法，设置线程任务</li>
<li>调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法</li>
<li>调用ExecutorService中的方法shutdown销毁线程池(不建议执行)</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码展示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService es = Executors.newFixedThreadPool(<span class="number">3</span>);</span><br><span class="line">        es.submit(() -&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">    	es.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Lambda表达式"><a href="#3-Lambda表达式" class="headerlink" title="3. Lambda表达式"></a>3. Lambda表达式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lambda表达式的标准格式为：(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>使用前提：</p>
<ol>
<li>必须有<strong>函数式接口</strong>——只包含一个抽象方法的接口</li>
<li>必须有上下文引用（必须有接口作为数据类型接收）</li>
</ol>
</blockquote>
<blockquote>
<p>省略格式（<strong>可推导,可省略</strong>）：</p>
<ol>
<li>小括号内参数的类型可以省略；</li>
<li>如果小括号内有且仅有一个参，则小括号可以省略；</li>
<li>如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//重写Runnable接口    </span></span><br><span class="line">    <span class="keyword">new</span> Thread(() -&gt; System.out.println(<span class="string">"创建并执行线程"</span>)).start(); </span><br><span class="line">    <span class="comment">//重写Comparator接口，降序排序	</span></span><br><span class="line">    Collections.sort(list,(o1, o2) -&gt; o2 - o1);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="【File类、递归】"><a href="#【File类、递归】" class="headerlink" title="【File类、递归】"></a>【File类、递归】</h2><h4 id="1-File类"><a href="#1-File类" class="headerlink" title="1. File类"></a>1. File类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。</span><br><span class="line">File类的实例是不可变的，一旦创建，File对象表示的抽象路径名将永不改变</span><br></pre></td></tr></table></figure>

<h5 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String pathname)</span> ：通过将给定的路径名字符串创建新的 File实例。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(String parent, String child)</span> ：父路径名字符串+子路径名字符串创建新的File实例。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">File</span><span class="params">(File parent, String child)</span> ：从父File实例路径名+子路径名字符串创建新的File实例。</span></span><br></pre></td></tr></table></figure>

<h5 id="获取的方法"><a href="#获取的方法" class="headerlink" title="获取的方法"></a>获取的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getAbsolutePath</span><span class="params">()</span> ：返回此File的绝对路径名字符串。</span></span><br><span class="line"><span class="function"><span class="comment">//File对象的toString方法调用的就是getPath()方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPath</span><span class="params">()</span> ：将此File转换为路径名字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> ：返回由此File表示的文件或目录的名称。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">length</span><span class="params">()</span> ：返回由此File表示的文件的长度。</span></span><br></pre></td></tr></table></figure>

<h5 id="判断的方法"><a href="#判断的方法" class="headerlink" title="判断的方法"></a>判断的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">exists</span><span class="params">()</span> ：此File表示的文件或目录是否实际存在。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDirectory</span><span class="params">()</span> ：此File表示的是否为目录。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isFile</span><span class="params">()</span> ：此File表示的是否为文件。</span></span><br></pre></td></tr></table></figure>

<h5 id="创建删除的方法"><a href="#创建删除的方法" class="headerlink" title="创建删除的方法"></a>创建删除的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">createNewFile</span><span class="params">()</span> ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">delete</span><span class="params">()</span> ：删除由此File表示的文件或目录，目录项下有内容的话无法删除。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdir</span><span class="params">()</span> ：创建由此File表示的目录。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">mkdirs</span><span class="params">()</span> ：创建由此File表示的目录，包括任何必需但不存在的父目录。</span></span><br></pre></td></tr></table></figure>

<h5 id="遍历的方法"><a href="#遍历的方法" class="headerlink" title="遍历的方法"></a>遍历的方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。</span><br><span class="line"><span class="keyword">public</span> File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。</p>
</blockquote>
<h4 id="2-绝对路径和相对路径"><a href="#2-绝对路径和相对路径" class="headerlink" title="2. 绝对路径和相对路径"></a>2. 绝对路径和相对路径</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">绝对路径：从盘符开始的路径，这是一个完整的路径。</span><br><span class="line">相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>File.pathSeparator</code>：获取当前系统路径分隔符；（Windows用” <strong>;</strong> “    Linux用” <strong>:</strong> “）<br><code>File.separator</code>：获取当前系统文件名称分隔符；（Windows用”<strong>反斜杠\</strong>“    Linux用”<strong>正斜杠/</strong>“）</p>
</blockquote>
<h4 id="3-递归"><a href="#3-递归" class="headerlink" title="3. 递归"></a>3. 递归</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">递归：指在当前方法内调用自己的这种现象。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意事项：</p>
<ol>
<li>递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。(StackOverflowError)</li>
<li>在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。(StackOverflowError)</li>
<li>构造方法,禁止递归。</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 #暴力删除#</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deleteAll</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (f.exists()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (f.isDirectory()) &#123;</span><br><span class="line">                <span class="keyword">for</span> (File file : f.listFiles()) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (file.isFile()) &#123;</span><br><span class="line">                        file.delete();</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        deleteAll(file);</span><br><span class="line">                    &#125;&#125;&#125;</span><br><span class="line">            f.delete();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"该路径不是有效路径"</span>);</span><br><span class="line">        &#125;&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示 #阶乘#</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">factorial</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>  <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码演示 #内存容量测试#</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        b(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">b</span><span class="params">(<span class="keyword">int</span> i)</span></span>&#123;</span><br><span class="line">        System.out.println(i);</span><br><span class="line">        b(++i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-文件过滤器"><a href="#4-文件过滤器" class="headerlink" title="4. 文件过滤器"></a>4. 文件过滤器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> File[] listFiles():返回指定目录中的子目录和文件。</span><br><span class="line"><span class="keyword">public</span> File[] listFiles(FileFilter filter):返回指定目录中符合自定义规则的子目录和文件。</span><br><span class="line">FileFilter接口中抽象方法：</span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> 测试指定格式路径名是否包含在某个路径名列表中。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File[] <span class="title">listFiles</span><span class="params">(FilenameFilter filter)</span>:返回指定目录中指定文件。</span></span><br><span class="line"><span class="function">FilenameFilter接口中抽象方法：</span></span><br><span class="line"><span class="function">	<span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File dir, String name)</span> 测试指定文件是否应该包含在某一文件列表中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个方法，输出文件夹里的所有的java文件</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">showJava</span><span class="params">(File f)</span> </span>&#123;</span><br><span class="line">        File[] files = f.listFiles(pathname-&gt;pathname.isDirectory()||</span><br><span class="line">                                   pathname.getName().toLowerCase().endsWith(<span class="string">".java"</span>));</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file.isDirectory()) &#123;</span><br><span class="line">                showJava(file);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(file.getAbsolutePath());</span><br><span class="line">            &#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【字节流、字符流】"><a href="#【字节流、字符流】" class="headerlink" title="【字节流、字符流】"></a>【字节流、字符流】</h2><h4 id="1-IO流"><a href="#1-IO流" class="headerlink" title="1. IO流"></a>1. IO流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入流 ：把数据从其他设备上读取到【内存中】的流。</span><br><span class="line">输出流 ：把数据从【内存中】写出到其他设备上的流。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">顶级父类们</th>
<th align="center">输入流</th>
<th align="center">输出流</th>
</tr>
</thead>
<tbody><tr>
<td align="center">字节流</td>
<td align="center">字节输入流【InputStream】</td>
<td align="center">字节输出流【OutputStream】</td>
</tr>
<tr>
<td align="center">字符流</td>
<td align="center">字符输入流【Reader】</td>
<td align="center">字符输出流【Writer】</td>
</tr>
</tbody></table>
<h4 id="2-字节输出流【OutputStream】"><a href="#2-字节输出流【OutputStream】" class="headerlink" title="2. 字节输出流【OutputStream】"></a>2. 字节输出流【OutputStream】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//OutputStream 基本方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此输出流并释放与此流相关联的任何系统资源。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> ：刷新此输出流并强制任何缓冲的输出字节被写出。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b)</span> ：将 b.length字节从指定的字节数组写入此输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] b, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileOutputStream"><a href="#FileOutputStream" class="headerlink" title="FileOutputStream"></a>FileOutputStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法：true 表示追加数据， false 表示清空原有数据</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(String name, <span class="keyword">boolean</span> append)</span> ： 创建文件输出流以指定的名称写入文件。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FileOutputStream</span><span class="params">(File file, <span class="keyword">boolean</span> append)</span> ：创建文件输出流以写入由指定的File对象表示的文件。</span></span><br></pre></td></tr></table></figure>

<h4 id="3-字节输入流【InputStream】"><a href="#3-字节输入流【InputStream】" class="headerlink" title="3. 字节输入流【InputStream】"></a>3. 字节输入流【InputStream】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//InputStream 基本方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此输入流并释放与此流相关联的任何系统资源。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ： 从输入流读取数据的下一个字节。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span>[] b)</span> ： 从输入流中读取一些字节数，并将它们存储到字节数组b中，返回读取的字节数。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileInputStream"><a href="#FileInputStream" class="headerlink" title="FileInputStream"></a>FileInputStream</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileInputStream (File file)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的File对象file命名。</span><br><span class="line">FileInputStream (String name)：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名name命名。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件复制代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">//创建输入输出流对象</span></span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src.jpg"</span>);</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"des.jpg"</span>);</span><br><span class="line">        <span class="comment">//创建容器</span></span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="comment">//读取源文件</span></span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="comment">//输出文件</span></span><br><span class="line">            fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//释放资源</span></span><br><span class="line">        fos.close();</span><br><span class="line">        fis.close();</span><br></pre></td></tr></table></figure>

<h4 id="4-字符输入流【Reader】"><a href="#4-字符输入流【Reader】" class="headerlink" title="4. 字符输入流【Reader】"></a>4. 字符输入流【Reader】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Reader 基本方法：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> ：关闭此流并释放与此流相关联的任何系统资源。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> ： 从输入流读取一个字符。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> ： 从输入流中读取一些字符，并将它们存储到字符数组cbuf中 。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileReader"><a href="#FileReader" class="headerlink" title="FileReader"></a>FileReader</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileReader(File file)：创建一个新的 FileReader，给定要读取的File对象。</span><br><span class="line">FileReader(String fileName)：创建一个新的 FileReader，给定要读取的文件的名称。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileReader fr = <span class="keyword">new</span> FileReader(<span class="string">"a.txt"</span>);</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = fr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(chars,<span class="number">0</span>,len));</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-字符输出流【Writer】"><a href="#5-字符输出流【Writer】" class="headerlink" title="5. 字符输出流【Writer】"></a>5. 字符输出流【Writer】</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Writer 基本方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> 刷新该流的缓冲。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> 关闭此流，但会自动先刷新它。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> c)</span> 写入单个字符。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf)</span> 写入字符数组。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">char</span>[] cbuf, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 写入字符数组的某一部分,off数组的开始索引,len字符个数。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str)</span> 写入字符串。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(String str, <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> 写入字符串的某一部分,off字符串的开始索引,len字符个数。</span></span><br></pre></td></tr></table></figure>

<h5 id="FileWriter"><a href="#FileWriter" class="headerlink" title="FileWriter"></a>FileWriter</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">FileWriter(File file)：创建一个新的 FileWriter，给定要读取的File对象。</span><br><span class="line">FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：</p>
<p>使用FileWriter中的方法write，是把数据写入到内存缓冲区中，需要刷新缓冲区，才能将数据保存到文件中。</p>
<ul>
<li>flush ：刷新缓冲区，流对象可以继续使用。</li>
<li>close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。</li>
</ul>
</blockquote>
<h4 id="6-IO异常的处理"><a href="#6-IO异常的处理" class="headerlink" title="6. IO异常的处理"></a>6. IO异常的处理</h4><h5 id="JDK7前处理"><a href="#JDK7前处理" class="headerlink" title="JDK7前处理"></a>JDK7前处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fw != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fw.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();&#125;&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK7的处理"><a href="#JDK7的处理" class="headerlink" title="JDK7的处理"></a>JDK7的处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK7优化后用()包裹流对象语句，确保每个流对象在结束使用后关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> ( FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>); ) &#123;</span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>); </span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h5 id="JDK9的改进"><a href="#JDK9的改进" class="headerlink" title="JDK9的改进"></a>JDK9的改进</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JDK9中使用引入对象的方式，同样可以确保每个流对象在结束使用后自动关闭</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileWriter fw = <span class="keyword">new</span> FileWriter(<span class="string">"fw.txt"</span>);</span><br><span class="line">        <span class="keyword">try</span> (fw) &#123;</span><br><span class="line">            fw.write(<span class="string">"黑马程序员"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="7-Properties类"><a href="#7-Properties类" class="headerlink" title="7. Properties类"></a>7. Properties类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.Properties继承于Hashtable，使用键值结构存储数据，每个键及其对应值都是一个字符串。</span><br><span class="line">可以方便地在双列集合和数据文件之间转换。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Properties</span><span class="params">()</span> :创建一个空的属性列表。</span></span><br><span class="line"><span class="function"><span class="comment">//存储方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">setProperty</span><span class="params">(String key, String value)</span>：添加一个键值对。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getProperty</span><span class="params">(String key)</span>：通过键获取对应的值。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">stringPropertyNames</span><span class="params">()</span>：获取所有键名称的集合。</span></span><br><span class="line"><span class="function"><span class="comment">//流相关方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">load</span><span class="params">(InputStream in)</span>：从字节输入流中读取键值对,生成Properties集合。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">store</span><span class="params">(OutputStream out,String comments)</span>：从Properties集合中获取键值对，输出到字节输出流的文件中。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> FileNotFoundException </span>&#123;</span><br><span class="line">    Properties pro = <span class="keyword">new</span> Properties();	<span class="comment">//创建Properties对象</span></span><br><span class="line">    pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"read.txt"</span>));	<span class="comment">//从read.txt中读取数据</span></span><br><span class="line">    pro.setProperty(<span class="string">"one"</span>, <span class="string">"111"</span>);	<span class="comment">//往对象中添加数据</span></span><br><span class="line">    Set&lt;String&gt; strings = pro.stringPropertyNames();	<span class="comment">//获取对象所有键名称的集合</span></span><br><span class="line">	<span class="keyword">for</span> (String key : strings ) &#123;	<span class="comment">//遍历集合并打印</span></span><br><span class="line">		System.out.println(key+<span class="string">" ‐‐ "</span>+pro.getProperty(key));</span><br><span class="line">	&#125;</span><br><span class="line">    pro.store(<span class="keyword">new</span> FileOutputStream(<span class="string">"write.txt"</span>),<span class="string">"Saving"</span>);	<span class="comment">//将对象的信息输出到文件中</span></span><br></pre></td></tr></table></figure>

<h2 id="【缓冲流、转换流、序列化流】"><a href="#【缓冲流、转换流、序列化流】" class="headerlink" title="【缓冲流、转换流、序列化流】"></a>【缓冲流、转换流、序列化流】</h2><h4 id="1-缓冲流"><a href="#1-缓冲流" class="headerlink" title="1. 缓冲流"></a>1. 缓冲流</h4><h5 id="字节缓冲流"><a href="#字节缓冲流" class="headerlink" title="字节缓冲流"></a>字节缓冲流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in)</span> ：创建一个 新的缓冲输入流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedOutputStream</span><span class="params">(OutputStream out)</span> ： 创建一个新的缓冲输出流。</span></span><br></pre></td></tr></table></figure>

<h5 id="字符缓冲流"><a href="#字符缓冲流" class="headerlink" title="字符缓冲流"></a>字符缓冲流</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedReader</span><span class="params">(Reader in)</span> ：创建一个 新的缓冲输入流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedWriter</span><span class="params">(Writer out)</span> ： 创建一个新的缓冲输出流。</span></span><br><span class="line"><span class="function"><span class="comment">//特有方法</span></span></span><br><span class="line"><span class="function">BufferedReader： <span class="keyword">public</span> String <span class="title">readLine</span><span class="params">()</span> : 读一行文字。</span></span><br><span class="line"><span class="function">BufferedWriter： <span class="keyword">public</span> <span class="keyword">void</span> <span class="title">newLine</span><span class="params">()</span> : 写一行行分隔符,由系统属性定义符号。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//通过缓冲流复制文件，代码演示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        BufferedOutputStream bos = </span><br><span class="line">            <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"des.jpg"</span>));</span><br><span class="line">        BufferedInputStream bis = </span><br><span class="line">            <span class="keyword">new</span> BufferedInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"src.jpg"</span>));</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            bos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        bos.close();</span><br><span class="line">        bis.close(); &#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-字符集"><a href="#2-字符集" class="headerlink" title="2. 字符集"></a>2. 字符集</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。</span><br></pre></td></tr></table></figure>

<blockquote>
<ul>
<li><strong>ASCII字符集</strong> ：基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。</li>
<li><strong>GBK</strong>：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了<br>21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。</li>
<li><strong>Unicode字符集</strong> ：为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国<br>码，其中最为常用的是UTF-8编码：<ol>
<li>128个US-ASCII字符，只需一个字节编码。</li>
<li>拉丁文等字符，需要二个字节编码。</li>
<li>大部分常用字（含中文），使用三个字节编码。</li>
<li>其他极少使用的Unicode辅助字符，使用四字节编码。</li>
</ol>
</li>
</ul>
</blockquote>
<h4 id="3-转换流"><a href="#3-转换流" class="headerlink" title="3. 转换流"></a>3. 转换流</h4><h5 id="InputStreamReader类"><a href="#InputStreamReader类" class="headerlink" title="InputStreamReader类"></a>InputStreamReader类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">转换流java.io.InputStreamReader ，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定</span><br><span class="line">的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。</span><br><span class="line">InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。</span><br></pre></td></tr></table></figure>

<h5 id="OutputStreamWriter类"><a href="#OutputStreamWriter类" class="headerlink" title="OutputStreamWriter类"></a>OutputStreamWriter类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符</span><br><span class="line">编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line">OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。</span><br><span class="line">OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将GBK编码的文件转换为UTF-8编码，代码演示：</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line">        OutputStreamWriter osw = </span><br><span class="line">            <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(<span class="string">"U8code.txt"</span>));</span><br><span class="line">        InputStreamReader isr = </span><br><span class="line">            <span class="keyword">new</span> InputStreamReader(<span class="keyword">new</span> FileInputStream(<span class="string">"GBKcode.txt"</span>), <span class="string">"GBK"</span>);</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">char</span>[] chars = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = isr.read(chars)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            osw.write(chars,<span class="number">0</span>,len);</span><br><span class="line">        &#125;</span><br><span class="line">        osw.close();</span><br><span class="line">        isr.close();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-序列化"><a href="#4-序列化" class="headerlink" title="4. 序列化"></a>4. 序列化</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Java提供了一种对象序列化的机制，使【内存中对象的数据】与【硬盘中文件里的数据】可以相互转化。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。</span><br></pre></td></tr></table></figure>

<h5 id="ObjectOutputStream类"><a href="#ObjectOutputStream类" class="headerlink" title="ObjectOutputStream类"></a>ObjectOutputStream类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectOutputStream</span><span class="params">(OutputStream out)</span>：创建一个指定OutputStream的序列化流对象。</span></span><br><span class="line"><span class="function"><span class="comment">//写出方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">writeObject</span> <span class="params">(Object obj)</span> : 将指定的对象写出。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>序列化操作注意事项：</strong></p>
<ol>
<li>要实现序列化的类必须实现<code>java.io.Serializable</code>接口，否则会抛出NotSerializableException异常。</li>
<li>被瞬态<code>transient</code>或静态<code>static</code>修饰的属性不会被序列化。</li>
</ol>
</blockquote>
<h5 id="ObjectInputStream类"><a href="#ObjectInputStream类" class="headerlink" title="ObjectInputStream类"></a>ObjectInputStream类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。</span><br><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ObjectInputStream</span><span class="params">(InputStream in)</span> ： 创建一个指定InputStream的ObjectInputStream。</span></span><br><span class="line"><span class="function"><span class="comment">//读取方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Object <span class="title">readObject</span> <span class="params">()</span> : 读取一个对象。</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>serialVersionUID序列版本号：</strong>Serializable 接口给需要序列化的类，提供了一个序列版本号，目的在于验证序列化的对象和对应类是否版本匹配。如果对类进行和修改，那么其序列标本号也会发生修改。可通过在类中写死序列版本号，使修改后的类依然能够匹配序列化的对象。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//序列化代码演示</span></span><br><span class="line"><span class="comment">//定义学生类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">8206478034432139083L</span>;</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//测试类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        <span class="comment">//序列化</span></span><br><span class="line">        ObjectOutputStream oos =</span><br><span class="line">                <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"Student.txt"</span>));</span><br><span class="line">        oos.writeObject(<span class="keyword">new</span> Student(<span class="string">"Eric"</span>, <span class="number">20</span>));</span><br><span class="line">        oos.close();</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">        ObjectInputStream ois =</span><br><span class="line">            <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"Student.txt"</span>));</span><br><span class="line">        Student stu = (Student)ois.readObject();</span><br><span class="line">        System.out.println(stu); <span class="comment">//Student&#123;name='Eric', age=20&#125;</span></span><br><span class="line">        ois.close();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-打印流"><a href="#5-打印流" class="headerlink" title="5. 打印流"></a>5. 打印流</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.io.PrintStream 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。</span><br></pre></td></tr></table></figure>

<h5 id="PrintStream类"><a href="#PrintStream类" class="headerlink" title="PrintStream类"></a>PrintStream类</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PrintStream</span><span class="params">(String fileName)</span> ： 使用指定的文件名创建一个新的打印流。</span></span><br><span class="line"><span class="function"><span class="comment">//改变打印流向</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	PrintStream ps = <span class="keyword">new</span> PrintStream(<span class="string">"ps.txt"</span>);</span><br><span class="line">	System.setOut(ps);</span><br><span class="line">	System.out.println(<span class="string">"Hello,World"</span>);&#125; <span class="comment">//在ps.txt中输出Hello,World</span></span><br></pre></td></tr></table></figure>



<h2 id="【网络编程】"><a href="#【网络编程】" class="headerlink" title="【网络编程】"></a>【网络编程】</h2><h4 id="1-软件结构"><a href="#1-软件结构" class="headerlink" title="1. 软件结构"></a>1. 软件结构</h4><ul>
<li>C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。</li>
<li>B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。</li>
</ul>
<h4 id="2-网络通信协议"><a href="#2-网络通信协议" class="headerlink" title="2. 网络通信协议"></a>2. 网络通信协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">分层</th>
<th align="center">协议</th>
</tr>
</thead>
<tbody><tr>
<td align="center">应用层</td>
<td align="center">HTTP/FTP/TFTP/SMTP/SNMP/DNS</td>
</tr>
<tr>
<td align="center">传输层</td>
<td align="center">TCP/UDP</td>
</tr>
<tr>
<td align="center">网络层</td>
<td align="center">ICMP/IGMP/IP/ARP/RARP</td>
</tr>
<tr>
<td align="center">数据链路层+物理层</td>
<td align="center">由底层网络定义的协议</td>
</tr>
</tbody></table>
<h4 id="3-TCP协议"><a href="#3-TCP协议" class="headerlink" title="3. TCP协议"></a>3. TCP协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，</span><br><span class="line">在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>三次握手建立连接：</strong>在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。</p>
<ol>
<li>客户端向服务器端发出连接请求，等待服务器确认。</li>
<li>服务器端向客户端回送一个响应，通知客户端收到了连接请求。</li>
<li>客户端再次向服务器端发送确认信息，确认连接。</li>
</ol>
</blockquote>
<blockquote>
<p><strong>四次挥手断开连接：</strong>客户端与服务器之间的四次交互后断开，保证了数据的完整性。</p>
<ol>
<li>客户端先向服务器发送断开请求，问询服务器是否可以断开（说明客户端没有数据要传输了）</li>
<li>服务器向客户端发送数据，需要客户端确认（说明服务器没有数据要传输了）</li>
<li>客户端再次问询服务器是否可以断开连接</li>
<li>断开连接</li>
</ol>
</blockquote>
<h4 id="4-UDP协议"><a href="#4-UDP协议" class="headerlink" title="4. UDP协议"></a>4. UDP协议</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。</span><br></pre></td></tr></table></figure>

<h4 id="5-IP地址"><a href="#5-IP地址" class="headerlink" title="5. IP地址"></a>5. IP地址</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设</span><br><span class="line">备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>IP地址分类：</strong></p>
<ul>
<li>IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如<code>192.168.65.100</code>，最多可以表示42亿个。有资料显示，全球IPv4地址在2011年2月分配完毕。</li>
<li>IPv6：采用128位地址长度，每16个字节一组，分成8组十六进制数，解决了网络地址资源数量不够的问题。表示成：<code>ABCD:EF01:2345:6789:ABCD:EF01:2345:6789</code> 。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>查看本机IP地址，在控制台输入：<code>ipconfig</code></li>
<li>检查网络是否连通，在控制台输入：<code>ping 空格 IP地址</code></li>
<li>本机IP地址：<code>127.0.0.1</code></li>
</ul>
</blockquote>
<h4 id="6-端口号"><a href="#6-端口号" class="headerlink" title="6. 端口号"></a>6. 端口号</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">网络的通信，本质上是两个进程（应用程序）的通信，端口号可以标识设备中的不同进程（应用程序）。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>用两个字节表示的整数，它的取值范围是0~65535。</p>
<p>0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。</p>
<p>常用端口号：</p>
<ol>
<li>网络端口 https:443  http:80</li>
<li>数据库  mysql:3306  oracle:1521</li>
<li>Tomcat服务器:8080</li>
</ol>
</blockquote>
<p><strong>【协议+ IP地址+ 端口号】</strong> 三元组合可以标识网络中的进程，进程间的通信可以利用这个标识与其它进程交互。</p>
<h4 id="7-Socket类"><a href="#7-Socket类" class="headerlink" title="7. Socket类"></a>7. Socket类</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.Socket类表示客户端。创建Socket对象向服务器发出连接请求，服务器响应请求，两者建立连接开始通信。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Socket</span><span class="params">(String host, <span class="keyword">int</span> port)</span> :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是<span class="keyword">null</span>，则相当于指定地址为回送地址。</span></span><br><span class="line"><span class="function"><span class="comment">//成员方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> InputStream <span class="title">getInputStream</span><span class="params">()</span>：返回此套接字的输入流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> OutputStream <span class="title">getOutputStream</span><span class="params">()</span>：返回此套接字的输出流。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span>：关闭此套接字,关闭socket也将关闭相关的InputStream和OutputStream 。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdownOutput</span><span class="params">()</span>：禁用此套接字的输出流,任何先前写出的数据将被发送，随后终止输出流。</span></span><br></pre></td></tr></table></figure>

<h4 id="8-ServerSocket类"><a href="#8-ServerSocket类" class="headerlink" title="8. ServerSocket类"></a>8. ServerSocket类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java.net.ServerSocket类表示服务端。创建ServerSocket 对象，相当于开启一个服务，并等待客户端的连接。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//构造方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ServerSocket</span><span class="params">(<span class="keyword">int</span> port)</span>：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。</span></span><br><span class="line"><span class="function"><span class="comment">//成员方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Socket <span class="title">accept</span><span class="params">()</span>：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//客户端代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"你好服务器"</span>.getBytes());</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bys);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys,<span class="number">0</span>,len));</span><br><span class="line">        System.out.println(socket);</span><br><span class="line">        socket.close();&#125;&#125;</span><br><span class="line"><span class="comment">//服务端代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TCPServer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept();</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">int</span> len = is.read(bys);</span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        os.write(<span class="string">"收到谢谢"</span>.getBytes());</span><br><span class="line">        System.out.println(server);</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="9-文件上传优化分析"><a href="#9-文件上传优化分析" class="headerlink" title="9. 文件上传优化分析"></a>9. 文件上传优化分析</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//文件上传案例服务端代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ServerSocket server = <span class="keyword">new</span> ServerSocket(<span class="number">8888</span>);</span><br><span class="line">        Socket socket = server.accept(); ②</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(<span class="string">"copy.jpg"</span>); ①</span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            fos.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.getOutputStream().write(<span class="string">"上传成功"</span>.getBytes());</span><br><span class="line">        fos.close();</span><br><span class="line">        socket.close();</span><br><span class="line">        server.close();</span><br><span class="line"><span class="comment">//文件上传案例客服端代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span><span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">new</span> FileInputStream(<span class="string">"src.jpg"</span>);</span><br><span class="line">        Socket socket = <span class="keyword">new</span> Socket(<span class="string">"127.0.0.1"</span>, <span class="number">8888</span>);</span><br><span class="line">        OutputStream os = socket.getOutputStream();</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">byte</span>[] bys = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024</span>];</span><br><span class="line">        <span class="keyword">while</span> ((len = fis.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            os.write(bys, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        socket.shutdownOutput(); <span class="comment">//避免阻塞问题</span></span><br><span class="line">        InputStream is = socket.getInputStream();</span><br><span class="line">        <span class="keyword">while</span> ((len = is.read(bys)) != -<span class="number">1</span>) &#123;</span><br><span class="line">            System.out.println(<span class="keyword">new</span> String(bys, <span class="number">0</span>, len));</span><br><span class="line">        &#125;</span><br><span class="line">        socket.close();</span><br><span class="line">        fis.close();</span><br></pre></td></tr></table></figure>

<h5 id="①-文件名称写死的问题"><a href="#①-文件名称写死的问题" class="headerlink" title="① 文件名称写死的问题"></a>① 文件名称写死的问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：</span><br><span class="line">FileOutputStream fis = <span class="keyword">new</span> FileOutputStream(System.currentTimeMillis()+<span class="string">".jpg"</span>) <span class="comment">// 文件名称</span></span><br></pre></td></tr></table></figure>

<h5 id="②-循环接收的问题"><a href="#②-循环接收的问题" class="headerlink" title="② 循环接收的问题"></a>② 循环接收的问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：</span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">	Socket socket = server.accept();</span><br><span class="line">	......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="③-效率问题"><a href="#③-效率问题" class="headerlink" title="③ 效率问题"></a>③ 效率问题</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：</span><br><span class="line"><span class="keyword">while</span>（<span class="keyword">true</span>）&#123;</span><br><span class="line">	Socket socket = serverSocket.accept();</span><br><span class="line">	<span class="comment">// socket 交给子线程处理.</span></span><br><span class="line">	<span class="keyword">new</span> Thread(() ‐&gt; &#123;</span><br><span class="line">		......</span><br><span class="line">		InputStream is = socket.getInputStream();</span><br><span class="line">		......</span><br><span class="line">	&#125;).start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【函数式接口】"><a href="#【函数式接口】" class="headerlink" title="【函数式接口】"></a>【函数式接口】</h2><h4 id="1-函数式接口"><a href="#1-函数式接口" class="headerlink" title="1. 函数式接口"></a>1. 函数式接口</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">有且仅有一个抽象方法的接口。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>@FunctionalInterface注解：使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。</p>
</blockquote>
<h4 id="2-Lambda的延迟执行"><a href="#2-Lambda的延迟执行" class="headerlink" title="2. Lambda的延迟执行"></a>2. Lambda的延迟执行</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无论level是多少，都会先把字符串拼接并传入方法内。如果level不符合要求，拼接操作就白做了</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">	String msgB = <span class="string">"World"</span>;</span><br><span class="line">	String msgC = <span class="string">"Java"</span>;</span><br><span class="line">	log(<span class="number">1</span>, msgA + msgB + msgC);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, String msg)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">	System.out.println(msg);&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用Lambda的延迟执行进行优化，只有满足要求的时候才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String msgA = <span class="string">"Hello"</span>;</span><br><span class="line">	String msgB = <span class="string">"World"</span>;</span><br><span class="line">	String msgC = <span class="string">"Java"</span>;</span><br><span class="line">	log(<span class="number">1</span>, () ‐&gt; msgA + msgB + msgC );&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">log</span><span class="params">(<span class="keyword">int</span> level, MessageBuilder builder)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (level == <span class="number">1</span>) &#123;</span><br><span class="line">		System.out.println(builder.buildMessage());&#125;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MessageBuilder</span> </span>&#123;</span><br><span class="line">	<span class="function">String <span class="title">buildMessage</span><span class="params">()</span></span>;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-Supplier接口"><a href="#3-Supplier接口" class="headerlink" title="3. Supplier接口"></a>3. Supplier接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Supplier&lt;T&gt;接口用来获取一个泛型参数指定类型的对象数据。</span><br><span class="line">仅包含一个无参的抽象方法：<span class="function">T <span class="title">get</span><span class="params">()</span> 。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	String s = getString(() -&gt; <span class="string">"Eric"</span> + <span class="string">"loset"</span>);</span><br><span class="line">	System.out.println(s);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getString</span><span class="params">(Supplier&lt;String&gt; sup)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> sup.get();&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-Consumer接口"><a href="#4-Consumer接口" class="headerlink" title="4. Consumer接口"></a>4. Consumer接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Consumer&lt;T&gt; 接口与Supplier接口相反，是消费一个数据，其数据类型由泛型决定。</span><br><span class="line">包含一个有参的抽象方法<span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(T t)</span>，一个默认方法<span class="title">andThen</span><span class="params">()</span>,可以组合多个步骤。</span></span><br><span class="line"><span class="function"><span class="comment">//andThen方法源码：</span></span></span><br><span class="line"><span class="function"><span class="keyword">default</span> Consumer&lt;T&gt; <span class="title">andThen</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; after)</span> </span>&#123;</span><br><span class="line">	Objects.requireNonNull(after);</span><br><span class="line">	<span class="keyword">return</span> (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	method(<span class="string">"方法"</span>,</span><br><span class="line">	(t) -&gt; System.out.print(t + <span class="string">"1"</span>),</span><br><span class="line">	(t) -&gt; System.out.print(t + <span class="string">"2"</span>),</span><br><span class="line">	(t) -&gt; System.out.print(t + <span class="string">"3"</span>));&#125;       <span class="comment">//方法1方法2方法3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String name, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2, 								Consumer&lt;String&gt; con3)</span></span>&#123;</span><br><span class="line">	con1.andThen(con2).andThen(con3).accept(name);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="5-Predicate接口"><a href="#5-Predicate接口" class="headerlink" title="5. Predicate接口"></a>5. Predicate接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Predicate&lt;T&gt;接口返回一个<span class="keyword">boolean</span>值结果，用于对某种类型的数据进行判断。</span><br><span class="line">接口中包含一个抽象方法： <span class="function"><span class="keyword">boolean</span> <span class="title">test</span><span class="params">(T t)</span>，用于条件判断的场景。</span></span><br><span class="line"><span class="function">接口中包含三个默认方法： <span class="title">and</span><span class="params">()</span>,<span class="title">or</span><span class="params">()</span>,<span class="title">negate</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">"abcdefg"</span>;</span><br><span class="line">        <span class="keyword">boolean</span> b = checkString(s,</span><br><span class="line">                (str) -&gt; str.length() &gt; <span class="number">20</span>,</span><br><span class="line">                (str) -&gt; str.contains(<span class="string">"bc"</span>));</span><br><span class="line">        System.out.println(b);&#125; 	<span class="comment">//true</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">checkString</span><span class="params">(String s, Predicate&lt;String&gt; pre1, </span></span></span><br><span class="line"><span class="function"><span class="params">                                  	Predicate&lt;String&gt; pre2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> pre1.or(pre2).test(s);&#125;</span><br></pre></td></tr></table></figure>

<h4 id="6-Function接口"><a href="#6-Function接口" class="headerlink" title="6. Function接口"></a>6. Function接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据。</span><br><span class="line">包含一个有参的抽象方法 <span class="function">R <span class="title">apply</span><span class="params">(T t)</span>，一个默认方法<span class="title">andThen</span><span class="params">()</span>，可以组合多个步骤。</span></span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">(String str, Function&lt;String, Integer&gt; function)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> num = function.apply(str);</span><br><span class="line">	System.out.println(num + <span class="number">20</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	method(<span class="string">"100"</span>,s-&gt;Integer.parseInt(s));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="【Stream流、方法引用】"><a href="#【Stream流、方法引用】" class="headerlink" title="【Stream流、方法引用】"></a>【Stream流、方法引用】</h2><h4 id="1-流式思想"><a href="#1-流式思想" class="headerlink" title="1. 流式思想"></a>1. 流式思想</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Stream（流）是一个来自数据源（集合、数组等）的元素队列，元素是特定类型的对象，形成一个队列。</span><br><span class="line">Java中的Stream并不会存储元素，而是按需计算。中间操作都会返回流对象本身，这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。</span><br><span class="line">这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Stream流支持并行，效率高</p>
</blockquote>
<h4 id="2-获取流"><a href="#2-获取流" class="headerlink" title="2. 获取流"></a>2. 获取流</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//单列集合中，Collecion接口中加入了stream方法用于获取流</span></span><br><span class="line">Collection&lt;String&gt; c = <span class="keyword">new</span> ArrayList();</span><br><span class="line">Stream&lt;String&gt; collectionStream = c.stream();</span><br><span class="line"><span class="comment">//双列集合中，获取流需要先获得key集合或value集合或者entry集合</span></span><br><span class="line">Map&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">Stream&lt;String&gt; keyStream = map.keySet().stream();</span><br><span class="line">Stream&lt;String&gt; valueStream = map.values().stream();</span><br><span class="line">Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();</span><br><span class="line"><span class="comment">//要获取数组的流对象，可以通过Stream接口中提供的静态方法of</span></span><br><span class="line">String[] arr = &#123;<span class="string">"one"</span>, <span class="string">"two"</span>, <span class="string">"three"</span>&#125;;</span><br><span class="line">Stream&lt;String&gt; arrStream = Stream.of(arr);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>备注： of 方法的参数其实是一个可变参数，所以支持数组。</p>
</blockquote>
<h4 id="3-常用方法"><a href="#3-常用方法" class="headerlink" title="3. 常用方法"></a>3. 常用方法</h4><blockquote>
<ul>
<li><strong>延迟方法：</strong>返回值类型仍然是Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。）</li>
<li><strong>终结方法：</strong>返回值类型不再是Stream 接口自身类型的方法，因此不再支持类似StringBuilder 那样的链式调用。终结方法包括count 和forEach 方法。</li>
</ul>
</blockquote>
<h5 id="forEach：逐一处理"><a href="#forEach：逐一处理" class="headerlink" title="forEach：逐一处理"></a>forEach：逐一处理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">forEach</span><span class="params">(Consumer&lt;? <span class="keyword">super</span> T&gt; action)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="filter：过滤"><a href="#filter：过滤" class="headerlink" title="filter：过滤"></a>filter：过滤</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">filter</span><span class="params">(Predicate&lt;? <span class="keyword">super</span> T&gt; predicate)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="map：映射"><a href="#map：映射" class="headerlink" title="map：映射"></a>map：映射</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;R&gt; <span class="function">Stream&lt;R&gt; <span class="title">map</span><span class="params">(Function&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="count：统计个数"><a href="#count：统计个数" class="headerlink" title="count：统计个数"></a>count：统计个数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">long</span> <span class="title">count</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure>

<h5 id="limit：取用前几个"><a href="#limit：取用前几个" class="headerlink" title="limit：取用前几个"></a>limit：取用前几个</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">limit</span><span class="params">(<span class="keyword">long</span> maxSize)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。</p>
</blockquote>
<h5 id="skip：跳过前几个"><a href="#skip：跳过前几个" class="headerlink" title="skip：跳过前几个"></a>skip：跳过前几个</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Stream&lt;T&gt; <span class="title">skip</span><span class="params">(<span class="keyword">long</span> n)</span></span>;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。</p>
</blockquote>
<h5 id="concat：组合"><a href="#concat：组合" class="headerlink" title="concat：组合"></a>concat：组合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Stream&lt;T&gt; <span class="title">concat</span><span class="params">(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="collect：将流元素生成集合"><a href="#collect：将流元素生成集合" class="headerlink" title="collect：将流元素生成集合"></a>collect：将流元素生成集合</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">List&lt;T&gt; list = stream.collect(Collectors.toList());</span><br><span class="line">Set&lt;T&gt; set = stream.collect(Collectors.toSet());</span><br></pre></td></tr></table></figure>

<h5 id="toArray：将流元素生成数组"><a href="#toArray：将流元素生成数组" class="headerlink" title="toArray：将流元素生成数组"></a>toArray：将流元素生成数组</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object[] array = stream.toArray();</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="comment">// 第一个队伍只要名字为3个字的成员姓名；// 第一个队伍筛选之后只要前3个人；</span></span><br><span class="line">Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == <span class="number">3</span>).limit(<span class="number">3</span>);</span><br><span class="line"><span class="comment">// 第二个队伍只要姓张的成员姓名；// 第二个队伍筛选之后不要前2个人；</span></span><br><span class="line">Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith(<span class="string">"张"</span>)).skip(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 将两个队伍合并为一个队伍；// 根据姓名创建Person对象；// 打印整个队伍的Person对象信息。</span></span><br><span class="line">Stream.concat(streamOne, streamTwo).map(Person::<span class="keyword">new</span>).forEach(System.out::println);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：Stream分为三类方法：</p>
<ol>
<li>初始操作，将数据源转换为Stream流</li>
<li>中间操作，调用之后返回值也是Stream对象</li>
<li>终止操作，调用之后返回值不是Streasm对象</li>
</ol>
<p>流中的数据<strong>只能被消费一次</strong>，流在操作过程中，如果执行的是初始操作、中间操作，那么实际上<strong>不会对流元素进行处理</strong>，只有在进行Stream的<strong>终止操作的时候才执行</strong></p>
</blockquote>
<h4 id="4-方法引用"><a href="#4-方法引用" class="headerlink" title="4. 方法引用"></a>4. 方法引用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">双冒号::为引用运算符，它所在的表达式被称为方法引用，是简化Lambda的书写。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。前提是括号内的所有内容都是依赖于一个对象的某个方法实现的，并不是所有的Lambda表达式都能被简化为方法引用。</span><br></pre></td></tr></table></figure>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">method</span><span class="params">(<span class="keyword">int</span> i, Function&lt;Integer, Integer&gt; f)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> f.apply(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	System.out.println(method(-<span class="number">5</span>, Math::abs));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//数组的构造器引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span>[] ints = createArray(<span class="number">5</span>, <span class="keyword">int</span>[]::<span class="keyword">new</span>);</span><br><span class="line">	System.out.println(Arrays.toString(ints));</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] createArray(<span class="keyword">int</span> i, Function&lt;Integer, <span class="keyword">int</span>[]&gt; f) &#123;</span><br><span class="line">	<span class="keyword">return</span> f.apply(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//类的构造器引用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	personBuilder(<span class="string">"Eric"</span>, (Person::<span class="keyword">new</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">personBuilder</span><span class="params">(String s, Function&lt;String, Person&gt; f)</span> </span>&#123;</span><br><span class="line">	Person p = f.apply(s);</span><br><span class="line">	System.out.println(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="【单元测试、反射、注解】"><a href="#【单元测试、反射、注解】" class="headerlink" title="【单元测试、反射、注解】"></a>【单元测试、反射、注解】</h2><h4 id="1-单元测试"><a href="#1-单元测试" class="headerlink" title="1. 单元测试"></a>1. 单元测试</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试分类：</span><br><span class="line">	1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值，不用懂程序的知识也可以进行测试</span><br><span class="line">	2. 白盒测试：需要写代码的，关注程序具体的执行流程。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>白盒测试</strong>步骤：</p>
<ol>
<li>定义一个测试类，类名为被测试类名+Test（CalculatorTest）</li>
<li>定义一个测试方法，可以独立运行，方法名为test+被测方法名（testAdd() ）</li>
</ol>
<p>方法的返回值：void；参数列表：空参</p>
<ol start="3">
<li>给方法加@Test</li>
<li>导入junit依赖环境</li>
</ol>
</blockquote>
<blockquote>
<p>注意事项：</p>
<ol>
<li>使用断言操作<code>Assert.assertEquals(期望的结果,运算的结果)</code>来处理结果</li>
<li>红色结果为失败，绿色结果为成功</li>
<li>@Before：修饰的方法会在测试方法之前被自动执行</li>
<li>@After：修饰的方法会在测试方法执行之后自动被执行</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代码演示</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Before</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"初始化..."</span>);&#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> add = c.add(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(<span class="number">3</span>, add);&#125;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">        <span class="keyword">int</span> sub = c.sub(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        Assert.assertEquals(-<span class="number">1</span>, sub);&#125;</span><br><span class="line">    <span class="meta">@After</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"释放资源"</span>);&#125;&#125;</span><br></pre></td></tr></table></figure>

<h4 id="2-反射"><a href="#2-反射" class="headerlink" title="2. 反射"></a>2. 反射</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">反射：将类的各个组成部分封装为其他对象，这就是反射机制。通过反射，可以在程序运行过程中操作这些对象，是框架的基础。运用反射可以解耦，提高程序的可拓展性。</span><br></pre></td></tr></table></figure>

<h5 id="获取Class对象"><a href="#获取Class对象" class="headerlink" title="获取Class对象"></a>获取Class对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>. Class.forName(<span class="string">"全类名"</span>)：用于配置文件</span><br><span class="line">	Class personClass = Class.forName(<span class="string">"Reflect.Person"</span>);</span><br><span class="line"><span class="number">2</span>. 类名.class：用于参数的传递</span><br><span class="line">	Class personClass = Person.class;</span><br><span class="line"><span class="number">3</span>. 对象.getClass()：用于对象的获取字节码的方式</span><br><span class="line">	Person p = <span class="keyword">new</span> Person();	Class personClass = p.getClass();</span><br></pre></td></tr></table></figure>

<h5 id="操作成员变量对象"><a href="#操作成员变量对象" class="headerlink" title="操作成员变量对象"></a>操作成员变量对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取成员变量对象</span></span><br><span class="line"><span class="function">Field <span class="title">getField</span><span class="params">(String name)</span>：获取指定名称的<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function">Field[] <span class="title">getFields</span><span class="params">()</span>：获取所有<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function">Field <span class="title">getDeclaredField</span><span class="params">(String name)</span>：获取指定名称的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function">Field[] <span class="title">getDeclaredFields</span><span class="params">()</span>：获取所有的成员变量，不考虑修饰符</span></span><br><span class="line"><span class="function"><span class="comment">//设置成员变量方法</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set</span><span class="params">(Object obj, Object value)</span>：设置值</span></span><br><span class="line"><span class="function"><span class="title">get</span><span class="params">(Object obj)</span>：获取值</span></span><br><span class="line"><span class="function"><span class="title">setAccessible</span><span class="params">(<span class="keyword">true</span>)</span>：忽略访问权限修饰符的安全检查（暴力反射）</span></span><br></pre></td></tr></table></figure>

<h5 id="操作构造方法对象"><a href="#操作构造方法对象" class="headerlink" title="操作构造方法对象"></a>操作构造方法对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取构造方法对象</span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getConstructor</span><span class="params">(parameterTypes.class)</span>：获取指定参数列表的<span class="keyword">public</span>修饰的成员变量</span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getConstructors</span><span class="params">()</span>：获取所有<span class="keyword">public</span>修饰的构造方法 </span></span><br><span class="line"><span class="function">Constructor&lt;T&gt; <span class="title">getDeclaredConstructor</span><span class="params">(parameterTypes.class)</span>：获取指定参数列表的成员变量</span></span><br><span class="line"><span class="function">Constructor&lt;?&gt;[] <span class="title">getDeclaredConstructors</span><span class="params">()</span>：获取所有的构造方法，不考虑修饰符  </span></span><br><span class="line"><span class="function"><span class="comment">//创建对象的方法</span></span></span><br><span class="line"><span class="function"> T <span class="title">newInstance</span><span class="params">(Object... initargs)</span></span></span><br></pre></td></tr></table></figure>

<h5 id="操作成员方法对象"><a href="#操作成员方法对象" class="headerlink" title="操作成员方法对象"></a>操作成员方法对象</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//获取成员方法对象</span></span><br><span class="line"><span class="function">Method <span class="title">getMethod</span><span class="params">(String name，parameterTypes.class)</span>：获取指定名称和参数列表的<span class="keyword">public</span>修饰的方法</span></span><br><span class="line"><span class="function">Method[] <span class="title">getMethods</span><span class="params">()</span>：获取所有<span class="keyword">public</span>修饰的成员方法</span></span><br><span class="line"><span class="function">Method <span class="title">getDeclaredMethod</span><span class="params">(String name，parameterTypes.class)</span>：获取指定名称和参数列表的成员方法</span></span><br><span class="line"><span class="function">Method[] <span class="title">getDeclaredMethods</span><span class="params">()</span>：获取所有的成员方法，不考虑修饰符（含继承的方法）    </span></span><br><span class="line"><span class="function"><span class="comment">//执行方法</span></span></span><br><span class="line"><span class="function">method <span class="title">invoke</span><span class="params">(Object obj)</span></span></span><br></pre></td></tr></table></figure>

<h4 id="3-“框架”案例"><a href="#3-“框架”案例" class="headerlink" title="3. “框架”案例"></a>3. “框架”案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//	配置文件ClassMessage.properties:</span></span><br><span class="line"><span class="comment">//	className = Reflect.Person</span></span><br><span class="line"><span class="comment">//	methodName = eat</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">	Properties pro = <span class="keyword">new</span> Properties();</span><br><span class="line">	pro.load(<span class="keyword">new</span> FileInputStream(<span class="string">"ClassMessage.properties"</span>));</span><br><span class="line">	String className = pro.getProperty(<span class="string">"className"</span>);	<span class="comment">//Reflect.Person</span></span><br><span class="line">	String methodName = pro.getProperty(<span class="string">"methodName"</span>);	<span class="comment">//eat</span></span><br><span class="line">	Class cls = Class.forName(className);</span><br><span class="line">	Object o = cls.getConstructor().newInstance();</span><br><span class="line">	Method method = cls.getMethod(methodName);</span><br><span class="line">	method.invoke(o);	<span class="comment">//调用了Person类中的eat方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="4-注解"><a href="#4-注解" class="headerlink" title="4. 注解"></a>4. 注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">注解（Annotation），也叫元数据。一种代码级别的说明，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。JDK1.5及以后版本引入的特性。</span><br><span class="line">格式：@注解名称</span><br></pre></td></tr></table></figure>

<blockquote>
<p>作用分类：</p>
<ol>
<li>编写文档：通过代码里标识的注解生成文档【生成文档doc文档】</li>
<li>代码分析：通过代码里标识的注解对代码进行分析【使用反射】</li>
<li>编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】</li>
</ol>
</blockquote>
<blockquote>
<p>JDK中预定义的一些注解：</p>
<ul>
<li>@override：方法重写注解</li>
<li>@Deprecated：过期注解</li>
<li>@SuppressWarnings：压制警告，将当前所有的类警告都去除</li>
</ul>
<p>一般传递参数all  @SuppressWarnings(“all”)</p>
</blockquote>
<h4 id="5-自定义注解"><a href="#5-自定义注解" class="headerlink" title="5. 自定义注解"></a>5. 自定义注解</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//格式：</span></span><br><span class="line">	元注解</span><br><span class="line">	<span class="keyword">public</span> <span class="meta">@interface</span> 注解名称&#123;</span><br><span class="line">		属性列表;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注解本质上就是一个接口，该接口<strong>默认继承Annotation接口</strong>：
<code>public interface MyAnno extends java.lang.annotation.Annotation {}</code></p>
</blockquote>
<blockquote>
<p><strong>注解接口中的要求：</strong></p>
<ul>
<li><strong>接口中的抽象方法称为属性</strong>，返回值类型为：</li>
</ul>
<p>①基本数据类型；②String；③枚举；④注解；⑤以上类型的数组</p>
<ul>
<li>定义了属性，在使用时需要给属性赋值，若定义时已经给了默认值，可以不用赋值，如果只有一个属性需要赋值，并且属性的名称是value，则赋值的时候，value的字样可以省略</li>
<li>数组赋值时，需要使用{}包裹，如果数组中只有一个值，则{}省略</li>
</ul>
</blockquote>
<h4 id="6-元注解"><a href="#6-元注解" class="headerlink" title="6. 元注解"></a>6. 元注解</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用于描述注解的注解。</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>@Target(ElementType)</strong>：描述注解能够作用的位置</p>
<p>ElementType取值：</p>
<ol>
<li>ElementType.TYPE：可以作用于类上</li>
<li>ElementType.METHOD：可以作用于方法上</li>
<li>ElementType.FIELD：可以作用于成员变量上</li>
</ol>
<p><strong>@Retention(RetentionPolicy)</strong>：描述注解被保留的阶段</p>
<p>RetentionPolicy取值：</p>
<ol>
<li>RetentionPolicy.RUNTIME：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到</li>
<li>RetentionPolicy.CLASS：当前被描述的注解，会保留到class字节码文件中，不会被JVM读取</li>
<li>RetentionPolicy.SOURCE：当前被描述的注解，不会被class字节码文件保留</li>
</ol>
<p><strong>@Documented</strong>：描述注解是否被抽取到api文档中</p>
<p><strong>@Inherited</strong>：描述注解是否被子类继承</p>
</blockquote>
<h4 id="7-”测试框架“案例"><a href="#7-”测试框架“案例" class="headerlink" title="7. ”测试框架“案例"></a>7. ”测试框架“案例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">	Calculator c = <span class="keyword">new</span> Calculator();</span><br><span class="line">	Class cls = c.getClass();</span><br><span class="line">	<span class="comment">//获取类中的所有方法</span></span><br><span class="line">    Method[] methods = cls.getMethods();</span><br><span class="line">    <span class="comment">//创建输出流和记录异常次数的变量count</span></span><br><span class="line">    BufferedWriter bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"error.txt"</span>));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;  <span class="comment">//遍历所有方法，筛选出被@Check标记的方法</span></span><br><span class="line">		<span class="keyword">if</span> (method.isAnnotationPresent(Check.class)) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				method.invoke(c);</span><br><span class="line">			&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">				count++;</span><br><span class="line">                <span class="comment">//将异常打印到日志文件中</span></span><br><span class="line">                bw.write(method.getName() + <span class="string">"方法出异常了"</span>);</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.write(<span class="string">"异常的名称"</span> + e.getCause().getClass().getSimpleName());</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.write(<span class="string">"异常的原因"</span> + e.getCause());</span><br><span class="line">                bw.newLine();</span><br><span class="line">                bw.write(<span class="string">"-----------------"</span>);</span><br><span class="line">                bw.newLine();&#125;&#125;&#125;</span><br><span class="line">	bw.write(<span class="string">"本次测试共出现了"</span> + count + <span class="string">"次异常"</span>);</span><br><span class="line">	bw.close();&#125;</span><br></pre></td></tr></table></figure>


      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/06/16/数据库知识点总结/" rel="next" title="数据库">
                <i class="fa fa-chevron-left"></i> 数据库
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2019/06/16/Web核心知识点总结/" rel="prev" title="web核心">
                web核心 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Inhaltsverzeichnis
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Übersicht
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Eric</p>
              <div class="site-description motion-element" itemprop="description">Eric's Knowledge Base</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives">
                
                    <span class="site-state-item-count">5</span>
                    <span class="site-state-item-name">Artikel</span>
                  </a>
                </div>
              

              

              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Java核心知识点总结"><span class="nav-text">Java核心知识点总结</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#【入门程序、常量、变量】"><span class="nav-text">【入门程序、常量、变量】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Java语言用途"><span class="nav-text">1. Java语言用途</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-十进制和二进制的转换规则"><span class="nav-text">2. 十进制和二进制的转换规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-计算机存储单元"><span class="nav-text">3.计算机存储单元</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java的跨平台性？"><span class="nav-text">4. Java的跨平台性？</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-JDK、JRE和JVM"><span class="nav-text">5. JDK、JRE和JVM</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-环境变量配置的意义"><span class="nav-text">6. 环境变量配置的意义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Java程序编写的三个步骤"><span class="nav-text">7. Java程序编写的三个步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-常用命令提示符"><span class="nav-text">8. 常用命令提示符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-注释及其格式"><span class="nav-text">9. 注释及其格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-关键字"><span class="nav-text">10. 关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-标识符及其定义规范"><span class="nav-text">11. 标识符及其定义规范</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-数据类型"><span class="nav-text">12. 数据类型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-常量及其分类"><span class="nav-text">13. 常量及其分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#14-变量及其定义格式"><span class="nav-text">14. 变量及其定义格式</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【数据类型转换、运算符、方法入门】"><span class="nav-text">【数据类型转换、运算符、方法入门】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据类型转换"><span class="nav-text">1. 数据类型转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-精度损失和数据溢出"><span class="nav-text">2. 精度损失和数据溢出</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-运算时数据类型的转换规则"><span class="nav-text">3.  运算时数据类型的转换规则</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-编译器的两点优化"><span class="nav-text">4.  编译器的两点优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-加号的三种用法"><span class="nav-text">5. 加号的三种用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ASCII码表"><span class="nav-text">6. ASCII码表</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-运算符"><span class="nav-text">7. 运算符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-、–的使用场景"><span class="nav-text">8. ++、–的使用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-a-1和a-a-1的区别"><span class="nav-text">9. a += 1和a = a + 1的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-定义方法的好处"><span class="nav-text">10. 定义方法的好处</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-方法定义和调用的注意事项"><span class="nav-text">11. 方法定义和调用的注意事项</span></a></li></ol></li></ol><li class="nav-item nav-level-2"><a class="nav-link" href="#【流程控制语句】"><span class="nav-text">【流程控制语句】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-if语句的三种格式"><span class="nav-text">1. if语句的三种格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-程序的健壮性"><span class="nav-text">2. 程序的健壮性</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-switch语句的格式"><span class="nav-text">3. switch语句的格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-三种循环语句的格式"><span class="nav-text">4. 三种循环语句的格式</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#（1）for循环"><span class="nav-text">（1）for循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（2）while循环"><span class="nav-text">（2）while循环</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#（3）do-while循环"><span class="nav-text">（3）do..while循环</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-三种循环语句的区别"><span class="nav-text">5. 三种循环语句的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-break和continue"><span class="nav-text">6. break和continue</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-死循环的格式"><span class="nav-text">7. 死循环的格式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【Idea、方法】"><span class="nav-text">【Idea、方法】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是方法"><span class="nav-text">1. 什么是方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-方法的定义格式"><span class="nav-text">2. 方法的定义格式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-return的作用"><span class="nav-text">3. return的作用</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-方法的调用的方式"><span class="nav-text">4.方法的调用的方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-方法的执行流程"><span class="nav-text">5. 方法的执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-方法的三要素"><span class="nav-text">6. 方法的三要素</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-方法的重载"><span class="nav-text">7. 方法的重载</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-IDEA-常用快捷键"><span class="nav-text">8. IDEA 常用快捷键</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【数组】"><span class="nav-text">【数组】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-什么是数组"><span class="nav-text">1. 什么是数组</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-数组的初始化"><span class="nav-text">2. 数组的初始化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-索引"><span class="nav-text">3. 索引</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Java内存的5个组成部分"><span class="nav-text">4. Java内存的5个组成部分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-数组越界索引异常"><span class="nav-text">5. 数组越界索引异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-数组空指针异常"><span class="nav-text">6. 数组空指针异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-方法的参数类型区别"><span class="nav-text">7. 方法的参数类型区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-数组的直接打印"><span class="nav-text">8. 数组的直接打印</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-数组的内存执行流程"><span class="nav-text">9. 数组的内存执行流程</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-数组的反转"><span class="nav-text">10. 数组的反转</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【类与对象、封装、构造方法】"><span class="nav-text">【类与对象、封装、构造方法】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-面向对象"><span class="nav-text">1. 面向对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-类与对象"><span class="nav-text">2. 类与对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-类描述的信息"><span class="nav-text">3. 类描述的信息</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-对象的使用方式"><span class="nav-text">4. 对象的使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-成员变量和局部变量区别"><span class="nav-text">5. 成员变量和局部变量区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-封装"><span class="nav-text">6. 封装</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-private关键字"><span class="nav-text">7. private关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-this关键字"><span class="nav-text">8. this关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-成员变量的默认值"><span class="nav-text">9. 成员变量的默认值</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-构造方法注意事项"><span class="nav-text">10. 构造方法注意事项</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-标准代码——JavaBean"><span class="nav-text">11. 标准代码——JavaBean</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-对象的内存图流程"><span class="nav-text">12. 对象的内存图流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【Scanner类、Random类、ArrayList类】"><span class="nav-text">【Scanner类、Random类、ArrayList类】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-API的使用方式"><span class="nav-text">1. API的使用方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Scanner类使用步骤"><span class="nav-text">2. Scanner类使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Random类使用步骤"><span class="nav-text">3. Random类使用步骤</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-匿名对象"><span class="nav-text">4. 匿名对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-数组与集合的不同"><span class="nav-text">5. 数组与集合的不同</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-ArrayList类"><span class="nav-text">6. ArrayList类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-ArrayList中的常用方法"><span class="nav-text">7. ArrayList中的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-包装类"><span class="nav-text">8. 包装类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【String类、static关键字、Arrays类、Math类】"><span class="nav-text">【String类、static关键字、Arrays类、Math类】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-String类的三个特点"><span class="nav-text">1. String类的三个特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建字符串的1-3种方法"><span class="nav-text">2. 创建字符串的1+3种方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-String常用方法"><span class="nav-text">3.String常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#判断"><span class="nav-text">判断</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取"><span class="nav-text">获取</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#转换"><span class="nav-text">转换</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#分割"><span class="nav-text">分割</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-正则表达式"><span class="nav-text">4. 正则表达式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-static关键字"><span class="nav-text">5. static关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#类变量"><span class="nav-text">类变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法"><span class="nav-text">静态方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态代码块"><span class="nav-text">静态代码块</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Arrays类"><span class="nav-text">6. Arrays类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Math类"><span class="nav-text">7. Math类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【继承、super、this、抽象类】"><span class="nav-text">【继承、super、this、抽象类】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-继承"><span class="nav-text">1. 继承</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-抽象类"><span class="nav-text">2. 抽象类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-继承后的特点"><span class="nav-text">3. 继承后的特点</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#成员变量重名"><span class="nav-text">成员变量重名</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#成员方法重名——重写-Override"><span class="nav-text">成员方法重名——重写(Override)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法"><span class="nav-text">构造方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-super关键字的三种用法"><span class="nav-text">4. super关键字的三种用法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-this关键字的三种用法"><span class="nav-text">5. this关键字的三种用法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【接口、多态】"><span class="nav-text">【接口、多态】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-接口的定义"><span class="nav-text">1. 接口的定义</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-接口包含的内容"><span class="nav-text">2. 接口包含的内容</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#常量（Java-7）"><span class="nav-text">常量（Java 7）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#抽象方法（Java-7）"><span class="nav-text">抽象方法（Java 7）</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#默认方法-Java-8"><span class="nav-text">默认方法(Java 8)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#静态方法-Java-8"><span class="nav-text">静态方法(Java 8)</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#私有方法-Java-9"><span class="nav-text">私有方法(Java 9)</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-接口的多实现"><span class="nav-text">3. 接口的多实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-接口的特点"><span class="nav-text">4. 接口的特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-多态"><span class="nav-text">5. 多态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-多态成员的访问"><span class="nav-text">6. 多态成员的访问</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-多态的好处和弊端"><span class="nav-text">7. 多态的好处和弊端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-引用、对象、对象名称的区分"><span class="nav-text">8. 引用、对象、对象名称的区分</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-向上转型和向下转型"><span class="nav-text">9. 向上转型和向下转型</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-instanceof-关键字"><span class="nav-text">10. instanceof 关键字</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【final、权限、内部类、引用类型】"><span class="nav-text">【final、权限、内部类、引用类型】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-final-关键字"><span class="nav-text">1. final 关键字</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰类"><span class="nav-text">修饰类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰方法"><span class="nav-text">修饰方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰局部变量"><span class="nav-text">修饰局部变量</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#修饰成员变量"><span class="nav-text">修饰成员变量</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-权限修饰符"><span class="nav-text">2. 权限修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-成员内部类"><span class="nav-text">3. 成员内部类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-类的权限修饰符"><span class="nav-text">4. 类的权限修饰符</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-局部内部类的final问题"><span class="nav-text">5. 局部内部类的final问题</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-匿名内部类"><span class="nav-text">6. 匿名内部类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【Object类、常用API】"><span class="nav-text">【Object类、常用API】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Object类"><span class="nav-text">1. Object类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-toString方法"><span class="nav-text">2. toString方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-equals方法"><span class="nav-text">3. equals方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Objects类"><span class="nav-text">4. Objects类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Date类"><span class="nav-text">5. Date类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-DateFormat类"><span class="nav-text">6. DateFormat类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Calendar类"><span class="nav-text">7. Calendar类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-日期、字符串、毫秒值和日历的相互转换"><span class="nav-text">8. 日期、字符串、毫秒值和日历的相互转换</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-System类"><span class="nav-text">9. System类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-StringBuilder类"><span class="nav-text">10. StringBuilder类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-基本类型与字符串之间的转换"><span class="nav-text">11. 基本类型与字符串之间的转换</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【Collection、泛型】"><span class="nav-text">【Collection、泛型】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Collection"><span class="nav-text">1. Collection</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-集合和数组的区别"><span class="nav-text">2. 集合和数组的区别</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Collection-常用功能"><span class="nav-text">3. Collection 常用功能</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Iterator接口"><span class="nav-text">4.  Iterator接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-ListIterator接口"><span class="nav-text">5. ListIterator接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-增强for"><span class="nav-text">6. 增强for</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-泛型"><span class="nav-text">7. 泛型</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#含有泛型的类"><span class="nav-text">含有泛型的类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#含有泛型的方法"><span class="nav-text">含有泛型的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#含有泛型的接口"><span class="nav-text">含有泛型的接口</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-泛型通配符"><span class="nav-text">8. 泛型通配符</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【List、Set、数据结构、Collections】"><span class="nav-text">【List、Set、数据结构、Collections】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-数据结构"><span class="nav-text">1. 数据结构</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#栈"><span class="nav-text">栈</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#队列"><span class="nav-text">队列</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#数组"><span class="nav-text">数组</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#链表"><span class="nav-text">链表</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#红黑树"><span class="nav-text">红黑树</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-List-接口"><span class="nav-text">2. List 接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-LinkedList-集合"><span class="nav-text">3. LinkedList 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-HashSet-集合"><span class="nav-text">4. HashSet 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-LinkedHashSet-集合"><span class="nav-text">5. LinkedHashSet 集合</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-重写HashCode-方法"><span class="nav-text">6. 重写HashCode()方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-可变参数"><span class="nav-text">7. 可变参数</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Collections-工具类"><span class="nav-text">8. Collections 工具类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-Comparable-Comparator-接口"><span class="nav-text">9. Comparable/Comparator 接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【Map、Debug】"><span class="nav-text">【Map、Debug】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Map接口"><span class="nav-text">1. Map接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Map的常用子类"><span class="nav-text">2. Map的常用子类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Map的常用方法"><span class="nav-text">3. Map的常用方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Entry键值对对象"><span class="nav-text">4. Entry键值对对象</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Map的两种遍历方式"><span class="nav-text">5. Map的两种遍历方式</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-JDK9对集合添加的优化"><span class="nav-text">6. JDK9对集合添加的优化</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Debug追踪"><span class="nav-text">7. Debug追踪</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【异常、线程】"><span class="nav-text">【异常、线程】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-异常"><span class="nav-text">1. 异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Throwable体系"><span class="nav-text">2. Throwable体系</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-异常的分类"><span class="nav-text">3. 异常的分类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-异常产生过程解析"><span class="nav-text">4. 异常产生过程解析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-throw关键字"><span class="nav-text">5. throw关键字</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Objects非空判断"><span class="nav-text">6. Objects非空判断</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-throws声明异常"><span class="nav-text">7. throws声明异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-try…catch捕获异常"><span class="nav-text">8. try…catch捕获异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-finally代码块"><span class="nav-text">9. finally代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-多个异常使用捕获"><span class="nav-text">10. 多个异常使用捕获</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#11-自定义异常"><span class="nav-text">11. 自定义异常</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#12-并发与并行"><span class="nav-text">12. 并发与并行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#13-线程与进程"><span class="nav-text">13. 线程与进程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【线程、同步】"><span class="nav-text">【线程、同步】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-Thread类"><span class="nav-text">1. Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-创建线程-继承Thread类"><span class="nav-text">2. 创建线程-继承Thread类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-创建线程-Runnable接口"><span class="nav-text">3. 创建线程-Runnable接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Runnable接口具有的优势"><span class="nav-text">4. Runnable接口具有的优势</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-线程安全"><span class="nav-text">5. 线程安全</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-同步代码块"><span class="nav-text">6. 同步代码块</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-同步方法"><span class="nav-text">7. 同步方法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-Lock锁"><span class="nav-text">8. Lock锁</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-六种线程状态"><span class="nav-text">9. 六种线程状态</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#10-等待与唤醒方法"><span class="nav-text">10. 等待与唤醒方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【线程池、Lambda表达式】"><span class="nav-text">【线程池、Lambda表达式】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-等待唤醒机制"><span class="nav-text">1. 等待唤醒机制</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-线程池"><span class="nav-text">2. 线程池</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Lambda表达式"><span class="nav-text">3. Lambda表达式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【File类、递归】"><span class="nav-text">【File类、递归】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-File类"><span class="nav-text">1. File类</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#构造方法-1"><span class="nav-text">构造方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#获取的方法"><span class="nav-text">获取的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#判断的方法"><span class="nav-text">判断的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#创建删除的方法"><span class="nav-text">创建删除的方法</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#遍历的方法"><span class="nav-text">遍历的方法</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-绝对路径和相对路径"><span class="nav-text">2. 绝对路径和相对路径</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-递归"><span class="nav-text">3. 递归</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-文件过滤器"><span class="nav-text">4. 文件过滤器</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【字节流、字符流】"><span class="nav-text">【字节流、字符流】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-IO流"><span class="nav-text">1. IO流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字节输出流【OutputStream】"><span class="nav-text">2. 字节输出流【OutputStream】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileOutputStream"><span class="nav-text">FileOutputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-字节输入流【InputStream】"><span class="nav-text">3. 字节输入流【InputStream】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileInputStream"><span class="nav-text">FileInputStream</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-字符输入流【Reader】"><span class="nav-text">4. 字符输入流【Reader】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileReader"><span class="nav-text">FileReader</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-字符输出流【Writer】"><span class="nav-text">5. 字符输出流【Writer】</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#FileWriter"><span class="nav-text">FileWriter</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-IO异常的处理"><span class="nav-text">6. IO异常的处理</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK7前处理"><span class="nav-text">JDK7前处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK7的处理"><span class="nav-text">JDK7的处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#JDK9的改进"><span class="nav-text">JDK9的改进</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Properties类"><span class="nav-text">7. Properties类</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【缓冲流、转换流、序列化流】"><span class="nav-text">【缓冲流、转换流、序列化流】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-缓冲流"><span class="nav-text">1. 缓冲流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#字节缓冲流"><span class="nav-text">字节缓冲流</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#字符缓冲流"><span class="nav-text">字符缓冲流</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-字符集"><span class="nav-text">2. 字符集</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-转换流"><span class="nav-text">3. 转换流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#InputStreamReader类"><span class="nav-text">InputStreamReader类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#OutputStreamWriter类"><span class="nav-text">OutputStreamWriter类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-序列化"><span class="nav-text">4. 序列化</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectOutputStream类"><span class="nav-text">ObjectOutputStream类</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#ObjectInputStream类"><span class="nav-text">ObjectInputStream类</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-打印流"><span class="nav-text">5. 打印流</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#PrintStream类"><span class="nav-text">PrintStream类</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【网络编程】"><span class="nav-text">【网络编程】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-软件结构"><span class="nav-text">1. 软件结构</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-网络通信协议"><span class="nav-text">2. 网络通信协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-TCP协议"><span class="nav-text">3. TCP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-UDP协议"><span class="nav-text">4. UDP协议</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-IP地址"><span class="nav-text">5. IP地址</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-端口号"><span class="nav-text">6. 端口号</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-Socket类"><span class="nav-text">7. Socket类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#8-ServerSocket类"><span class="nav-text">8. ServerSocket类</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#9-文件上传优化分析"><span class="nav-text">9. 文件上传优化分析</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#①-文件名称写死的问题"><span class="nav-text">① 文件名称写死的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#②-循环接收的问题"><span class="nav-text">② 循环接收的问题</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#③-效率问题"><span class="nav-text">③ 效率问题</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【函数式接口】"><span class="nav-text">【函数式接口】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-函数式接口"><span class="nav-text">1. 函数式接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-Lambda的延迟执行"><span class="nav-text">2. Lambda的延迟执行</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-Supplier接口"><span class="nav-text">3. Supplier接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-Consumer接口"><span class="nav-text">4. Consumer接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-Predicate接口"><span class="nav-text">5. Predicate接口</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-Function接口"><span class="nav-text">6. Function接口</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【Stream流、方法引用】"><span class="nav-text">【Stream流、方法引用】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-流式思想"><span class="nav-text">1. 流式思想</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-获取流"><span class="nav-text">2. 获取流</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-常用方法"><span class="nav-text">3. 常用方法</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#forEach：逐一处理"><span class="nav-text">forEach：逐一处理</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#filter：过滤"><span class="nav-text">filter：过滤</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#map：映射"><span class="nav-text">map：映射</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#count：统计个数"><span class="nav-text">count：统计个数</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#limit：取用前几个"><span class="nav-text">limit：取用前几个</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#skip：跳过前几个"><span class="nav-text">skip：跳过前几个</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#concat：组合"><span class="nav-text">concat：组合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#collect：将流元素生成集合"><span class="nav-text">collect：将流元素生成集合</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#toArray：将流元素生成数组"><span class="nav-text">toArray：将流元素生成数组</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-方法引用"><span class="nav-text">4. 方法引用</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#【单元测试、反射、注解】"><span class="nav-text">【单元测试、反射、注解】</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#1-单元测试"><span class="nav-text">1. 单元测试</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-反射"><span class="nav-text">2. 反射</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#获取Class对象"><span class="nav-text">获取Class对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作成员变量对象"><span class="nav-text">操作成员变量对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作构造方法对象"><span class="nav-text">操作构造方法对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#操作成员方法对象"><span class="nav-text">操作成员方法对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#3-“框架”案例"><span class="nav-text">3. “框架”案例</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#4-注解"><span class="nav-text">4. 注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#5-自定义注解"><span class="nav-text">5. 自定义注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#6-元注解"><span class="nav-text">6. 元注解</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#7-”测试框架“案例"><span class="nav-text">7. ”测试框架“案例</span></a></li></ol></li></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Eric</span>

  

  
</div>


  <div class="powered-by">Erstellt mit  <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Design – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> v7.1.2</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=3.4.1"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/utils.js?v=7.1.2"></script>

  <script src="/js/motion.js?v=7.1.2"></script>



  
  


  <script src="/js/affix.js?v=7.1.2"></script>

  <script src="/js/schemes/pisces.js?v=7.1.2"></script>




  
  <script src="/js/scrollspy.js?v=7.1.2"></script>
<script src="/js/post-details.js?v=7.1.2"></script>



  


  <script src="/js/next-boot.js?v=7.1.2"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
