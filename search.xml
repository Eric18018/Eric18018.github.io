<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ssm框架]]></title>
    <url>%2F2019%2F06%2F16%2F%E6%A1%86%E6%9E%B6%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[框架知识点总结Mybatis1. 框架概述1框架（Framework）是某种应用的半成品，是一组组件，供你选用完成你自己的系统。通过框架，可以将应用自身的设计和具体的实现技术解耦，这样，软件的研发将集中在应用的设计上，而不是具体的技术实现。框架一般处在低层应用平台（如J2EE）和高层业务逻辑之间的中间层。 1MyBatis 是一款优秀的持久层框架，它支持定制化SQL、存储过程以及高级映射。MyBatis避免了几乎所有的JDBC代码和手动设置参数以及获取结果集。MyBatis 可以使用简单的 XML 或注解来配置和映射原生信息，将接口和POJOs映射成数据库中的记录，使开发者只需要关注sql语句本身，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 2. Mybatis快速入门 在pom.xml文件中添加Mybatis3.4.5，mysql，log4j的坐标 12345678910111213141516171819&gt; &lt;dependencies&gt; &gt; &lt;dependency&gt; &gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &gt; &lt;version&gt;3.4.5&lt;/version&gt; &gt; &lt;/dependency&gt; &gt; &lt;dependency&gt; &gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &gt; &lt;version&gt;5.1.6&lt;/version&gt; &gt; &lt;scope&gt;runtime&lt;/scope&gt; &gt; &lt;/dependency&gt; &gt; &lt;dependency&gt; &gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &gt; &lt;version&gt;1.2.12&lt;/version&gt; &gt; &lt;/dependency&gt; &gt; &lt;/dependencies&gt;&gt; 编写持久层接口的映射文件XXXDao.xml 创建位置：创建在resources文件中，但必须和持久层接口在相同的包中 名称：必须以持久层接口名称命名文件名，扩展名是.xml 1234567891011&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt;&gt; &lt;!DOCTYPE mapper&gt; PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"&gt; "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&gt; &lt;mapper namespace="dao.IUserDao"&gt;&gt; &lt;!--配置查询所有--&gt;&gt; &lt;select id="findAll" resultType="domain.User"&gt;&gt; select * from user&gt; &lt;/select&gt;&gt; &lt;/mapper&gt;&gt; 编写SqlMapConfig.xml配置文件 创建位置：创建在resources文件中 1234567891011121314151617181920212223242526272829303132333435&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt;&gt; &lt;!DOCTYPE configuration&gt; PUBLIC "-//mybatis.org//DTD Config 3.0//EN"&gt; "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;&gt; &lt;!-- mybatis的主配置文件 --&gt;&gt; &lt;configuration&gt;&gt; &lt;!-- 引入properties文件 --&gt;&gt; &lt;properties resource="jdbcConfig.properties"&gt;&lt;/properties&gt;&gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名 --&gt;&gt; &lt;typeAliases&gt;&gt; &lt;package name="domain"&gt;&lt;/package&gt;&gt; &lt;/typeAliases&gt;&gt; &lt;!-- 配置环境 --&gt;&gt; &lt;environments default="mysql"&gt;&gt; &lt;!-- 配置mysql的环境--&gt;&gt; &lt;environment id="mysql"&gt;&gt; &lt;!-- 配置事务的类型--&gt;&gt; &lt;transactionManager type="JDBC"&gt;&lt;/transactionManager&gt;&gt; &lt;!-- 配置数据源（连接池） --&gt;&gt; &lt;dataSource type="POOLED"&gt;&gt; &lt;!-- 配置连接数据库的4个基本信息 --&gt;&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"&gt;&lt;/property&gt;&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"&gt;&lt;/property&gt;&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"&gt;&lt;/property&gt;&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt;&gt; &lt;/dataSource&gt;&gt; &lt;/environment&gt;&gt; &lt;/environments&gt;&gt; &gt; &lt;!-- 注册指定包下的所有mapper接口(xml文件) --&gt;&gt; &lt;mappers&gt; &gt; &lt;package name="dao"&gt;&lt;/package&gt;&gt; &lt;/mappers&gt;&gt; &lt;/configuration&gt;&gt; 编写测试类 123456789101112131415161718192021&gt; public static void main(String[] args) throws IOException &#123;&gt; //1.读取主配置文件，通过类加载器获得输入流对象&gt; InputStream in = Resources.getResourceAsStream("SqlMapConfig.xml");&gt; //2.创建SqlSessionFactory的构建者对象&gt; SqlSessionFactoryBuilder builder = new SqlSessionFactoryBuilder();&gt; //3.使用构建者创建工厂对象SqlSessionFactory&gt; SqlSessionFactory factory = builder.build(in);&gt; //4.创建SqlSession对象，SqlSession对象就可以对数据库进行增删改查&gt; SqlSession session = factory.openSession();&gt; //5.根据SqlSession对象获取dao接口的代理对象&gt; IUserDao userDao = session.getMapper(IUserDao.class);&gt; //6.执行代理对象中的具体方法&gt; List&lt;User&gt; users = userDao.findAll();&gt; for (User user : users) &#123;&gt; System.out.println(user);&gt; &#125;&gt; //7.释放资源&gt; session.close();&gt; in.close();&gt; &#125;&gt; 基于注解的mybatis使用 在持久层接口中添加注解，不再需要持久层接口的映射文件 12345&gt; public interface IUserDao &#123;&gt; @Select("select * from user") &gt; List&lt;User&gt; findAll(); &gt; &#125;&gt; 修改SqlMapConfig.xml 12345678&gt; &lt;mappers&gt; &gt; &lt;!--使用注解方式配置映射信息--&gt;&gt; &lt;mapper class="dao.IUserDao"/&gt; &gt; &lt;!--使用映射配置文件路径--&gt;&gt; &lt;!-- &lt;mapper resource="dao/IUserDao.xml"/&gt; --&gt;&gt; &lt;!--如果配置文件和注解方式同时存在，则会报错--&gt;&gt; &lt;/mappers&gt;&gt; 在使用基于注解的Mybatis配置时，请移除xml的映射配置（IUserDao.xml） 3. 基于代理Dao实现CRUD操作1234567891011121314151617181920212223242526272829303132333435363738&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE mapper PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN" "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;&lt;mapper namespace="dao.IUserDao"&gt; &lt;!-- resultMap配置数据库和实体类的映射，用于数据库和实体类名称不对应时 --&gt; &lt;resultMap type="domain.User" id="userMap"&gt; &lt;id column="id" property="userId"/&gt; &lt;result column="username" property="userName"/&gt; &lt;result column="sex" property="userSex"/&gt; &lt;result column="address" property="userAddress"/&gt; &lt;result column="birthday" property="userBirthday"/&gt; &lt;/resultMap&gt; &lt;!-- 根据id查找 --&gt; &lt;select id="findById" resultMap="userMap"&gt; select * from user where id = #&#123;id&#125; &lt;/select&gt; &lt;!-- 插入数据 --&gt; &lt;insert id="saveUser" parameterType="domain.User"&gt; &lt;!-- 配置保存时获取插入的id --&gt; &lt;selectKey keyColumn="id" keyProperty="id" resultType="int" &gt; select last_insert_id() &lt;/selectKey&gt; insert into user(username,birthday,sex,address) VALUES (#&#123;username&#125;,#&#123;birthday&#125;,#&#123;sex&#125;,#&#123;address&#125;) &lt;/insert&gt; &lt;!-- 修改数据 --&gt; &lt;update id="updateUser" parameterType="domain.User"&gt; update user set username = #&#123;username&#125;,birthday = #&#123;birthday&#125;,sex = #&#123;sex&#125;,address=#&#123;address&#125; where id = #&#123;id&#125; &lt;/update&gt; &lt;!-- 删除数据 --&gt; &lt;delete id="deleteUser" parameterType="int"&gt; delete from user where id = #&#123;uid&#125; &lt;/delete&gt; &lt;!-- 模糊匹配查询 --&gt; &lt;select id="findByName" parameterType="String" resultMap="userMap"&gt; select * from user where username like #&#123;username&#125; &lt;!--'%$&#123;value&#125;%'--&gt; &lt;/select&gt;&lt;/mapper&gt; 12345678910111213141516171819//测试类@Beforepublic void init() throws IOException &#123; in = Resources.getResourceAsStream("SqlMapConfig.xml"); SqlSessionFactory factory = new SqlSessionFactoryBuilder().build(in); session = factory.openSession(); userDao = session.getMapper(IUserDao.class);&#125;@Afterpublic void destroy()&#123; session.commit(); session.close(); try &#123; in.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125; #{}与${}的区别： #{}表示一个占位符号，通过实现preparedStatement向占位符中设置值，自动进行java类型和jdbc类型转换，可以有效防止sql注入。 接收简单类型值或pojo属性值。 ${} 表示拼接sql串，通过将parameterType传入的内容拼接在sql中且不进行jdbc类型转换，可以接收简单类型值或pojo属性值，如果parameterType传输单个简单类型值，${}括号中只能是value。 4. SqlMapConfig.xml配置文件SqlMapConfig.xml中配置的内容和顺序1234567891011121314151617-properties（属性） --property -settings（全局配置参数） --setting -typeAliases（类型别名） --typeAliase --package -typeHandlers（类型处理器） -objectFactory（对象工厂） -plugins（插件） -environments（环境集合属性对象） --environment（环境子属性对象） ---transactionManager（事务管理） ---dataSource（数据源） -mappers（映射器） --mapper --package 自定义别名 1234567&gt; &lt;typeAliases&gt; &gt; &lt;!-- 单个别名定义 --&gt; &gt; &lt;typeAlias alias="user" type="com.itheima.domain.User"/&gt; &gt; &lt;!-- 批量别名定义，扫描整个包下的类，别名为类名（首字母大写或小写都可以） --&gt; &gt; &lt;package name="com.itheima.domain"/&gt; &lt;package name="其它包"/&gt; &gt; &lt;/typeAliases&gt;&gt; mappers（映射器） 使用相对于类路径的资源：&lt;mapper resource=&quot;com/itheima/dao/IUserDao.xml&quot;/&gt; 使用mapper接口类路径：&lt;mapper class=&quot;com.itheima.dao.UserDao&quot;/&gt; 注册指定包下的所有mapper接口：&lt;package name=&quot;cn.itcast.mybatis.mapper&quot;/&gt; 5. Mybatis连接池 Mybatis将它自己的数据源dataSource分为三类： POOLED：使用连接池的数据源，MyBatis会创建PooledDataSource实例 UNPOOLED：不使用连接池的数据源，MyBatis会创建UnpooledDataSource实例 JNDI：使用JNDI实现的数据源，MyBatis会从JNDI服务上查找DataSource实例，然后返回使用 1234567&lt;!-- 配置数据源（连接池）信息 --&gt; &lt;dataSource type="POOLED"&gt; &lt;property name="driver" value="$&#123;jdbc.driver&#125;"/&gt; &lt;property name="url" value="$&#123;jdbc.url&#125;"/&gt; &lt;property name="username" value="$&#123;jdbc.username&#125;"/&gt; &lt;property name="password" value="$&#123;jdbc.password&#125;"/&gt; &lt;/dataSource&gt; 当我们需要创建SqlSession对象并需要执行SQL语句时，MyBatis才会去调用dataSource对象来创建java.sql.Connection对象。也就是说，java.sql.Connection对象的创建一直延迟到执行SQL语句的时候。 6. Mybatis事务控制123Mybatis框架是对JDBC的封装，所以Mybatis框架的事务控制方式是用JDBC的setAutoCommit()方法来设置事务提交方式的。在连接池中取出的连接，都会调用connection.setAutoCommit(false)方法实现事务提交。通过设定session = factory.openSession(true);传入true参数，实现事务的自动提交，不用再进行手动提交了。 7. 动态sql语句12345678910111213141516&lt;!-- 抽取重复的语句代码片段 --&gt;&lt;sql id="defaultSql"&gt; select * from user &lt;/sql&gt;&lt;!-- 查询所有用户在id的集合之中 --&gt; &lt;select id="findInIds" resultType="user" parameterType="queryvo"&gt; &lt;!-- select * from user where id in (1,2,3,4,5); --&gt; &lt;include refid="defaultSql"&gt;&lt;/include&gt; &lt;where&gt; &lt;if test="ids != null and ids.size() &gt; 0"&gt; &lt;foreach collection="ids" open="id in ( " close=")" item="uid" separator=","&gt; #&#123;uid&#125; &lt;/foreach&gt; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; 标签说明： &lt;Sql&gt;：将重复的sql提取出来，使用时用&lt;include&gt;引用即可，最终达到sql重用的目的。 &lt;where&gt;：用于条件拼装 &lt;if&gt;：标签中test属性中写的是对象的属性名，不为空时加入sql条件语句 &lt;foreach&gt;：用于遍历集合，它的属性： collection：代表要遍历的集合元素，注意编写时不要写#{} open：代表语句的开始部分 close：代表结束部分 item：代表遍历集合的每个元素，生成的变量名 sperator：代表分隔符 8. 一对一查询 以Account表（账户表）关联User表（用户表）为例： 在Account类中加入User类的对象作为Account类的一个属性，并添加GetterSetter方法 在AccountDao.xml中定义封装Account和User的resultMap 1234567891011121314&gt; &lt;resultMap id="accountUserMap" type="account"&gt;&gt; &lt;id property="id" column="aid"/&gt;&gt; &lt;result property="uid" column="uid"/&gt;&gt; &lt;result property="money" column="money"/&gt;&gt; &lt;!-- 一对一的关系映射：配置封装user的内容--&gt;&gt; &lt;association property="id" column="uid" javaType="user"&gt;&gt; &lt;id property="id" column="id"/&gt;&gt; &lt;result column="username" property="username"/&gt;&gt; &lt;result column="address" property="address"/&gt;&gt; &lt;result column="sex" property="sex"/&gt;&gt; &lt;result column="birthday" property="birthday"/&gt;&gt; &lt;/association&gt;&gt; &lt;/resultMap&gt;&gt; 配置sql语句 1234&gt; &lt;select id="findAll" resultMap="accountUserMap"&gt;&gt; select u.*,a.id as aid,a.uid,a.money from account a , user u where u.id = a.uid;&gt; &lt;/select&gt;&gt; association标签 property：映射到列结果的字段或属性。 column：用来传给另一个表的值所在列，一般为两个表关联的主键。 javaType：一个 Java 类的完全限定名，或一个类型别名，表示封装的类型。 select：另外一个查询语句的id，column属性中指定的列的值将被传递给目标select语句作为参数。 9. 一对多查询 以User表（用户表）关联Account表（账户表）为例： 在User类中加入Account类的对象作为User类的一个属性，并添加GetterSetter方法 在UserDao.xml中定义封装User和Account的resultMap 1234567891011121314&gt; &lt;resultMap id="userMap" type="user"&gt;&gt; &lt;id property="id" column="id"/&gt;&gt; &lt;result property="username" column="username"/&gt;&gt; &lt;result property="address" column="address"/&gt;&gt; &lt;result property="sex" column="sex"/&gt;&gt; &lt;result property="birthday" column="birthday"/&gt;&gt; &lt;!-- 配置user对象中accounts集合的映射 --&gt;&gt; &lt;collection property="accounts" ofType="account"&gt;&gt; &lt;id column="aid" property="id"/&gt;&gt; &lt;result column="uid" property="uid"/&gt;&gt; &lt;result column="money" property="money"/&gt;&gt; &lt;/collection&gt;&gt; &lt;/resultMap&gt;&gt; 配置sql语句 1234&gt; &lt;select id="findAll" resultMap="userMap"&gt; &gt; select u.*,a.id as aid ,a.uid,a.money from user u left outer join account a on u.id =a.uid &gt; &lt;/select&gt;&gt; collection标签 property：关联查询的结果集存储在User对象的哪个属性里 ofType：指定关联查询的结果集中的对象类型，即List对象中的泛型。可使用别名，也可使用全限定名。 10. 延迟加载1延迟加载：在需要用到数据时才进行加载，不需要用到数据时就不加载数据，也称懒加载。 通过assocation实现延迟加载：以查询账户信息时延时加载用户信息为例。 查询所有账户，同时获取账户所属用户名及其地址 1234&gt; &lt;select id="findAll" resultMap="accountMap"&gt;&gt; select * from account&gt; &lt;/select&gt;&gt; 在dao层的Account映射文件添加association标签 12345678&gt; &lt;resultMap id="accountMap" type="account"&gt;&gt; &lt;id property="id" column="id"/&gt;&gt; &lt;result property="uid" column="uid"/&gt;&gt; &lt;result property="money" column="money"/&gt;&gt; &lt;!-- 从指定表方引用实体属性 --&gt;&gt; &lt;association property="user" column="uid" select="dao.IUserDao.findById" /&gt;&gt; &lt;/resultMap&gt;&gt; select：填写我们要调用的 select 映射的 id column：填写我们要传递给 select 映射的参数 association标签中调用的”dao.IUserDao.findById” 1234&gt; &lt;select id="findById" parameterType="INT" resultType="user"&gt;&gt; select * from user where id = #&#123;uid&#125;&gt; &lt;/select&gt;&gt; 开启Mybatis的延迟加载策略 12345&gt; &lt;settings&gt;&gt; &lt;setting name="lazyLoadingEnabled" value="true"/&gt; &gt; &lt;setting name="aggressiveLazyLoading" value="false"/&gt; &gt; &lt;/settings&gt;&gt; lazyLoadingEnabled： 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 aggressiveLazyLoading： 当开启时，任何方法的调用都会加载该对象的所有属性。否则，每个属性会按需加载。 编写测试方法 1234567&gt; @Before...&gt; @After...&gt; @Test&gt; public void testFindAll()&#123;&gt; List&lt;Account&gt; lists = accountDao.findAll();&gt; &#125;&gt; 运行测试后的日志信息： 12345678910111213141516&gt; 开启延时加载：&gt; ==&gt; Preparing: select * from account &gt; ==&gt; Parameters: &gt; &lt;== Total: 3&gt; &gt; 关闭延时加载：&gt; ==&gt; Preparing: select * from account &gt; ==&gt; Parameter&gt; ==&gt; Preparing: select * from user where id = ? &gt; ==&gt; Parameters: 41(Integer)&gt; &lt;== Total: 1&gt; ==&gt; Preparing: select * from user where id = ? &gt; ==&gt; Parameters: 45(Integer)&gt; &lt;== Total: 1&gt; &lt;== Total: 3&gt; 通过collection实现延迟加载：以完成加载用户对象时，查询该用户所拥有的账户信息为例。 在dao层的User映射文件添加collection标签，其他步骤同association方法 12345678910&gt; &lt;resultMap type="user" id="userMap"&gt; &gt; &lt;id column="id" property="id"/&gt;&gt; &lt;result column="username" property="username"/&gt; &gt; &lt;result column="address" property="address"/&gt; &gt; &lt;result column="sex" property="sex"/&gt; &gt; &lt;result column="birthday" property="birthday"/&gt; &gt; &lt;collection property="accounts" ofType="account" &gt; select="dao.IAccountDao.findByUid" column="id"&gt; &lt;/collection&gt; &gt; &lt;/resultMap&gt;&gt; &lt;collection&gt;标签主要用于加载关联的集合对象 ofType用于指定集合元素的数据类型 select是用于指定查询账户的唯一标识（账户的dao全限定类名加上方法名称） column是用于指定使用哪个字段的值作为传递的条件查询 11. Mybatis缓存1像大多数的持久化框架一样，Mybatis也提供了缓存策略，通过缓存策略来减少数据库的查询次数，从而提高性能。 Mybatis中缓存分为一级缓存，二级缓存。 一级缓存：是SqlSession范围的缓存，当查询同一用户id的数据时，会优从一级缓存中查找数据，如果没有，再去数据库。 一级缓存的清空：当SqlSession执行flush、close、修改、添加、删除、commit等，或者执行sqlSession.clearCache();就会清空一级缓存。 二级缓存：是mapper映射级别的缓存，多个SqlSession去操作同一个Mapper映射的sql语句，多个SqlSession可以共用二级缓存，二级缓存是跨SqlSession的。 开启二级缓存： 在SqlMapConfig.xml文件中，开启二级缓存（已默认开启，这一步可省略） 12345&gt; &lt;settings&gt; &gt; &lt;!-- 开启二级缓存的支持,默认值为true,改为false代表不开启二级缓存 --&gt; &gt; &lt;setting name="cacheEnabled" value="true"/&gt; &gt; &lt;/settings&gt;&gt; 配置相关的Mapper映射文件 12345&gt; &lt;mapper namespace="dao.IUserDao"&gt; &gt; &lt;!-- 开启二级缓存的支持 --&gt; &gt; &lt;cache/&gt;&gt; &lt;/mapper&gt;&gt; 配置statement上面的useCache属性 1234&gt; &lt;!-- 根据id查询 --&gt; &gt; &lt;select id="findById" resultType="user" parameterType="int" useCache="true"&gt; select * from user where id = #&#123;uid&#125; &gt; &lt;/select&gt;&gt; 注意事项 针对每次查询都需要最新的数据sql，要设置成useCache=false，禁用二级缓存。 使用二级缓存的类一定要实现java.io.Serializable接口，这样就可以使用序列化方式来保存对象。 12. 注解开发 @Insert:实现新增 @Update:实现更新 @Delete:实现删除 @Select:实现查询 @Result:实现结果集封装 12345678&gt; 代替了 &lt;id&gt;标签和&lt;result&gt;标签&gt; @Result中属性介绍： &gt; id 是否是主键字段 &gt; column 数据库的列名 &gt; property需要装配的属性名 &gt; one 需要使用的@One注解（@Result（one=@One）（））） &gt; many 需要使用的@Many注解（@Result（many=@many）（）））&gt; @Results:可以与@Result一起使用，封装多个结果集 1234567891011&gt; 代替的是标签&lt;resultMap&gt;&gt; @Select("select * from user")&gt; @Results(id = "userMap", value = &#123;&gt; @Result(id = true, column = "id", property = "userId"),&gt; @Result(column="username",property="userName"),&gt; @Result(column="sex",property="userSex"),&gt; @Result(column="address",property="userAddress"),&gt; @Result(column="birthday",property="userBirthday")&gt; &#125;)&gt; List&lt;User&gt; findAll();&gt; @ResultMap:实现引用@Results定义的封装 @One:实现一对一结果集封装 123456&gt; 代替了&lt;assocation&gt;标签，是多表查询的关键，在注解中用来指定子查询返回单一对象。&gt; @Result(column="uid", property="user", &gt; one=@One(select="dao.IUserDao.findById", fetchType=FetchType.LAZY) )&gt; //select属性：代表将要执行的sql语句 &gt; //fetchType属性：代表加载方式，一般如果要延迟加载都设置为LAZY的值&gt; @Many:实现一对多结果集封装 1234&gt; 代替了&lt;Collection&gt;标签,是是多表查询的关键，在注解中用来指定子查询返回对象集合。&gt; @Result(column="id",property="accounts", &gt; many=@Many( select="dao.IAccountDao.findByUid", fetchType=FetchType.LAZY ) ) &gt; @SelectProvider: 实现动态SQL映射 @CacheNamespace:实现注解二级缓存的使用 123&gt; @CacheNamespace(blocking=true) //mybatis基于注解方式实现配置二级缓存 &gt; public interface IUserDao &#123;&#125;&gt; Spring1. Spring概述1Spring是Java SE/EE应用全栈轻量级开源框架，以IoC（Inverse Of Control：反转控制）和AOP（Aspect Oriented Programming：面向切面编程）为内核，提供了展现层Spring MVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术，还整合了众多著名第三方框架和类库，成为使用最多的Java EE企业应用开源框架。 2. 控制反转12控制反转(IoC)把创建对象的权利交给框架，是框架的重要特征，包括依赖注入和依赖查找。控制反转运用了工厂模式，在实际开发中我们可以把三层的对象都使用配置文件配置起来，当启动服务器应用加载的时候，让一个类中的方法通过读取配置文件，把这些对象创建出来并存起来。存储这些对象的map称之为容器；读取配置文件，创建和获取三层对象的类就是工厂。 12345678910111213141516171819202122232425262728293031323334353637383940414243//模拟BeanFactorypublic class BeanFactory &#123; //定义一个Properties对象 private static Properties props; //定义一个Map,用于存放我们要创建的对象。我们把它称之为容器 private static Map&lt;String,Object&gt; beans; //使用静态代码块为Properties对象赋值 static &#123; try &#123; //实例化对象 props = new Properties(); //获取properties文件的流对象 InputStream in = BeanFactory.class.getClassLoader().getResourceAsStream("bean.properties"); props.load(in); //实例化容器 beans = new HashMap&lt;String,Object&gt;(); //取出配置文件中所有的Key Enumeration keys = props.keys(); //遍历枚举 while (keys.hasMoreElements())&#123; //取出每个Key String key = keys.nextElement().toString(); //根据key获取value String beanPath = props.getProperty(key); //反射创建对象 Object value = Class.forName(beanPath).newInstance(); //把key和value存入容器中,容器里面放的是对象！ beans.put(key,value); &#125; &#125;catch(Exception e)&#123; throw new ExceptionInInitializerError("初始化properties失败！"); &#125; &#125; /** * 根据bean的名称获取对象 * @param beanName * @return */ public static Object getBean(String beanName)&#123; return beans.get(beanName); &#125;&#125; 3. Spring环境配置 添加Spring环境依赖 123456&gt; &lt;dependency&gt;&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt;&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt;&gt; &lt;version&gt;5.0.2.RELEASE&lt;/version&gt;&gt; &lt;/dependency&gt;&gt; 在rescources根目录下创建Spring的XML约束，配置文件路径 123456789101112131415161718&gt; &lt;?xml version="1.0" encoding="UTF-8"?&gt;&gt; &lt;beans xmlns="http://www.springframework.org/schema/beans"&gt; xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"&gt; xsi:schemaLocation="http://www.springframework.org/schema/beans&gt; http://www.springframework.org/schema/beans/spring-beans.xsd"&gt;&gt; &gt; &lt;bean id="accountService" class="service.impl.AccountServiceImpl"&gt;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&gt; &lt;/bean&gt;&gt; &gt; &lt;bean id="accountDao" class="dao.impl.AccountDaoImpl"&gt;&gt; &lt;!-- collaborators and configuration for this bean go here --&gt;&gt; &lt;/bean&gt;&gt; &gt; &lt;!-- more bean definitions go here --&gt;&gt; &gt; &lt;/beans&gt;&gt; 测试配置是否成功 12345678&gt; public class Client&#123;&gt; public static void main(String[] args)&#123;&gt; ApplicationContext ac = new ClassPathXmlApplicationContext("bean.xml");&gt; IAccountService aService = (IAccountService) ac.getBean("accountService");&gt; IAccountDao adao = ac.getBean("accountDao", IAccountDao.class);&gt; System.out.println(aService);&gt; System.out.println(aDao);&#125;&#125;&gt; 4. ApplicationContext BeanFactory 和 ApplicationContext的区别 BeanFactory 是Spring 容器中的顶层接口，ApplicationContext 是它的子接口。 ApplicationContext：只要一读取配置文件，默认情况下就会创建对象。 BeanFactory：在使用的时候才创建对象。 ApplicationContext 接口的实现类 ClassPathXmlApplicationContext：从类的根路径下加载配置文件（推荐使用） FileSystemXmlApplicationContext：从磁盘路径上加载配置文件，配置文件可以在磁盘的任意位置 AnnotationConfigApplicationContext：可以读取注解的spring容器，用于注解配置的容器对象 5. bean标签1用于配置对象让spring来创建的，默认情况下它调用的是类中的无参构造函数。如果没有无参构造函数则不能创建成功。 属性： id：给对象在容器中提供一个唯一标识。用于获取对象。 class：指定类的全限定类名。用于反射创建对象。默认情况下调用无参构造函数。 init-method：指定类中的初始化方法名称。 destroy-method：指定类中销毁方法名称。 scope：指定对象的作用范围。 singleton：默认值，单例的 prototype：多例的 request：WEB项目中，Spring创建一个Bean的对象并存入到request域中 session：WEB项目中，Spring创建一个Bean的对象并存入到session域中 global session：WEB项目中，Spring创建一个Bean的对象并应用在Portlet环境 实例化的三种方式： 使用默认无参构造函数：如果bean中没有默认无参构造函数，将会创建失败。 &lt;bean id=&quot;accountService&quot; class=&quot;service.impl.AccountServiceImpl&quot;/&gt; 使用静态工厂的方法创建对象： 1234&gt; public class StaticFactory &#123; &gt; public static IAccountService createAccountService()&#123; &gt; return new AccountServiceImpl(); &#125; &#125;&gt; 使用StaticFactory类中的静态方法createAccountService创建对象，并存入spring容器 &lt;bean id=&quot;accountService&quot; ​ class=&quot;factory.StaticFactory&quot; （指定静态工厂的全限定类名） ​ factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt; （指定生产对象的静态方法） 使用实例工厂的方法创建对象： 1234&gt; public class InstanceFactory &#123; &gt; public IAccountService createAccountService()&#123; &gt; return new AccountServiceImpl(); &#125; &#125;&gt; 先把工厂的创建交给spring来管理，然后在使用工厂的bean来调用里面的方法 &lt;bean id=&quot;instancFactory&quot; class=&quot;factory.InstanceFactory&quot;&gt;&lt;/bean&gt; &lt;bean id=&quot;accountService&quot; ​ factory-bean=&quot;instancFactory&quot; （用于指定实例工厂bean的id） ​ factory-method=&quot;createAccountService&quot;&gt;&lt;/bean&gt;（用于指定实例工厂中创建对象的方法） 6. 依赖注入1依赖注入：Dependency Injection，是spring框架核心ioc的具体实现。使用spring之后，业务层和持久层的依赖关系由spring来维护，我们可以通过配置标签为变量注入值和属性。 构造函数注入 1234567&gt; &lt;bean id="accountService" class="service.impl.AccountServiceImpl"&gt; &gt; &lt;constructor-arg name="name" value="张三"&gt;&lt;/constructor-arg&gt; &gt; &lt;constructor-arg name="age" value="18"&gt;&lt;/constructor-arg&gt; &gt; &lt;constructor-arg name="birthday" ref="now"&gt;&lt;/constructor-arg&gt; &gt; &lt;/bean&gt;&gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;&gt; 涉及的标签：constructor-arg 相关属性： index：指定参数在构造函数参数列表的索引位置 type：指定参数在构造函数中的数据类型 name：指定参数在构造函数中的名称，用于寻找赋值对象 value：用于赋值，能赋基本数据类型和String类型 ref：用于赋值，能赋其他bean类型，该bean类型必须在配置文件中配置过 set方法注入 12345678&gt; &lt;!-- 在类中需要提供注入成员的set方法 --&gt;&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &gt; &lt;property name="name" value="test"&gt;&lt;/property&gt; &gt; &lt;property name="age" value="21"&gt;&lt;/property&gt; &gt; &lt;property name="birthday" ref="now"&gt;&lt;/property&gt; &gt; &lt;/bean&gt; &gt; &lt;bean id="now" class="java.util.Date"&gt;&lt;/bean&gt;&gt; 涉及的标签：property 注入集合属性 1234567891011121314151617181920212223242526272829&gt; &lt;!-- 注入集合数据 List结构可用标签array,list,set；Map结构可用标签map,entry,props,prop --&gt; &gt; &lt;bean id="accountService" class="service.impl.AccountServiceImpl"&gt; &gt; &lt;!-- 在注入集合数据时，只要结构相同，标签可以互换 --&gt; &gt; &lt;!-- 注入list集合数据 --&gt; &gt; &lt;property name="myList"&gt; &gt; &lt;list&gt; &gt; &lt;value&gt;AAA&lt;/value&gt; &gt; &lt;value&gt;BBB&lt;/value&gt; &gt; &lt;value&gt;CCC&lt;/value&gt; &gt; &lt;/list&gt; &gt; &lt;/property&gt; &gt; &lt;!-- 注入Map数据 --&gt; &gt; &lt;property name="myMap"&gt; &gt; &lt;map&gt; &gt; &lt;prop key="testA"&gt;aaa&lt;/prop&gt; &gt; &lt;prop key="testB"&gt;bbb&lt;/prop&gt; &gt; &lt;/map&gt; &gt; &lt;/property&gt; &gt; &lt;!-- 注入properties数据 --&gt;&gt; &lt;property name="myProps"&gt; &gt; &lt;prop&gt;&gt; &lt;entry key="testA" value="aaa"&gt;&lt;/entry&gt;&gt; &lt;entry key="testB"&gt; &gt; &lt;value&gt;bbb&lt;/value&gt; &gt; &lt;/entry&gt; &gt; &lt;/prop&gt; &gt; &lt;/property&gt; &gt; &lt;/bean&gt;&gt; 7. 基于XML配置的CRUD 配置文件 bean.xml 123456789101112131415161718192021222324252627282930&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"&gt; &lt;!-- 配置Service --&gt; &lt;bean id="accountService" class="service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;/bean&gt; &lt;bean id="accountDao" class="dao.impl.AccountDaoImpl"&gt; &lt;property name="runner" ref="runner"/&gt; &lt;/bean&gt; &lt;!--配置QueryRunner--&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;!--注入数据源--&gt; &lt;constructor-arg name="ds" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt;&lt;/beans&gt; 持久层文件 AccountDaoImpl.java 1234567891011121314public class AccountDaoImpl implements IAccountDao &#123; private QueryRunner runner; //由spring框架来赋值，需要set方法 public void setRunner(QueryRunner runner) &#123; this.runner = runner; &#125; @Override public List&lt;Account&gt; findAllAccount() &#123; try&#123; return runner.query("select * from account", new BeanListHandler&lt;Account&gt;(Account.class)); &#125;catch (Exception e) &#123; throw new RuntimeException(e); &#125; &#125; 业务层文件 AccountServiceImpl.java 12345678910public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; //由spring框架来赋值，需要set方法 public void setAccountDao(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; 测试文件 AccountServiceTest.java 123456789101112//@RunWith将Junit运行器替换成spring运行器，为了提供spring的容器@RunWith(SpringJUnit4ClassRunner.class)//@ContextConfiguration指定spring配置文件的位置@ContextConfiguration(locations = "classpath:bean.xml")public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = as.findAllAccount(); for(Account account : accounts)&#123; System.out.println(account);&#125;&#125; 8. 基于XML+注解的IoC配置 配置文件 bean.xml 1234567891011121314151617181920212223242526&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;context:component-scan base-package="com"/&gt; &lt;!--配置QueryRunner--&gt; &lt;bean id="runner" class="org.apache.commons.dbutils.QueryRunner" scope="prototype"&gt; &lt;!--注入数据源--&gt; &lt;constructor-arg name="ds" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;!--连接数据库的必备信息--&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql://localhost:3306/eesy"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt;&lt;/beans&gt; 持久层文件 AccountDaoImpl.java 1234567891011@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private QueryRunner runner; @Override public List&lt;Account&gt; findAllAccount() &#123; try&#123; return runner.query("select * from account", new BeanListHandler&lt;Account&gt;(Account.class)); &#125;catch (Exception e) &#123; throw new RuntimeException(e);&#125;&#125; 业务层文件 AccountServiceImpl.java 12345678@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; 测试文件 AccountServiceTest.java 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(locations = "classpath:bean.xml")public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = as.findAllAccount(); for(Account account : accounts)&#123; System.out.println(account);&#125;&#125; 9. 基于纯注解的IoC配置 SpringConfiguration.java 12345@Configuration //指定当前类是一个配置类@ComponentScan("com") //指定spring在创建容器时要扫描的包@Import(JdbcConfig.class) //导入其他的配置类@PropertySource("classpath:jdbcConfig.properties") //指定properties文件的位置public class SpringConfiguration &#123;&#125; JdbcConfig.java 1234567891011121314151617181920212223242526272829public class JdbcConfig &#123; @Value("$&#123;jdbc.driver&#125;") private String driver; @Value("$&#123;jdbc.url&#125;") private String url; @Value("$&#123;jdbc.username&#125;") private String username; @Value("$&#123;jdbc.password&#125;") private String password; //创建一个QueryRunner对象 @Bean(name="runner") @Scope("prototype") public QueryRunner createQueryRunner(DataSource dataSource)&#123; return new QueryRunner(dataSource); &#125; //创建数据源对象 @Bean(name="ds") public DataSource createDataSource()&#123; try &#123; ComboPooledDataSource ds = new ComboPooledDataSource(); ds.setDriverClass(driver); ds.setJdbcUrl(url); ds.setUser(username); ds.setPassword(password); return ds; &#125;catch (Exception e)&#123; throw new RuntimeException(e);&#125;&#125;&#125; 持久层文件 AccountDaoImpl.java 1234567891011@Repository("accountDao")public class AccountDaoImpl implements IAccountDao &#123; @Autowired private QueryRunner runner; @Override public List&lt;Account&gt; findAllAccount() &#123; try&#123; return runner.query("select * from account", new BeanListHandler&lt;Account&gt;(Account.class)); &#125;catch (Exception e) &#123; throw new RuntimeException(e);&#125;&#125; 业务层文件 AccountServiceImpl.java 12345678@Service("accountService")public class AccountServiceImpl implements IAccountService &#123; @Autowired private IAccountDao accountDao; @Override public List&lt;Account&gt; findAllAccount() &#123; return accountDao.findAllAccount(); &#125; 测试文件 AccountServiceTest.java 12345678910@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class) //由.xml换成.class文件public class AccountServiceTest &#123; @Autowired private IAccountService as; @Test public void testFindAll() &#123; List&lt;Account&gt; accounts = as.findAllAccount(); for(Account account : accounts)&#123; System.out.println(account);&#125;&#125; 10. IoC中的注解用于创建对象@Component 作用： 把资源让spring来管理。相当于在xml中配置一个bean。 属性： value：指定bean的id。如果不指定value属性，默认bean的id是当前类的类名。首字母小写。 衍生注解：@Controller，@Service，@Repository 作用属性都相同，提供更加明确的语义化 @Controller 一般用于表现层的注解 @Service 一般用于业务层的注解 @Repository 一般用于持久层的注解 用于注入数据@Autowired 作用：可以注解在变量上，按照变量类型在spring容器中匹配后注入，set方法可以省略。它只能注入其他bean类型。当有多个类型匹配时，使用要注入的对象变量名称作为bean的id，在spring容器查找，找到了也可以注入成功，找不到就报错。 @Qualifier 作用：在自动按照类型注入的基础之上，再按照Bean的id注入。它在给字段注入时不能独立使用，必须和@Autowire一起使用；但是给方法参数注入时，可以独立使用。 属性：value：指定bean的id。 @Resource 作用： 直接按照Bean的id注入。它也只能注入其他bean类型。 属性： name：指定bean的id。（“name“不能省略） @value 作用： 注入基本数据类型和String类型数据的。 属性： value：用于指定值。 用于改变作用范围@Scope 作用： 指定bean的作用范围。 属性： value：指定范围的值。 取值：singleton，prototype，request，session，globalsession 生命周期相关@PostConstruct 作用： 用于指定初始化方法。 @PreDestroy 作用： 用于指定销毁方法。 用于配置文件@Configuration 作用： 用于指定当前类是一个spring配置类，当创建容器时会从该类上加载注解。 获取容器时需要使用AnnotationApplicationContext(有@Configuration注解的类.class)。 属性： value:用于指定配置类的字节码 @ComponentScan 作用：用于指定spring在初始化容器时要扫描的包。 属性：basePackages：用于指定要扫描的包。和该注解中的value属性作用一样。 @Bean 作用： 该注解只能写在方法上，表明使用此方法创建一个对象，并且放入spring容器。 属性： name：给当前@Bean注解方法创建的对象指定一个名称(即bean的id）。 @PropertySource 作用：用于加载.properties文件中的配置。例如我们配置数据源时，可以把连接数据库的信息写到properties配置文件中，就可以使用此注解指定properties配置文件的位置。 属性： value[]：用于指定properties文件位置。如果是在类路径下，需要写上classpath: @Import 作用： 用于导入其他配置类，在引入其他配置类时，可以不用再写@Configuration注解。 属性： value[]：用于指定其他配置类的字节码。 用于整合Junit@RunWith @RunWith(SpringJUnit4ClassRunner.class) 作用：将Junit运行器替换成spring运行器，提供spring的容器 @ContextConfiguration @ContextConfiguration(locations= {&quot;classpath:bean.xml&quot;}) 作用：指定spring配置文件的位置 11. AOP1AOP，全称是Aspect Oriented Programming，即面向切面编程。通过把程序重复的代码抽取出来，在需要执行的时候，使用动态代理的技术，在不修改源码的基础上，对已有的方法进行增强。 相关术语： Joinpoint(连接点)：指被拦截到的点，在spring中指的是被拦截到的方法。 Pointcut(切入点)：指被拦截后进行增强修改的Joinpoint。 Advice(通知/增强)：拦截到Joinpoint之后所要做的事情就是通知。 通知的类型：前置通知，后置通知，异常通知，最终通知，环绕通知。 Introduction(引介)：在不修改类代码的前提下，引介可以在运行期为类动态地添加一些方法或Field。 Target(目标对象)：代理的目标对象。 Weaving(织入)：是指把增强应用到目标对象来创建新的代理对象的过程。spring采用动态代理织入，而AspectJ采用编译期织入和类装载期织入。 Proxy（代理）：一个类被AOP织入增强后，就产生一个结果代理类。 Aspect(切面)：是切入点和通知（引介）的结合。 12. 基于XML的AOP配置 配置文件 bean.xml 123456789101112131415161718192021222324252627&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置service对象 --&gt; &lt;bean id="accountService" class="service.impl.AccountServiceImpl"/&gt; &lt;!-- 配置Logger类 --&gt; &lt;bean id="logger" class="utils.Logger"/&gt; &lt;!-- 配置AOP --&gt; &lt;aop:config&gt; &lt;!-- 配置切入点表达式 --&gt; &lt;aop:pointcut id="pt1" expression="execution(* service.impl.*.*(..) )"/&gt; &lt;!-- 配置切面 --&gt; &lt;aop:aspect id="logAdvice" ref="logger"&gt; &lt;!-- 配置通知类型，通知方法和切入点方法 --&gt; &lt;aop:before method="before" pointcut-ref="pt1"/&gt; &lt;aop:after-returning method="afterRunning" pointcut-ref="pt1"/&gt; &lt;aop:after-throwing method="afterThrowing" pointcut-ref="pt1"/&gt; &lt;aop:after method="after" pointcut-ref="pt1"/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 13. AOP配置中的标签 &lt;aop:config&gt;：用于声明开始aop的配置 &lt;aop:pointcut&gt;：用于配置切入点表达式，指定对哪些类的哪些方法进行增强 expression：用于定义切入点表达式 id：用于给切入点表达式提供一个唯一标识 &lt;aop:aspect&gt;：用于配置切面 id：给切面提供一个唯一标识 ref：引用配置好的通知类bean的id &lt;aop:before&gt;：用于配置前置通知，指定增强的方法在切入点方法之前执行 &lt;aop:after-returning&gt;：用于配置后置通知 &lt;aop:after-throwing&gt;：用于配置异常通知 &lt;aop:after&gt;：用于配置最终通知 &lt;aop:around&gt;：用于配置环绕通知，通常独立使用，可以手动控制增强代码的执行时机 method：指定通知中方法的名称 pointct：定义切入点表达式 pointcut-ref：指定切入点表达式的引用 切入点表达式123456789101112131415161718192021222324表达式语法：execution([修饰符] 返回值类型 包名.类名.方法名(参数)) 写法说明： 全匹配方式： public void service.impl.AccountServiceImpl.saveAccount(domain.Account) 访问修饰符可以省略 void service.impl.AccountServiceImpl.saveAccount(domain.Account)返回值可以使用*号，表示任意返回值 * service.impl.AccountServiceImpl.saveAccount(domain.Account) 包名可以使用*号，表示任意包，但是有几级包，需要写几个* *.*.AccountServiceImpl.saveAccount(domain.Account) 使用..来表示当前包，及其子包 * service..AccountServiceImpl.saveAccount(domain.Account) 类名可以使用*号，表示任意类 * service..*.saveAccount(domain.Account) 方法名可以使用*号，表示任意方法* service..*.*(domain.Account) 参数列表可以使用*，表示参数可以是任意数据类型，但是必须有参数 * service..*.*(*) 参数列表可以使用..表示有无参数均可，有参数可以是任意类型 * service..*.*(..) 全通配方式* *..*.*(..) 注： 通常情况下，我们都是对业务层的方法进行增强，所以切入点表达式都是切到业务层实现类。 execution(* service.impl.*.*(..)) 14. 环绕通知1234567891011121314//spring框架为我们提供了一个接口：ProceedingJoinPoint，它可以作为环绕通知的方法参数，在环绕通知执行时，spring框架会为我们提供该接口的实现类对象，我们直接使用就行。public Object transactionAround(ProceedingJoinPoint pjp) &#123; Object rtValue = null; //定义返回值 try &#123; Object[] args = pjp.getArgs(); //获取方法执行所需的参数 beginTransaction(); //前置通知：开启事务 rtValue = pjp.proceed(args); //执行方法 commit(); //后置通知：提交事务 &#125;catch(Throwable e) &#123; rollback(); //异常通知：回滚事务 e.printStackTrace(); &#125; finally &#123; release(); &#125; //最终通知：释放资源 return rtValue; &#125; 15. 基于注解的AOP配置 配置文件 bean.xml 导入context的空间名称 12345678910111213141516&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 告知spring，在创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"/&gt; &lt;!-- 开启spring对注解AOP的支持 --&gt; &lt;aop:aspectj-autoproxy/&gt;&lt;/beans&gt; AccountServiceImpl.java 把资源使用注解配置 12345@Service("accountService")public class AccountServiceImpl implements IAccountService&#123; @Override public void saveAccount() &#123; System.out.println("执行了保存");&#125;&#125; Logger.java 方式一：通知类使用注解配置 1234567891011121314151617@Component("logger")@Aspect //把当前类声明为切面类public class Logger &#123; @Pointcut("execution(* com.itheima.service.impl.*.*(..) )") private void pt1()&#123;&#125; //指定切入点表达式 @Before("pt1()") //注意：千万别忘了写括号 public void before()&#123;System.out.println("前置通知");&#125; @AfterReturning("pt1()") public void afterRunning()&#123;System.out.println("后置通知");&#125; @AfterThrowing("pt1()") public void afterThrowing()&#123;System.out.println("异常通知");&#125; @After(("pt1()") public void after()&#123;System.out.println("最终通知");&#125;&#125; Logger.java 方式二：通知类使用环绕注解配置 1234567891011121314@Component("logger")@Aspect //把当前类声明为切面类public class Logger &#123; @Around("execution(* com.itheima.service.impl.*.*(..) )") public void transactionAround(ProceedingJoinPoint pjp) &#123; System.out.println("前置通知"); try &#123; pjp.proceed(); //执行切入点的方法 System.out.println("后置通知"); &#125; catch (Throwable throwable) &#123; System.out.println("异常通知"); &#125;finally &#123; System.out.println("最终通知"); &#125;&#125;&#125; SpringConfiguration.java 配置后可完全删除xml文件 12345@Configuration@ComponentScan(basePackages="com.itheima")@EnableAspectJAutoProxypublic class SpringConfiguration &#123;&#125; 基于纯注解的测试方法 12345678@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class Test01 &#123; @Autowired private IAccountService accountService; @Test public void testAccount()&#123; accountService.saveAccount();&#125;&#125; 16. JdbcDaoSupport 12345678910111213JdbcDaoSupport是spring框架为我们提供的一个类，该类中定义了一个JdbcTemplate对象，持久层实现类Dao通过继承该类可以直接获得JdbcTemplate对象。但是要想创建该对象，需要为其提供一个数据源：具体源码如下：public abstract class JdbcDaoSupport extends DaoSupport &#123; //定义对象 private JdbcTemplate jdbcTemplate; //set方法注入数据源，判断是否注入了，注入了就创建JdbcTemplate public final void setDataSource(DataSource dataSource) &#123; if (this.jdbcTemplate == null || dataSource != this.jdbcTemplate.getDataSource()) &#123; //如果提供了数据源就创建JdbcTemplate this.jdbcTemplate = createJdbcTemplate(dataSource); initTemplateConfig(); &#125; &#125; //使用数据源创建JdcbTemplate protected JdbcTemplate createJdbcTemplate(DataSource dataSource) &#123; return new JdbcTemplate(dataSource); &#125; 通过让Dao继承JdbcDaoSupport的方式，只能用于基于XML的方式，注解用不了。 17. Spring中的事务控制 事务的隔离级别(isolation)： READ_UNCOMMITTED READ_COMMITTED REPEATABLE_READ SERIALIZABLE 事务的传播行为(propagation)： REQUIRED：如果当前没有事务，就创建一个；如果已存在，就加入这个事务中。（默认值） SUPPORTS：使用当前事务，如果当前没有事务，就以非事务方式执行 MANDATORY：使用当前事务，如果当前没有事务，就抛出异常 REQUERS_NEW：新建事务，如果当前有事务，把当前事务挂起 NOT_SUPPORTED：以非事务方式执行操作，如果当前有事务，把当前事务挂起 NEVER：以非事务方式执行操作，如果当前有事务，抛出异常 NESTED：如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行REQUIRED类操作 超时时间(timeout)： 默认值是-1，没有超时限制。如果有值，以秒为单位进行设置 只读事务(read-only)： 是否只读事务，查询时一般设置为只读 18. 基于XML的声明式事务控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 导入aop和tx两个名称空间 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd"&gt; &lt;!-- 配置service --&gt; &lt;bean id="accountService" class="com.itheima.service.impl.AccountServiceImpl"&gt; &lt;property name="accountDao" ref="accountDao"/&gt; &lt;/bean&gt; &lt;!-- 配置dao --&gt; &lt;bean id="accountDao" class="com.itheima.dao.impl.AccountDaoImpl"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy" /&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- 配置一个事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 事务的配置 --&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;!-- 配置事务的属性 --&gt; &lt;tx:attributes&gt; &lt;tx:method name="find*" propagation="SUPPORTS" read-only="true"/&gt; &lt;tx:method name="*" propagation="REQUIRED" read-only="false"/&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!-- 配置AOP切入点表达式 --&gt; &lt;aop:config&gt; &lt;aop:pointcut id="pt1" expression="execution(* com.itheima.service.impl.*.*(..))"/&gt; &lt;!-- 建立事务的通知和切入点表达式的关系 --&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut-ref="pt1"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 19. 基于注解的声明式事务控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!-- 导入context和tx两个名称空间 --&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:tx="http://www.springframework.org/schema/tx" xmlns:context="http://www.springframework.org/schema/context" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 告知spring，在创建容器时要扫描的包 --&gt; &lt;context:component-scan base-package="com.itheima"/&gt; &lt;!-- 配置jdbcTemplate --&gt; &lt;bean id="jdbcTemplate" class="org.springframework.jdbc.core.JdbcTemplate"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 配置数据源 --&gt; &lt;bean id="dataSource" class="org.springframework.jdbc.datasource.DriverManagerDataSource"&gt; &lt;property name="driverClassName" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="url" value="jdbc:mysql://localhost:3306/eesy" /&gt; &lt;property name="username" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!-- 配置一个事务管理器 --&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!-- 开启spring对注解事务的支持 --&gt; &lt;tx:annotation-driven transaction-manager="transactionManager"/&gt;&lt;/beans&gt;&lt;!-- 在业务层需要的地方使用@Transactional注解 --&gt;@Transactional注解可以出现在接口上，类上和方法上。 出现接口上，表示该接口的所有实现类都有事务支持。 出现在类上，表示类中所有方法有事务支持。出现在方法上，表示方法有事务支持。 以上三个位置的优先级：方法&gt;类&gt;接口 SpringMVC1. SpringMVC概述1SpringMVC是一种基于Java的实现MVC设计模型的请求驱动类型的轻量级Web框架，属于Spring FrameWork的后续产品，已经融合在Spring Web Flow里面。它通过一套注解，让一个简单的Java类成为处理请求的控制器，而无须实现任何接口，同时它还支持RESTful编程风格的请求。 2. SpringMVC快速入门 创建Maven工程，工程参数中添加键值对archetypeCatalog：internal，解决项目创建过慢的问题 web.xml 配置核心控制器 12345678910111213141516&lt;!-- 配置spring mvc的核心控制器 --&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 配置初始化参数，用于读取SpringMVC的配置文件 --&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 配置servlet的对象的创建时间点：应用加载时创建。 取值只能是非0正整数，表示启动顺序 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; SpringMVC.xml 配置文件 12345678910111213141516171819202122232425&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package="cn.itcast"/&gt; &lt;!-- 视图解析器对象,拼接前缀和后缀,进行请求转发 --&gt; &lt;bean id="internalResourceViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 开启SpringMVC框架注解的支持 --&gt; &lt;mvc:annotation-driven /&gt; &lt;!-- 设置所有静态资源不拦截 --&gt; &lt;mvc:default-servlet-handler/&gt;&lt;/beans&gt; HelloController.java 编写控制器 123456789@Controller@RequestMapping(path = "/hello")public class HelloController &#123; @RequestMapping(path = "/world") public String sayHello()&#123; System.out.println("Hello StringMVC"); return "success"; &#125;&#125; 3. SpringMVC组件 前端控制器（DispatcherServlet） 用户请求到达前端控制器，它就相当于mvc 模式中的c，dispatcherServlet 是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。 处理器映射器（HandlerMapping） HandlerMapping 负责根据用户请求找到Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 处理器（Handler） 开发中要编写的具体业务控制器。由DispatcherServlet 把用户请求转发到Handler。由Handler 对具体的用户请求进行处理。 处理器适配器（HandlerAdapter） 通过HandlerAdapter 对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 视图解析器（ViewResolver） View Resolver 负责将处理结果生成View 视图，View Resolver 首先根据逻辑视图名解析成物理视图名即具体的页面地址，再生成View 视图对象，最后对View 进行渲染将处理结果通过页面展示给用户。 12345678910111213141516171819在SpringMVC 的各个组件中，处理器映射器、处理器适配器、视图解析器称为SpringMVC 的三大组件。在SpringMVC.xml配置文件中使用&lt;mvc:annotation-driven&gt;注解可替代处理器映射器和处理器适配器的配置。相当于在xml 中配置了：&lt;!-- Begin --&gt;&lt;!-- HandlerMapping --&gt;&lt;beanclass="org.springframework.web.servlet.mvc.method.annotation. RequestMappingHandlerMapping"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"&gt;&lt;/bean&gt; &lt;!-- HandlerAdapter --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation. RequestMappingHandlerAdapter"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.HttpRequestHandlerAdapter"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.SimpleControllerHandlerAdapter"&gt;&lt;/bean&gt; &lt;!-- HadnlerExceptionResolvers --&gt; &lt;bean class="org.springframework.web.servlet.mvc.method.annotation. ExceptionHandlerExceptionResolver"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.annotation. ResponseStatusExceptionResolver"&gt;&lt;/bean&gt; &lt;bean class="org.springframework.web.servlet.mvc.support. DefaultHandlerExceptionResolver"&gt;&lt;/bean&gt; &lt;!-- End --&gt; 4. 请求参数的绑定12SpringMVC绑定请求参数的过程是通过把表单提交请求参数，作为控制器中方法参数进行绑定的。&lt;a href="account/findAccount?accountId=10"&gt;查询账户&lt;/a&gt; 1234@RequestMapping("/findAccount") public String findAccount(Integer accountId) &#123; System.out.println("查询了账户"+accountId); //自动获取到accountId=10 return "success"; &#125; 支持的数据类型 基本类型： 包括基本类型和String类型 要求参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) POJO类型参数： 包括实体类，以及关联的实体类 要求控制器方法的参数类型是POJO类型，并且表单中参数名称和POJO类的属性名称保持一致。 数组和集合类型参数： 包括List结构和Map结构的集合（包括数组） 第一种方式要求集合类型的请求参数必须在POJO中。在表单中请求参数名称要和POJO中集合属性名称相同。给List集合中的元素赋值，使用下标。 给Map集合中的元素赋值，使用键值对。 第二种方式要求接收的请求参数是json格式数据，需要借助一个注解实现。 5. 设置编码过滤器post请求方式：在web.xml中配置一个过滤器 1234567891011121314&lt;!--中文乱码过滤器--&gt;&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;!-- 过滤所有请求 --&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; get请求方式：修改tomcat的server.xml配置文件 123&lt;Connector connectionTimeout="20000" port="8080" protocol="HTTP/1.1" redirectPort="8443" URIEncoding="UTF-8"/&gt; &lt;!-- 添加URIEncoding参数 --&gt; 6. 常用注解：@RequestMapping123@Target(&#123;ElementType.METHOD, ElementType.TYPE&#125;) @Retention(RetentionPolicy.RUNTIME) 用于建立请求URL和处理请求方法之间的对应关系 出现位置： 类上：请求URL的第一级访问目录，不写的话相当于应用的根目录。写的话需要以/开头使URL可以按照模块化管理。 方法上：请求URL的第二级访问目录。 属性： value：用于指定请求的URL，和path属性的作用是一样的。 method：用于指定请求的方式。 params：用于指定限制请求参数的条件。要求请求参数的key和value必须和配置的一模一样。例如： 123&gt; params = &#123;"accountName"&#125;，表示请求参数必须有accountName &gt; params = &#123;"moeny!100"&#125;，表示请求参数中money不能是100。&gt; headers：用于指定限制请求消息头的条件。 jsp中的访问方式： 1234567&gt; &lt;body&gt; &gt; &lt;!-- 第一种访问方式 --&gt; &gt; &lt;a href="$&#123;pageContext.request.contextPath&#125;/account/findAccount"&gt; 查询账户 &lt;/a&gt; &gt; &lt;!-- 第二种访问方式 --&gt; &gt; &lt;a href="account/findAccount"&gt;查询账户&lt;/a&gt; &lt;!-- 不要在访问URL前面加/ --&gt;&gt; &lt;/body&gt;&gt; @RequestParam1作用：把请求中指定名称的参数给控制器中的形参赋值。 属性： value：请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true，表示必须提供，如果不提供将报错。 123&gt; &lt;!-- requestParams注解的使用 --&gt; &gt; &lt;a href="springmvc/useRequestParam?name=test"&gt;requestParam注解&lt;/a&gt;&gt; 123456&gt; @RequestMapping("/useRequestParam") &gt; public String useRequestParam(@RequestParam("name")String username))&#123; &gt; System.out.println(username); //运行结果，获取name=test&gt; return "success"; &gt; &#125;&gt; @RequestBody1用于获取请求体内容。直接使用得到是key=value&amp;key=value...结构的数据。get请求方式不适用。 属性： required：是否必须有请求体。默认值是:true。当取值为true时,get请求方式会报错。如果取值为false，get请求得到是null。 12345678910&gt; &lt;!-- requestBody注解的使用 --&gt; &gt; &lt;!-- post请求jsp代码 --&gt; &gt; &lt;form action="springmvc/useRequestBody" method="post"&gt; &gt; 用户名称：&lt;input type="text" name="username" &gt;&lt;br/&gt; &gt; 用户密码：&lt;input type="password" name="password" &gt;&lt;br/&gt; &gt; 用户年龄：&lt;input type="text" name="age" &gt;&lt;br/&gt; &gt; &lt;input type="submit" value="保存"&gt; &gt; &lt;!-- get请求jsp代码 --&gt;&gt; &lt;a href="springmvc/useRequestBody?body=test"&gt;requestBody注解get请求&lt;/a&gt;&gt; 12&gt; @RequestMapping(&quot;/useRequestBody&quot;) public String useRequestBody(@RequestBody(required=false) String body)&#123; System.out.println(body); return &quot;success&quot;; &#125;&gt; @PathVaribale12用于绑定url中的占位符。例如：请求url中 /delete/&#123;id&#125;，这个&#123;id&#125;就是url占位符。 url支持占位符是spring3.0之后加入的。是springmvc支持rest风格URL的一个重要标志。 12&lt;!-- PathVaribale注解的使用 --&gt; &lt;a href="springmvc/usePathVariable/100"&gt;pathVariable注解&lt;/a&gt; 1234@RequestMapping("/usePathVariable/&#123;id&#125;") public String usePathVariable(@PathVariable("id") Integer id)&#123; System.out.println(id); return "success"; &#125; 7. 返回值分类 字符串 controller方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。 使用关键字的方式进行转发或者重定向： 转发：return &quot;forward:/WEB-INF/pages/success.jsp&quot; 重定向：return &quot;redirect:/index.jsp&quot; 注：如果是重定向到jsp页面，则jsp页面不能写在WEB-INF目录中，否则无法找到。 void 在controller方法形参上可以定义request和response，使用request或response指定响应结果： 使用request转向页面：request.getRequestDispatcher(&quot;/WEBINF/pages/success.jsp&quot;). forward(request, response); 通过response页面重定向：response.sendRedirect(&quot;testRetrunString&quot;) 通过response指定响应结果： response.setCharacterEncoding(&quot;utf-8&quot;); response.setContentType(&quot;application/json;charset=utf-8&quot;); response.getWriter().write(&quot;json串&quot;); ModelAndView ModelAndView是SpringMVC为我们提供的一个对象，该对象中有两个方法，对象可以作为返回值。 12345678910&gt; public ModelAndView testModelAndView() &#123;&gt; ModelAndView mv = new ModelAndView();&gt; User user = new User("Eric", "123", 18);&gt; //addObject方法将参数封装到对象中，在页面上可以通过el表达式直接获取 $&#123;user.username&#125;&gt; mv.addObject("user", user);&gt; //setViewName用于设置逻辑视图名称，视图解析器会根据名称前往指定的视图&gt; mv.setViewName("success");&gt; return mv;&gt; &#125;&gt; 8. ResponseBody响应json数据 使用JQuery进行异步请求时，DispatcherServlet会拦截到所有的资源，导致一个问题就是静态资源（img、css、js）也会被拦截到，从而不能被使用。需在springmvc.xml配置文件设置静态资源不过滤 1234&lt;!-- 设置静态资源不过滤 --&gt;&lt;mvc:resources location="/css/" mapping="/css/**"/&gt; &lt;mvc:resources location="/images/" mapping="/images/**"/&gt; &lt;mvc:resources location="/js/" mapping="/js/**"/&gt; response.jsp 123456789101112131415161718192021222324252627&lt;head&gt; &lt;title&gt;Title&lt;/title&gt; &lt;script src="js/jquery.min.js"&gt;&lt;/script&gt; &lt;script&gt; // 页面加载，绑定单击事件 $(function()&#123; $("#btn").click(function()&#123; alert("hello btn"); $.ajax(&#123; // 编写json格式，设置属性和值 url:"user/testAjax", contentType:"application/json;charset=UTF-8", data:'&#123;"username":"hehe","password":"123","age":30&#125;', dataType:"json", type:"post", success:function(data)&#123; // data服务器端响应的json的数据，进行解析 alert(data); alert(data.username); alert(data.password); alert(data.age); &#125;&#125;);&#125;);&#125;); &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;button id="btn"&gt;发送ajax的请求&lt;/button&gt;&lt;/body&gt; UserController.java 1234567891011@RequestMapping("/testAjax") public @ResponseBody User testAjax(@RequestBody User user)&#123; System.out.println("testAjax方法执行了..."); // 客户端发送ajax的请求，传的是json字符串，后端把json字符串封装到user对象中 System.out.println(user); // 做响应，模拟查询数据库 user.setUsername("haha"); user.setAge(40); // 做响应 return user; &#125; Json字符串和JavaBean对象互相转换的过程中，需要使用jackson的jar包 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; 9. 实现文件上传12345678910111213141516171819202122232425262728293031323334353637/*** 传统文件上传* @return*/@RequestMapping("/fileupload1")public String fileuoload1(HttpServletRequest request) throws Exception &#123; System.out.println("文件上传..."); // 使用fileupload组件完成文件上传 String path = request.getSession().getServletContext().getRealPath("/uploads/"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 解析request对象，获取上传文件项 DiskFileItemFactory factory = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(factory); // 解析request List&lt;FileItem&gt; items = upload.parseRequest(request); // 遍历 for(FileItem item:items)&#123; // 进行判断，当前item对象是否是上传文件项 if(item.isFormField())&#123; // 说明普通表单向 &#125;else&#123; // 说明上传文件项，获取上传文件的名称 String filename = item.getName(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace("-", ""); filename = uuid+"_"+filename; // 完成文件上传 item.write(new File(path,filename)); // 删除临时文件 item.delete();&#125;&#125; return "success";&#125; 123456789101112131415161718192021222324/** * SpringMVC文件上传 * @return */@RequestMapping("/fileupload2")public String fileuoload2(HttpServletRequest request, MultipartFile upload) throws Exception &#123; System.out.println("springmvc文件上传..."); // 使用fileupload组件完成文件上传 String path = request.getSession().getServletContext().getRealPath("/uploads/"); // 判断，该路径是否存在 File file = new File(path); if(!file.exists())&#123; // 创建该文件夹 file.mkdirs(); &#125; // 说明上传文件项，获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace("-", ""); filename = uuid+"_"+filename; // 完成文件上传 upload.transferTo(new File(path,filename)); return "success";&#125; 12345678910111213141516171819202122/*** 跨服务器文件上传* @return*/@RequestMapping("/fileupload3")public String fileuoload3(MultipartFile upload) throws Exception &#123; System.out.println("跨服务器文件上传..."); // 定义上传文件服务器路径 String path = "http://localhost:9090/uploads/"; // 说明上传文件项，获取上传文件的名称 String filename = upload.getOriginalFilename(); // 把文件的名称设置唯一值，uuid String uuid = UUID.randomUUID().toString().replace("-", ""); filename = uuid+"_"+filename; // 创建客户端的对象 Client client = Client.create(); // 和图片服务器进行连接 WebResource webResource = client.resource(path + filename); // 上传文件 webResource.put(upload.getBytes()); return "success";&#125; 123456&lt;%-- 文件上传jsp页面 --%&gt;&lt;h3&gt;Springmvc文件上传&lt;/h3&gt;&lt;form action="/user/fileupload2" method="post" enctype="multipart/form-data"&gt; 选择文件：&lt;input type="file" name="upload"/&gt;&lt;br/&gt; &lt;input type="submit" value="上传" /&gt;&lt;/form&gt; 10. SpringMVC拦截器1SpringMVC的处理器拦截器类似于Servlet开发中的过滤器Filter，用于对处理器进行预处理和后处理。它是AOP思想的具体应用。要自定义拦截器，要求必须实现：HandlerInterceptor接口。 过滤器和拦截器的区别 过滤器是servlet规范中的一部分，任何java web工程都可以使用。 拦截器是SpringMVC框架自己的，只有使用了SpringMVC框架的工程才能用。 过滤器在url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器它是只会拦截访问的控制器方法，对jsp，html，css，image或者js是不会进行拦截的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * 自定义拦截器 */public class MyInterceptor1 implements HandlerInterceptor&#123; /** * 预处理，controller方法执行前 * return true 放行，执行下一个拦截器，如果没有，执行controller中的方法 * return false不放行 * @param request * @param response * @param handler * @return * @throws Exception */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println("MyInterceptor1执行了..."); return true; &#125; /** * 后处理方法，controller方法执行后，success.jsp执行之前 * @param request * @param response * @param handler * @param modelAndView * @throws Exception */ public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123; System.out.println("MyInterceptor1执行了...后1111"); &#125; /** * success.jsp页面执行后，该方法会执行 * @param request * @param response * @param handler * @param ex * @throws Exception */ public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123; System.out.println("MyInterceptor1执行了..."); &#125;&#125; SSM环境搭建1. pom.xml引入坐标依赖123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134 &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.0.2.RELEASE&lt;/spring.version&gt; &lt;slf4j.version&gt;1.6.6&lt;/slf4j.version&gt; &lt;log4j.version&gt;1.2.12&lt;/log4j.version&gt; &lt;mysql.version&gt;5.1.6&lt;/mysql.version&gt; &lt;mybatis.version&gt;3.4.5&lt;/mybatis.version&gt; &lt;/properties&gt;&lt;dependencies&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.6.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;$&#123;mysql.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;jstl&lt;/groupId&gt; &lt;artifactId&gt;jstl&lt;/artifactId&gt; &lt;version&gt;1.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log start --&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;$&#123;log4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;$&#123;slf4j.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;!-- log end --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;$&#123;mybatis.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis-spring&lt;/artifactId&gt; &lt;version&gt;1.3.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;c3p0&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.1.2&lt;/version&gt; &lt;type&gt;jar&lt;/type&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt;&lt;/dependencies&gt; 2. 搭建项目骨架 创建domain目录，编写实体类 创建dao目录，编写dao接口，添加方法，通过注解配置sql语句 123456789@Repositorypublic interface AccountDao &#123; @Select("select * from account") public List&lt;Account&gt; findAll(); @Insert("insert into account (name,money) values (#&#123;name&#125;,#&#123;money&#125;)") public void saveAccount(Account account);&#125; 创建service目录，编写service接口和实现类 12345678910111213@Service("accountService")public class AccountServiceImpl implements AccountService &#123; @Autowired private AccountDao accountDao; @Override public List&lt;Account&gt; findAll() &#123; return accountDao.findAll(); &#125; @Override public void saveAccount(Account account) &#123; accountDao.saveAccount(account); &#125;&#125; 创建controller目录，在controller中注入service对象 1234567891011121314151617181920@Controller@RequestMapping("/account")public class AccountController &#123; @Autowired AccountService accountService; @RequestMapping("/findAll") public ModelAndView findAll(ModelAndView mv) &#123; List&lt;Account&gt; accounts = accountService.findAll(); mv.addObject("accounts",accounts); mv.setViewName("list"); return mv; &#125; @RequestMapping("/save") public void save(Account account, HttpServletRequest request, HttpServletResponse response) throws IOException &#123; accountService.saveAccount(account); response.sendRedirect(request.getContextPath() + "/account/findAll"); return; &#125;&#125; 3. applicationContext.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:context="http://www.springframework.org/schema/context" xmlns:aop="http://www.springframework.org/schema/aop" xmlns:tx="http://www.springframework.org/schema/tx" xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd"&gt; &lt;!--开启注解的扫描，只扫描service--&gt; &lt;context:component-scan base-package="cn.itcast.service.impl"/&gt; &lt;!--在spring中整合mybatis框架--&gt; &lt;!--配置连接池--&gt; &lt;bean id="dataSource" class="com.mchange.v2.c3p0.ComboPooledDataSource"&gt; &lt;property name="driverClass" value="com.mysql.jdbc.Driver"/&gt; &lt;property name="jdbcUrl" value="jdbc:mysql:///ssm"/&gt; &lt;property name="user" value="root"/&gt; &lt;property name="password" value="root"/&gt; &lt;/bean&gt; &lt;!--创建SqlSessionFactory工厂--&gt; &lt;bean id="sqlSessionFactory" class="org.mybatis.spring.SqlSessionFactoryBean"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--配置AccountDao接口所在包--&gt; &lt;bean id="mapperScanner" class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt; &lt;property name="basePackage" value="cn.itcast.dao"/&gt; &lt;/bean&gt; &lt;!--配置spring框架声明式事务管理--&gt; &lt;!--配置事务管理器--&gt; &lt;bean id="transactionManager" class="org.springframework.jdbc.datasource.DataSourceTransactionManager"&gt; &lt;property name="dataSource" ref="dataSource"/&gt; &lt;/bean&gt; &lt;!--配置事务通知--&gt; &lt;tx:advice id="txAdvice" transaction-manager="transactionManager"&gt; &lt;tx:attributes&gt; &lt;tx:method name="find*" read-only="true" propagation="SUPPORTS"/&gt; &lt;tx:method name="*" /&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; &lt;!--配置AOP增强--&gt; &lt;aop:config&gt; &lt;aop:advisor advice-ref="txAdvice" pointcut="execution(* cn.itcast.service.impl.*.*(..))"/&gt; &lt;/aop:config&gt;&lt;/beans&gt; 4. web.xml配置1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;!DOCTYPE web-app PUBLIC "-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN" "http://java.sun.com/dtd/web-app_2_3.dtd" &gt;&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;!--配置前端控制器--&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载springmvc.xml配置文件--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--启动服务器，创建该servlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--解决中文乱码的过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--配置spring的监听器--&gt; &lt;listener&gt; &lt;listener-class&gt; org.springframework.web.context.ContextLoaderListener &lt;/listener-class&gt; &lt;/listener&gt; &lt;!--设置spring配置文件的路径--&gt; &lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:applicationContext.xml&lt;/param-value&gt; &lt;/context-param&gt;&lt;/web-app&gt; 5. springmvc.xml12345678910111213141516171819202122232425262728293031&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;beans xmlns="http://www.springframework.org/schema/beans" xmlns:mvc="http://www.springframework.org/schema/mvc" xmlns:context="http://www.springframework.org/schema/context" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation=" http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/mvc http://www.springframework.org/schema/mvc/spring-mvc.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd"&gt; &lt;!--开启注解扫描，只扫描Controller注解--&gt; &lt;context:component-scan base-package="cn.itcast"&gt; &lt;context:include-filter type="annotation" expression="org.springframework.stereotype.Controller" /&gt; &lt;/context:component-scan&gt; &lt;!--配置的视图解析器对象--&gt; &lt;bean id="ViewResolver" class="org.springframework.web.servlet.view.InternalResourceViewResolver"&gt; &lt;property name="prefix" value="/WEB-INF/pages/"/&gt; &lt;property name="suffix" value=".jsp"/&gt; &lt;/bean&gt; &lt;!-- 设置静态资源不过滤 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!--开启SpringMVC注解的支持--&gt; &lt;mvc:annotation-driven/&gt;&lt;/beans&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[web前端]]></title>
    <url>%2F2019%2F06%2F16%2FWeb%E5%89%8D%E7%AB%AF%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Web前端知识点总结1. B/S架构资源 静态资源：使用静态网页开发技术发布的资源 所有用户访问，得到的结果是一样的。 如：文本，图片，音频、视频, HTML,CSS,JavaScript。 如果用户请求的是静态资源，那么服务器会直接将静态资源发送给浏器。 用HTML搭建基础网页， 用CSS美化、布局页面，用JavaScript控制页面的元素，让页面有动态效果。 动态资源：使用动态网页及时发布的资源 所有用户访问，得到的结果可能不一样。 如：jsp/servlet,php,asp…。 如果用户请求的是动态资源，那么服务器会执行动态资源，转换为静态资源，再发送给浏览器。 2. HTML1Hyper Text Markup Language 超文本标记语言，是最基础的网页开发语言 超文本：用超链接的方法，将各种不同空间的文字信息组织在一起的网状文本 标记语言：由标签&lt;标签名称&gt; 构成的语言，如html、xml，不属于编程语言。 标签：标签可以嵌套，不区分大小写，建议用小写，分为两类： 围堵标签：有开始标签和结束标签。如 自闭标签：开始标签和结束标签在一起。如 &lt; br/&gt; 标签 说明 属性 &lt; html&gt; 文档的根标签 &lt; head&gt; 头标签，用于指定html文档的一些属性，引入外部的资源 &lt; title&gt; 标题标签 &lt; body&gt; 体标签 &lt; !DOCTYPE html &gt; html5中定义该文档是html文档 &lt; !– 注释内容 – &gt; 注释 &lt; h1&gt; to &lt; h6&gt; 标题标签，h1到h6字体大小逐渐递减 &lt; p&gt; 段落标签 &lt; br/&gt; 换行标签 &lt; hr&gt; 展示一条水平线 color/width/size/align &lt; b&gt; 字体加粗 &lt; i&gt; 字体斜体 &lt; font&gt; 字体标签 color/face/size &lt; center&gt; 文本居中 &lt; img src=” “ alt=” “&gt; 展示图片（src为图片URL，alt为图片替代文本） align/height/width &lt; ol&gt; &lt; li&gt;&lt; /li&gt; &lt; /ol&gt; 有序列表 type &lt; ul&gt; &lt; li&gt;&lt; /li&gt; &lt; /ul&gt; 无序列表 type &lt; a href=””&gt;&lt; /a&gt; 超链接标签 target( _self/ _blank) &lt; div&gt; 块级标签 &lt; span&gt; 行内标签 &lt; header&gt; 页眉 &lt; footer&gt; 页脚 超链接的功能：1. 生成可以被点击的样式； 2. 点击后跳转到href指定的url 若需要保留1功能，去掉2功能，则：href = &quot;javascript:void(0)&quot; 3. 表格标签 table：定义表格 width：宽度 border：边框 cellpadding：定义内容和单元格的距离 cellspacing：定义单元格之间的距离。如果指定为0，则单元格的线会合为一条 bgcolor：背景色 align：对齐方式 tr：定义行 bgcolor：背景色 align：对齐方式 td：定义单元格 colspan：合并列 rowspan：合并行 th：定义表头单元格 4. 表单标签1用于采集用户输入的数据，和服务器进行交互的标签。 action：指定提交数据的URL，若是写一个#，那么就是提交到本页面 method：指定提交方式，表单项中的数据要想被提交，必须指定其name属性 get：请求参数会在地址栏中显示，参数大小不能超过255， 不太安全 post：请求参数不会在地址栏中显示，参数的大小没有限制，多用于提交视频和图片，比较安全 input：可以通过type属性值，改变元素展示的样式 text：文本输入框，默认值（参数placeholder：指定输入框的提示信息） password：密码输入框 radio：单选框，多个单选框的name属性值必须一样，在value属性中指定其被选中后提交的值 checkbox：在value属性中指定其被选中后提交的值 file：文件选择框 hidden：隐藏域，用于提交一些信息，不需要用户输入 submit：提交按钮，可以提交表单 image：图片提交按钮，src属性指定图片的路径 label：label的for属性一般会和input的id属性值对应。点击label区域，会让对应的input输入框获取焦点 select：下拉列表，子元素option为指定列表项 textarea：文本域，cols：指定列数， rows：默认多少行 1234567891011121314151617181920212223242526272829&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;FormTest&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action="#" method="get"&gt; 姓名：&lt;input type="text" placeholder="请输入姓名" name = "username"&gt; &lt;br&gt; 密码：&lt;input type="password" placeholder="请输入密码" name="password"&gt; &lt;br&gt; 性别：&lt;input type="radio" name = "gender" value="男"&gt; 男 &lt;input type="radio" name = "gender" value="女"&gt; 女&lt;br&gt; 爱好：&lt;input type="checkbox" name = "hobby" value = 1&gt; 小米 &lt;input type="checkbox" name = "hobby" value = 2&gt; 华为 &lt;input type="checkbox" name = "hobby" value = 3&gt; 锤子&lt;br&gt; &lt;label for="file"&gt;文件&lt;/label&gt;：&lt;input type="file" id="file"&gt;&lt;br&gt; 隐藏：&lt;input type="hidden"&gt;&lt;br&gt; 提交：&lt;input type="submit" value="提交"&gt;&lt;br&gt; 图片提交：&lt;input type="image" src="baidu.png"&gt;&lt;br&gt; 地区：&lt;select name="place" id="place" &gt;&lt;br&gt; &lt;option&gt;请选择地区&lt;/option&gt; &lt;option value ="北京"&gt;北京&lt;/option&gt; &lt;option value="深圳"&gt;深圳&lt;/option&gt; &lt;option value="厦门"&gt;厦门&lt;/option&gt; &lt;/select&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 5. CCS12Cascading Style Sheets 层叠样式表，多个样式可以作用在同一个html的元素上，用于页面美化和布局控制好处：功能强大，将内容展示和样式控制分离，易于分工合作，提高效率，同时可以使页面中的样式得以复用。 CCS与Html的结合： 内联样式：在标签内使用style属性指定css代码： &lt;div style=&quot;color:red;&quot;&gt;hello css&lt;/div&gt; 内部样式： 在head标签内，定义style标签，style标签的标签体内容就是css代码： 123456789&gt; &lt;head&gt;&gt; &lt;style&gt;&gt; div&#123;color:blue;&#125;&gt; &lt;/style&gt;&gt; &lt;/head&gt;&gt; &lt;body&gt;&gt; &lt;div&gt;hello css&lt;/div&gt;&gt; &lt;/body&gt;&gt; 外部样式：先定义css资源文件，再在head标签内，定义link标签，引入外部的资源文件 &lt;link rel=&quot;stylesheet&quot; href=&quot;css/a.css&quot;&gt; （也可以写为：&lt;style&gt; @import &quot;a.css&quot;; &lt;/style&gt;） 6. CCS选择器123456选择器：筛选具有相似特征的元素选择器 &#123; 属性名1:属性值1; 属性名2:属性值2; ... &#125; 基础选择器： id选择器：选择具体的id属性值的元素，建议在一个html页面中id值唯一。语法：#id属性值{} 类选择器：选择具有相同的class属性值的元素。语法：.class属性值{} 元素选择器：选择具有相同标签名称的元素。语法：标签名称{} 扩展选择器： 选择所有元素。语法：*{} 并集选择器：同时筛选多个选择器。语法：选择器1,选择器2{} 子选择器：筛选选择器1元素下的选择器2元素。 语法：选择器1 选择器2{} 直系父选择器：筛选选择器2的父元素选择器1。语法：选择器1 &gt; 选择器2{} 属性选择器：选择元素名称，属性名=属性值的元素。语法：元素名称[属性名=&quot;属性值&quot;]{} 伪类选择器：选择一些元素具有的状态。语法：元素：状态{} 如：超链接标签 &lt; a&gt;： a:link{}：初始化的状态 a:visited{}：被访问过的状态 a:active{}：正在访问状态 a:hover{}：鼠标悬浮状态 7. CCS属性 字体、文本： font-size：字体大小 color：文本颜色 text-align：对齐方式 line-height：行高 背景background：可以设置背景色或填充图片 边框border：设置边框，符合属性 尺寸width：宽度height：高度 盒子模型：控制布局 margin：外边距 padding：内边距，默认情况下内边距会影响整个盒子的大小 box-sizing: border-box; 设置盒子的属性，让width和height就是最终盒子的大小 浮动：float，脱离文档流布局（靠左：left；靠右：right） 8. JavaScript基本语法1234JavaScript是一门客户端脚本语言，运行在客户端的浏览器中，每一个浏览器都有JavaScript的解析引擎。JS可以来增强用户和html页面的交互过程，可以来控制html元素，让页面有一些动态的效果，增强用户的体验。脚本语言：不需要编译，可以直接被浏览器内核解析执行的语言。客户端脚本语言的标准：ECMAScript，统一了所有客户端脚本语言的编码方式。 结合html 内部JS：定义&lt; script&gt;，标签体内容就是js代码 外部JS： 定义&lt; script&gt;，通过src属性引入外部的js文件 注意： &lt; script&gt;可以定义多个，可以定义在html页面的任何地方，但是定义的位置会影响执行顺序。 建议书写位置：1. head标题中 2. body最下方 数据类型 原始数据类型：五种 number：数字。包含整数、小数、NaN(Not a Number,代表不是数字的数字类型) string：字符串。 “abc”、 “a”、 ‘abc’ boolean：true和false null：一个对象为空的占位符(注意：null运算是其typeof类型为object，属设计错误) undefined：未定义。一个没有初始化的变量，会被默认赋值为undefined 引用数据类型：对象 变量1JavaScript是弱类型语言，定义变量的语法：var 变量名 = 初始化值 强类型：在开辟变量存储空间时，定义了空间将来存储数据的数据类型。只能存储固定类型的数据。 弱类型：在开辟变量存储空间时，不定义空间将来的存储数据类型，可以存放任意类型的数据。 运算符 被正负号修饰的运算数（+(-)）会自动转换为number类型，如果字面值不是数字，则转为NaN，true转为1，false转为0。 ==：直接比较字面值，类型不同时，先进行类型转换，再比较 ===：全等于，在比较之前，先判断类型，如果类型不一样，则直接返回false 进行逻辑运算时： number：0或NaN为假，其他为真 string：除了空字符串(“”)，其他都是true null&amp;undefined:都是false 对象：所有对象都为true 9. JavaScript基本对象Function:函数对象 创建： var fun = new Function(形式参数列表,方法体)； function 方法名称(形式参数列表){ 方法体} var 方法名 = function(形式参数列表){方法体} 方法： ​ length:代表形参的个数 特点： JS中不存在方法重载，方法的调用只与方法的名称有关，和参数列表无关 方法是一个对象，如果定义名称相同的方法，后执行的方法会覆盖之前的方法 第二种创建方法执行优先级较高，若定义名称相同，会被第三种创建方法覆盖 在方法声明中有一个隐藏的内置对象（数组）arguments，封装所有的实际参数 Array:数组对象 创建： var arr = new Array(元素列表); var arr = new Array(默认长度); var arr = [元素列表] 方法： join(参数)：将数组中的元素按照指定的分隔符拼接为字符串 push(参数)：向数组的末尾添加一个或更多元素，并返回新的数组长度 特点： JS中的数组长度可变，元素类型也可变。 Date:日期对象 创建：var date = new Date(); 方法：toLocaleString()：返回当前date对象对应的时间本地字符串格式getTime():获取毫秒值。返回当前如期对象描述的时间到1970年1月1日零点的毫秒值差 RegExp:正则表达式对象1正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则 创建： var reg = new RegExp(“正则表达式”); var reg = /正则表达式/; （表达式不需要双引号，不需要加转义字符） 方法： test(参数)：验证指定的字符串是否符合正则定义的规范 match(参数)：可以匹配正则，返回的是匹配正则的内容 表达式 含义 x 字符 x \\ 反斜线字符 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） \w 单词字符：[a-zA-Z_0-9] X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 ^ 开始 $ 结束 Global:全局对象1Global中封装的方法不需要对象就可以直接调用 方法： encodeURI()：url编码 decodeURI()：url解码 encodeURIComponent()：url编码（编码的字符范围更大） decodeURIComponent()：url解码 parseInt()：将字符串转为数字（逐一判断每一个字符是否是数字，直到不是数字为止，将前边数字部分转为number） isNaN()：判断一个值是否是NaN（NaN六亲不认，连自己都不认。NaN参与的==比较全部问false） eval()：将一个字符串转换为JS代码，并把它作为脚本代码来执行 10. BOM1Browser Object Model 浏览器对象模型：将浏览器的各个组成部分封装成为对象 Window:窗口对象 弹出框相关方法： alert()：显示带有一段消息和一个确认按钮的警告框 confirm()：显示带有一段消息以及确认按钮和取消按钮的对话框。 如果用户点击确定按钮，则方法返回true 如果用户点击取消按钮，则方法返回false prompt()：显示可提示用户输入的对话框，返回用户输入的值。 打开关闭窗口相关方法： close()：关闭调用此方法的浏览器窗口 open()：打开一个新的浏览器窗口，返回新的window对象 定时器相关方法： setTimeout(js代码或者方法对象，毫秒值)：在指定的毫秒数后调用函数或计算表达式 返回值：唯一标识，用于取消定时器 clearTimeout()：取消由 setTimeout() 方法设置的 timeout setInterval()：按照指定的周期（以毫秒计）来调用函数或计算表达式 clearInterval()：取消由 setInterval() 设置的 timeout 注意：Window可以获取其他BOM对象【history/location/navigator/screen】，DOM对象【document】。 Window对象不需要创建可以直接使用，window.方法名()，且window本身可省略 Location:地址栏对象 方法：reload()：重新加载当前文档，同刷新 History:历史记录对象 方法： back()：加载 history 列表中的前一个 URL forward()：加载 history 列表中的下一个 URL go(参数)：加载 history 列表中的某个具体页面（参数：前进(正数)或后退(负数)几个历史记录） length：返回当前窗口历史列表中的 URL 数量。 Navigator:浏览器对象Screen:显示器屏幕对象11. DOM12345Document Object Model 文档对象模型：将标记语言文档的各个组成部分封装为对象。可以使用这些对象对标记语言文档进行CRUD的动态操作。W3C标准中，DOM被分为三个不同的部分：1. 核心DOM -针对任何结构化文档的标准模型2. XML DOM -针对XML文档的标准模型3. HTML DOM -针对HTML文档的标准模型 Document:文档对象 获取：在HTML DOM模型中可以通过window对象来获取 获取Element对象方法： getElementById()：根据id属性值获取元素对象。 getElementsByTagName()：根据标签名称获取元素对象们，返回值是一个数组 getElementsByClassName()：根据Class属性值获取元素对象们，返回值是一个数组 getElementsByName()：根据name属性值获取元素对象们，返回值是一个数组 创建其他DOM对象方法： createAttribute(name)：创建Attribute属性对象 createComment()：创建Comment注释对象 createElement()：创建Element元素对象 createTextNode()：创建Text文本对象 Element:元素对象 属性： previousSibling：获取该元素的前一个节点 nextSibling：获取该元素的后一个节点 innerHTML：可以获取标签内所有的内容，包括标签 innerText：可以获取标签内所有的文本内容，不包括标签 方法： removeAttribute()：删除属性 setAttribute()：设置属性 Node:节点对象 特点：所有dom对象都可以被认为是一个节点 属性：parentNode 返回节点的父节点 方法： appendChild()：向节点的子节点列表的结尾添加新的子节点。 removeChild()：删除（并返回）当前节点的指定子节点。 replaceChild()：用新节点替换一个子节点。 Attribute:属性对象Text:文本对象Comment:注释对象12. 事件监听机制1概念：某些组件（按钮，文本输入框...）被执行了某些操作（单击，双击，键盘按下，鼠标移动...）后，触发某些代码的执行。 常见的事件： 点击事件： onclick：单击事件 ondblclick：双击事件 焦点事件：（input框里面有光标的时候，叫获取焦点） onblur：失去焦点 onfocus：元素获得焦点 加载事件： onload：在页面当中所有的内容加载完之后触发，常作为入口函数 window.onload = function(){} 鼠标事件： onmousedown 鼠标按钮被按下 onmouseup 鼠标按键被松开 onmousemove 鼠标被移动 onmouseover 鼠标移到某元素之上 onmouseout 鼠标从某元素移开 键盘事件： onkeydown 某个键盘按键被按下 onkeyup 某个键盘按键被松开 onkeypress 某个键盘按键被按下并松开 选择和改变： onchange 域的内容被改变。失焦后触发 onselect 文本被选中 表单事件： onsubmit 确认按钮被点击 onreset 重置按钮被点击 13. 综合案例动态表格12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;动态表格&lt;/title&gt; &lt;style&gt; table&#123; border: 1px solid; margin: auto; width: 500px; &#125; td,th&#123; text-align: center; border: 1px solid; &#125; div&#123; text-align: center; margin: 50px; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div&gt; &lt;input type="text" id="id" placeholder="请输入编号"&gt; &lt;input type="text" id="name" placeholder="请输入姓名"&gt; &lt;input type="text" id="gender" placeholder="请输入性别"&gt; &lt;input type="button" value="添加" id="btn_add"&gt;&lt;/div&gt;&lt;table&gt; &lt;caption&gt;学生信息表&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;编号&lt;/th&gt; &lt;th&gt;姓名&lt;/th&gt; &lt;th&gt;性别&lt;/th&gt; &lt;th&gt;操作&lt;/th&gt; &lt;/tr&gt;&lt;/table&gt;&lt;script&gt;//给添加按钮绑定单击事件document.getElementById("btn_add").onclick = function () &#123; //获取文本框内容 var id = document.getElementById("id").value; var name = document.getElementById("name").value; var gender = document.getElementById("gender").value; //将输入的内容添加到表格 var table = document.getElementsByTagName("table")[0]; table.innerHTML += '&lt;tr&gt;\n' +'&lt;td&gt;'+ id +'&lt;/td&gt;\n' + '&lt;td&gt;'+ name +'&lt;/td&gt;\n' +'&lt;td&gt;'+ gender +'&lt;/td&gt;\n' + '&lt;td&gt;&lt;a href="javascript:void(0)" onclick="delTr(this)"&gt;删除&lt;/a&gt;&lt;/td&gt;\n' +'&lt;/tr&gt;';&#125;//定义删除方法function delTr(obj) &#123; //节点关系：a -&gt; td -&gt; tr -&gt; table var table = obj.parentNode.parentNode.parentNode; var tr = obj.parentNode.parentNode; table.removeChild(tr);&#125;&lt;/script&gt; 表单校验123456789101112131415161718192021&lt;script&gt;// 校验name的方法function checkName() &#123; var name = document.getElementById("name").value; var flag = /^[a-zA-Z]&#123;1,12&#125;$/.test(name); var name_add = document.getElementById("span_name"); if(flag) &#123; name_add.innerHTML = "&lt;img height = '25' width = '35' " +"src = 'img/gou.png'&gt;" &#125;else&#123; name_add.innerHTML = "姓名格式有误"; &#125; return flag;&#125;&lt;/script&gt;&lt;!--表单校验的第一种方式--&gt;var form = document.getElementById("form");form.onsubmit = checkName;&lt;!--表单校验的第二种方式--&gt;&lt;form action="#" id="form" onsubmit="return checkName()"&gt; ...&lt;/form&gt; 14. Bootstrap1一个前端开发的响应式布局框架，基于HTML、CSS、JavaScript开发，简洁灵活，使得 Web 开发更加快捷。 1234567891011121314151617181920212223&lt;!--快速入门：导入Bootstrap文件和jQuery包，创建html页面，引入必要的资源文件： --&gt;&lt;!DOCTYPE html&gt;&lt;html lang="zh-CN"&gt;&lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;meta http-equiv="X-UA-Compatible" content="IE=edge"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1"&gt; &lt;!-- 上述3个meta标签*必须*放在最前面，任何其他内容都必须跟随其后！ --&gt; &lt;title&gt;Index&lt;/title&gt; &lt;!-- Bootstrap --&gt; &lt;link href="css/bootstrap.min.css" rel="stylesheet"&gt; &lt;!-- jQuery (necessary for Bootstrap's JavaScript plugins) --&gt; &lt;!-- Bootstrap中js插件都是依赖于jquery的，要第一步引入--&gt; &lt;script src="js/jquery-3.2.1.min.js"&gt;&lt;/script&gt; &lt;!-- Include all compiled plugins (below), or include individual files as needed --&gt; &lt;script src="js/bootstrap.min.js"&gt;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;Hello World！&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 响应式布局12响应式布局可以使同一套页面兼容不同分辨率的设备。实现方式依赖于栅格系统：将一行平均分成12个格子，可以指定元素占几个格子。 实现步骤： 定义容器：作用相当于&lt; table&gt;，样式：&lt; div&gt; 容器分类：1. container：两边留白； 2. container-fluid：每一种设备都是100%宽度 定义行：作用相当于&lt; tr&gt;，样式：&lt; row&gt; 定义元素：指定元素使用的设备和格子数目，样式：col-设备代号-格子数目 设备代号： xs：超小屏幕 手机 (&lt;768px) sm：小屏幕 平板 (≥768px) md：中等屏幕 桌面显示器 (≥992px) lg：大屏幕 大桌面显示器 (≥1200px) 注意： 一行中如果格子数目超过12，则超出部分自动换行 栅格类属性可以向上兼容，小尺寸设备代号兼容大尺寸设备显示 如果设备真实宽度小于栅格指定的设备代码的临界值，会一个元素占满一整行 15. JQuery1jQuery是一个快速、简洁的JavaScript框架，封装JavaScript常用的功能代码，提供一种简便的JavaScript设计模式，优化HTML文档操作、事件处理、动画设计和Ajax交互，本质上就是一些js文件。 JQuery对象和JS对象方法不通用，需要转换： jq – &gt; js：jq对象[索引] 或者 jq对象.get(索引) js – &gt; jq：$(js对象) 入口函数：$(function(){}); 与window.onload不同，可以定义多次 样式控制：$(&quot;#div1&quot;).css(&quot;backgroundColor&quot;,&quot;pink&quot;); 选择器操作 基本选择器 标签选择器(元素选择器)：$(&quot;html标签名&quot;)获得所有匹配标签名称的元素 id选择器：$(&quot;#id的属性值&quot;)获得与指定id属性值匹配的元素 类选择器：$(&quot;.class的属性值&quot;) 获得与指定的class属性值匹配的元素 并集选择器：$(&quot;选择器1,选择器2....&quot;)获取多个选择器选中的所有元素 层级选择器 后代选择器：$(&quot;A B&quot;) 选择A元素内部的所有B元素 子选择器：$(&quot;A &gt; B&quot;) 选择A元素内部的所有B子元素 属性选择器 属性名称选择器：$(&quot;A[属性名]&quot;) 包含指定属性的选择器 属性选择器：$(&quot;A[属性名=&#39;值&#39;]&quot;) 包含指定属性等于指定值的选择器 复合属性选择器：$(&quot;A[属性名=&#39;值&#39;][]...&quot;)包含多个属性条件的选择器 过滤选择器 首元素选择器：first 获得选择的元素中的第一个元素 尾元素选择器：last 获得选择的元素中的最后一个元素 非元素选择器：not(selector) 不包括指定内容的元素 偶数选择器：even 偶数，从 0 开始计数 奇数选择器：odd 奇数，从 0 开始计数 等于索引选择器：eq(index) 指定索引元素 大于索引选择器：gt(index) 大于指定索引元素 小于索引选择器：t(index)小于指定索引元素 标题选择器：header 获得标题（h1~h6）元素，固定写法 表单过滤选择器 可用元素选择器：enabled获得可用元素 不可用元素选择器：disabled 获得不可用元素 选中选择器：checked 获得单选/复选框选中的元素 选中选择器：selected 获得下拉框选中的元素 DOM操作 内容操作 html()：获取/设置元素的标签体内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; &lt;font&gt;内容&lt;/font&gt; text()：获取/设置元素的标签体纯文本内容 &lt;a&gt;&lt;font&gt;内容&lt;/font&gt;&lt;/a&gt; --&gt; 内容 val()：获取/设置元素的value属性值 属性操作 attr()：获取/设置元素的属性（偏向操作元素的固有属性） removeAttr()：删除属性 prop()：获取/设置元素的属性（偏向操作元素自定义的属性） removeProp()：删除属性 addClass()：添加class属性值（并且保留原class属性） removeClass()：删除class属性值 toggleClass()：切换class属性（若对象已有要切换的class属性，则删除；不存在则添加） css()：操作对象的css样式 CRUD操作 A.append(B)：对象A将对象B追加到自己元素内部的末尾 A.appendTo(B)：对象A将自己添加到对象B元素内部的末尾 A.prepend(B)：对象A将对象B追加到自己元素内部的开头 A.prependTo(B)：对象A将自己追加到对象B元素内部的开头 A.after(B)：对象A将对象B添加到自己后边，对象A和对象B是兄弟关系 A.before(B)：对象A将对象B添加到自己前边，对象A和对象B是兄弟关系 A.insertAfter(B)：对象A将自己添加到对象B后边，对象A和对象B是兄弟关系 A.before(B)：对象A将自己添加到对象B前边，对象A和对象B是兄弟关系 A.remove()：将对象A删除掉，也可以添加一个参数，删除指定标签内部的某个标签 A.empty()：将对象A的后代元素全部清空，但是保留当前对象以及其属性节点 高级操作 动画操作 默认显示和隐藏方式 show([speed,[easing],[fn]]) hide([speed,[easing],[fn]]) toggle([speed],[easing],[fn]) 滑动显示和隐藏方式 slideDown([speed],[easing],[fn]) slideUp([speed,[easing],[fn]]) slideToggle([speed],[easing],[fn]) 淡入淡出显示和隐藏方式 fadeIn([speed],[easing],[fn]) fadeOut([speed],[easing],[fn]) fadeToggle([speed,[easing],[fn]]) 三个参数含义： speed：表示动画时长的毫秒数，或三个预定义的值(slow,normal, fast) easing：用来指定切换效果，默认是swing(慢&gt;快&gt;慢)，可用参数linear(匀速) fn：在动画完成时执行的函数，每个元素执行一次 遍历操作 jq对象.each(callback)：citys.each(function(index,element) {}); $.each(object, [callback])：JQuery.each(citys,function(index,element) {}); for…of：for(city of citys) {}; （jquery 3.0 版本之后提供的方式） 事件绑定 标准绑定：jq对象.事件方法(回调函数)； 绑定事件：jq对象.on(“事件名称”,回调函数) 解除绑定：jq对象.off(“事件名称”) 事件切换：jq对象.toggle(fn1,fn2…) （通过单击循环切换方法） 12&gt; 1.9版本中.toggle() 方法删除，JQuery Migrate（迁移）插件可以恢复此功能。&gt; 插件操作 $.fn.extend(object)：增强JQuery的对象的功能 123456789&gt; $.fn.extend(&#123;&gt; check:function () &#123;&gt; this.prop("checked", true);&gt; &#125;,&gt; uncheck:function () &#123;&gt; this.prop("checked", false);&gt; &#125;&gt; &#125;)&gt; $.extend(object)：增强JQuery全局的功能 123456789&gt; $.extend(&#123;&gt; max: function (a, b) &#123;&gt; return a &gt; b ? a : b;&gt; &#125;,&gt; min: function (a, b) &#123;&gt; return a &lt; b ? a : b;&gt; &#125;&gt; &#125;)&gt; 16. AJAX1ASynchronous JavaScript And XML，可以使网页实现异步更新的技术，在服务器处理请求的过程中，客户端可以不需要等待服务器端的响应，进行其他的操作。这意味着可以在不重新加载整个网页的情况下，对网页的部分进行更新。 12345678910111213141516171819JQuery实现方式：//1.使用$.ajax()发送异步请求$.ajax(&#123; url:"ajaxServlet", // 请求路径 type:"POST", //请求方式 data:&#123;"username":"jack","age":23&#125;, //请求参数 success:function (data) &#123; //响应成功后的回调函数 alert(data); &#125;, error:function () &#123; //若响应失败的回调函数 alert("出错啦...") &#125;, dataType:"text"//设置接受到的响应数据的格式&#125;);//2. $.get()：发送get请求语法：$.get(url, [data], [callback], [type])参数：url：请求路径；data：请求参数；callback：回调函数；type：响应结果的类型；//3. $.post()：发送post请求 方法同$.get() 17. JSON1JavaScript Object Notation，JavaScript的对象表示法，多用于存储和交换文本信息的语法，进行数据传输 基本规则：var p = {&quot;name&quot;:&quot;张三&quot;,&quot;age&quot;:23,&quot;gender&quot;:&quot;男&quot;}; JSON数据由键值对构成，键可以用单引号、双引号包裹，也可以不使用引号 值的取值类型有六种： 数字（整数或浮点数） 字符串（在双引号中） 逻辑值（true 或 false） 数组（在方括号中） {“persons”:[{},{}]} 对象（在花括号中） {“address”:{“province”：”陕西”….}} null 数据由逗号分隔：多个键值对由逗号分隔 花括号保存对象：使用{}定义json 格式 方括号保存数组：[] 获取数据 json对象.键名 json对象[“键名”] 数组对象[索引] 注解 @JsonIgnore：排除属性，用于JavaBean成员变量上 @JsonFormat：属性值的格式化 @JsonFormat(pattern = &quot;yyyy-MM-dd&quot;) JSON数据和Java对象的相互转换12345678910常见的JSON解析器：Jsonlib，Gson，fastjson，jackson1. 导入jackson的相关jar包2. 创建Jackson核心对象 ObjectMapper3. 调用ObjectMapper的相关方法进行转换//将JSON数转换为java对象据：Object obj = mapper.readValue(json, Object.class);//将java对象转换为JSON数据：String json = mapper.writeValueAsString(obj);//将obj对象转换为JSON字符串mapper.writeValue(new File("C://a.txt"),obj);//将obj对象转换为JSON字符串，并保存到指定的文件中mapper.writeValue(response.getWriter(), obj);//将obj对象转换为JSON字符串，并响应至请求来源处 18. 案例展示：用户名检验123456789101112131415161718192021//Servlet代码@WebServlet("/findUserServlet")public class FindUserServlet extends HttpServlet &#123; public void doPost(...) throws IOException &#123; request.setCharacterEncoding("utf-8"); response.setContentType("application/json;charset=utf-8"); String username = request.getParameter("username"); User user = UserDao.username_check(username); HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;(); if (user != null) &#123; map.put("userExist", true); map.put("msg", "该用户名已存在"); &#125; else &#123; map.put("userExist", false); map.put("msg", "该用户名可用"); &#125; //将map转为JSON，并传给客户端 ObjectMapper mapper = new ObjectMapper(); mapper.writeValue(response.getWriter(), map); &#125; 12345678910111213141516171819202122232425262728293031&lt;!--html代码--&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;注册页面&lt;/title&gt; &lt;script src = "js/jquery-3.3.1.min.js"&gt;&lt;/script&gt; &lt;script&gt; $(function () &#123; $("#username").blur(function () &#123; //为username绑定失焦事件 //将username的内容异步传递给findUserServlet进行判断 var username = $(this).val(); $.get( "findUserServlet", &#123;username:username&#125;, //data接收mapper.writeValue(response.getWriter(), map)响应的JSON function (data) &#123; if(data.userExist) &#123; //用户名存在 $("#user_check").html(data.msg); &#125;else &#123; //用户名不存在 $("#user_check").html(data.msg); &#125;&#125;)&#125;);&#125;) &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;input type="text" name="username" id="username" placeholder="请输入用户名"&gt; &lt;span id="user_check"&gt;&lt;/span&gt; &lt;br&gt; &lt;input type="text" name="password" id="password" placeholder="请输入密码"&gt; &lt;br&gt; &lt;input type="button" value="提交"&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
  </entry>
  <entry>
    <title><![CDATA[web核心]]></title>
    <url>%2F2019%2F06%2F16%2FWeb%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Web核心知识点总结1. XML概述1Extensible Markup Language 可扩展标记语言，自定义标签，使用标记语言的特性描述数据结构，主要作为配置文件用于数据的存储以及传输。 语法特点： 文档后缀名：xml 第一行必须定义为文档声明 文档中有且仅有一个根标签，所有标签必须闭合，区分大小写 属性值必须加引号 文档声明： 格式：&lt;?xml version=&quot;1.0&quot; encoding = &quot;UTF-8&quot; standalone = &quot;yes&quot;?&gt; version 版本号是必须的属性； encoding 告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1 不支持汉 standalone 是否独立，取值yes为不依赖其他文件，取值no为依赖其他文件 指令： 结合CSS指令：&lt; ?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt; CDATA区（数据原样展示，不被解析）：&lt;![CDATA[ 数据 ]]&gt; 2. XML约束12规定xml文档的书写规则，不影响解析，主要有两种技术：DTD:一种简单的约束技术，约束的内容较为简单；Schema:一种复杂的约束技术，约束的内容较为详细 DTD引入： 内部dtd：将约束规则定义在xml文档中 外部dtd：将约束的规则定义在外部的dtd文件中 本地：&lt; !DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt; 网络：&lt; !DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt; Schema引入： 1234567891011121314151617&gt; 1. 填写xml文档的根元素:&gt; &lt;beans&gt; 2. 引入xsd约束的标准，并声明前缀xsi：&gt; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&gt; 3. 给xsi的location参数赋值，说明引入的xsd文件路径，路径前是xsd文件的命名空间：&gt; xsi:schemaLocation=&quot;&gt; http://www.springframework.org/schema/beans（命名空间） &gt; http://www.springframework.org/schema/beans/spring-beans.xsd（文件路径）&gt; http://www.springframework.org/schema/context （命名空间）&gt; http://www.springframework.org/schema/context/spring-context.xsd（文件路径）&gt; http://www.springframework.org/schema/mvc（命名空间）&gt; http://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;（文件路径）&gt; 4. 为每一个xsd约束声明一个前缀，作为标识：&gt; xmlns=&quot;http://www.springframework.org/schema/beans&quot;（无前缀为默认）&gt; xmlns:context=&quot;http://www.springframework.org/schema/context&quot;（前缀context）&gt; xmlns:mvc=&quot;http://www.springframework.org/schema/mvc&quot;（前缀mvc）&gt; &gt; 3. XML解析1操作xml文档，将文档中的数据读取到内存中 解析的方式： DOM：将标记语言文档一次性加载进内存，在内存中形成一颗DOM树 优点：操作方便，可以对文档进行CRUD操作；缺点：占内存 SAX：逐行读取，基于事件驱动 优点：不占内存；缺点：只能读取，不能增删改 常见解析器： JAXP：sun公司提供的解析器，支持dom和sax两种思想 DOM4J：一款非常优秀的解析器。应用广泛，对XPath支持度高 Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据 PULL：Android操作系统内置的解析器，sax方式的 Jsoup解析器 Jsoup方法： parse解析，返回Document： parse(File in, String charsetName)：解析xml或html文件的 parse(String html)：解析xml或html字符串 parse(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象 通过Document的方法获取Elements对象： getElementById(String id)：根据id属性值获取唯一的element对象 getElementsByTag(String tagName)：根据标签名称获取元素对象集合 getElementsByAttribute(String key)：根据属性名称获取元素对象集合 getElementsByAttributeValue(String key, String value)：根据属性名和属性值获取元素对象集合 通过Elements集合获取元素Element（Elements可当做ArrayList使用）： String attr(String key)：根据属性名称获取属性值 String text():获取文本内容 String html():获取标签体的所有内容(包括子标签及其字符串内容) selector选择器： document.select(String cssQuery)，返回Elements cssQuery语法参考Selector类中定义的语法： 123&gt; //示例：获取student标签并且number属性值为heima_0001的age子标签&gt; document.select("student[number=\"heima_0001\"] &gt; age");&gt; 123456789101112//Jsoup使用步骤//0.导入jar包：jsoup-1.11.2.jar//1.获取要解析文件的路径String path = Demo01Jsoup.class.getClassLoader().getResource("url").getPath();//2.通过Jsoup的方法解析，加载文档进内存，获取Document对象Document document = Jsoup.parse(new File(path), "utf-8");//3.获取元素对象集合Elements elements = document.getElementsByTag("name");//4.获取单个元素对象Element element = elements.get(1);System.out.println(element.html()); //获取标签体的所有内容(包括子标签)System.out.println(element.text()); //获取文本内容 Xpath路径语言1XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言，使用Jsoup的Xpath需要额外导入jar包，Jsoup只支持XPath1.0。 1234567891011121314151617181920//XPath使用演示：//1.获取要解析文件的路径String path = Demo01Jsoup.class.getClassLoader().getResource("url").getPath();//2.通过Jsoup的方法解析，加载文档进内存，获取Document对象Document document = Jsoup.parse(new File(path), "utf-8");//3.根据document对象，创建JXDocument对象JXDocument jxDocument = new JXDocument(document);//4.结合xpath语法查询符合条件的结果并输出List&lt;JXNode&gt; jxNodes = jxDocument.selN("条件");for (JXNode jxNode : jxNodes) &#123; System.out.println(jxNode);&#125;//条件示范：//查询所有student标签：jxDocument.selN("//student"); //查询所有student标签下的name标签：jxDocument.selN("//student/name"); //查询student标签下带有id属性的name标签：jxDocument.selN("//student/name[@id]"); //查询student标签下带有id属性的name标签，并且id属性值为itcast：jxDocument.selN("//student/name[@id='itcast']"); 4. web服务器软件123456web服务器软件搭载在服务器上，可以部署web项目，让用户通过浏览器来访问这些项目常见的java相关的web服务器软件： webLogic：oracle公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 webSphere：IBM公司，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 JBOSS：JBOSS公司的，大型的JavaEE服务器，支持所有的JavaEE规范，收费。 Tomcat：Apache基金组织，中小型的JavaEE服务器，支持少量的JavaEE规范servlet/jsp，开源，免费。 Tomcat介绍 启动：打开bin/startup.bat 关闭：打开bin/shutdown.bat或在命令行ctrl+c 部署项目的三种方式： 将项目打包成war(zip)包，放到webapps目录下即可 war包会自动解压缩，若需部署多个项目，可以放到虚拟目录中区分不同的项目。 配置conf/server.xml文件 docBase:项目存放的路径 path：虚拟目录 在conf\Catalina\localhost创建xml文件 xml文件名为虚拟目录名 xml文件中编写 5. Servlet接口12Servlet就是一个接口，定义了Java类被浏览器访问到(tomcat识别)的规则。Java类只要实现了这个接口，那么这个类就可以被浏览器访问到（让该类代码执行）。 访问原理 1. 当服务器接受到客户端浏览器的请求后，会解析请求URL路径，获取访问的Servlet的资源路径 查找web.xml文件，是否有对应的标签体内容。 如果有，则在找到对应的全类名 tomcat会将字节码文件加载进内存，并且通过反射机制创建其对象 调用其方法 使用步骤 创建JavaEE项目 定义一个类，实现Servlet接口public class ServletDemo1 implements Servlet 实现接口中的抽象方法 配置Servlet 12345678910111213141516171819202122&gt; //方法一： &gt; 在web.xml中配置：&gt; &lt;!--配置Servlet --&gt;&gt; &lt;servlet&gt;&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;&gt; &lt;servlet-class&gt;cn.itcast.web.servlet.ServletDemo1&lt;/servlet-class&gt;&gt; &lt;/servlet&gt;&gt; &gt; &lt;servlet-mapping&gt;&gt; &lt;servlet-name&gt;demo1&lt;/servlet-name&gt;&gt; &lt;url-pattern&gt;/demo1&lt;/url-pattern&gt;&gt; &lt;/servlet-mapping&gt;&gt; /*在&lt;servlet&gt;标签下配置 &lt;load-on-startup&gt;，赋值：&gt; 值为负数：第一次被访问时创建&gt; 值为非负数：在服务器启动时创建*/ &gt; //方法二：&gt; 在类上使用@WebServlet("/资源路径")注解，进行配置 (Servlet3.0版本以上)&gt; //一个Servlet可以定义多个访问路径 ： @WebServlet(&#123;"/d4","/dd4","/ddd4"&#125;)&gt; //路径定义规则：&gt; 1. /xxx/xxx:多层路径，目录结构&gt; 2. *.do：扩展名匹配(任何以.do结尾都可以匹配到) &gt; 内部方法 123456789101112131415161718192021&gt; @Override&gt; public void init(ServletConfig servletConfig) throws ServletException &#123;&gt; //Servlet的init方法，只执行一次，说明一个Servlet在内存中只存在一个对象，Servlet是单例的&gt; &#125;&gt; @Override&gt; public void service(ServletRequest servletRequest, ServletResponse servletResponse) throws ServletException, IOException &#123;&gt; //每次访问Servlet时，Service方法都会被调用一次。&gt; &#125;&gt; @Override&gt; public void destroy() &#123;&gt; //destroy方法在Servlet服务器正常关闭之前才会执行，一般用于释放资源。&gt; &#125;&gt; @Override&gt; public String getServletInfo() &#123; //不常用&gt; return null;&gt; &#125;&gt; @Override&gt; public ServletConfig getServletConfig() &#123; //不常用&gt; return null; &gt; &#125;&gt; 体系结构1234op1=&gt;operation: Servlet -- 接口op2=&gt;operation: GenericServlet -- 抽象类op3=&gt;operation: HttpServlet -- 抽象类op1-&gt;op2-&gt;op3 GenericServlet：将Servlet接口中其他的方法做了默认空实现，只将service()方法作为抽象。继承后实现service()方法即可。 HttpServlet：对http协议的一种封装，简化操作。复写doGet/doPost方法。 6. HTTP协议12Hyper Text Transfer Protocol 超文本传输协议：定义了客户端和服务器端通信时，发送数据的格式客户端和服务器必须同时遵守HTTP协议，才能通信 特点： 基于TCP/IP的高级协议 默认端口号：80 基于请求/响应模型的：一次请求对应一次响应 无状态的：每次请求之间相互独立，不能交互数据 版本： 1.0：每一次请求响应都会建立新的连接Connection，较耗费资源 1.1：复用连接，Connection复用，省略了重复创建连接所耗费的资源 2.0：1.X版本都是使用文本传输数据，2.0开始使用字节传输，多路复用，速率提升 7. 请求消息数据格式1234567891011POST /login.html HTTP/1.1 &lt;!--1.请求行：请求方式+请求url+请求协议/版本--&gt;Host: localhost &lt;!--2.请求头：IP地址+User-Agent浏览器信息+Referer来源+...--&gt;User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:60.0) Gecko/20100101 Firefox/60.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,;q=0.8Accept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Accept-Encoding: gzip, deflateReferer: http://localhost/login.html&lt;!--告诉服务器请求的来源--&gt;Connection: keep-aliveUpgrade-Insecure-Requests: 1 &lt;!--2.请求头--&gt;&lt;!--3.请求空行：分割请求头和请求体--&gt;username=zhangsan &lt;!--4.请求体(正文)：封装POST请求消息的请求参数--&gt; 常见的请求头： User-Agent：浏览器告诉服务器，我访问你使用的浏览器版本信息。服务器端可以获取该信息，针对不同浏览器设置参数，解决浏览器的兼容性问题。 Referer：http://localhost/login.html：告诉服务器当前请求的来源。作用：防盗链，统计工作。 8. Request对象1request对象用来获取请求消息，response对象用来设置响应消息，request和response对象都是由服务器创建的。 request对象继承体系结构： ​ ServletRequest 接口​ | 继承​ HttpServletRequest 接口​ | 实现org.apache.catalina.connector.RequestFacade 类(tomcat)在用户发出请求的时候 会自动的创建RequestFacade对象 获取请求消息数据的方法12345678910111213141516//获取请求方式 String method = request.getMethod(); // GET//获取虚拟目录 String contextPath = request.getContextPath(); // day03//获取Servlet路径 String servletPath = request.getServletPath(); // /Demo01Servlet//获取get方式请求参数 String queryString = request.getQueryString(); // username=zhangsan//获取请求URI、URLString requestURI = request.getRequestURI(); // /day03/Demo01ServletStringBuffer requestURL = request.getRequestURL();//http://localhost:8080/day03/Demo01Servlet//获取协议及版本 String protocol = request.getProtocol(); // HTTP/1.1//获取客户机的IP地址 String remoteAddr = request.getRemoteAddr(); // 0:0:0:0:0:0:0:1 URL：统一资源定位符：http://localhost/day14/demo1 （中华人民共和国） URI：统一资源标识符：/day14/demo1 （共和国） 获取请求头数据的方法123456789101112131415161718String getHeader(String name):通过请求头的名称获取请求头的值Enumeration&lt;String&gt; getHeaderNames():获取所有的请求头名称，封装为键值对 //使用示范： Enumeration&lt;String&gt; headerNames = request.getHeaderNames(); while (headerNames.hasMoreElements()) &#123; String name = headerNames.nextElement(); String value = request.getHeader(name); System.out.println(name + "------" + value);&#125; /*输出结果： host------localhost:8080 connection------keep-alive cache-control------max-age=0 upgrade-insecure-requests------1 user-agent------Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/74.0.3729.108 Safari/537.36 accept-----text/html,application/xhtml+xml,application/xml; accept-encoding------gzip, deflate, br accept-language------zh-CN,zh;q=0.9 cookie------_xsrf=2|50c9000a|7b65bf12b3842e1198f0522667c61f08|1554439214; */ 获取请求体数据的方法12345//请求体：只有POST请求方式，才有请求体，在请求体中封装了POST请求的请求参数//步骤：1. 获取流对象 BufferedReader getReader()：获取字符输入流，只能操作字符数据 ServletInputStream getInputStream()：获取字节输入流，可以操作所有类型数据 //2. 再从流对象中拿数据 获取请求参数通用方式12341. String getParameter(String name):根据参数名称获取参数值 2. String[] getParameterValues(String name):根据参数名称获取参数值的数组 3. Enumeration&lt;String&gt; getParameterNames():获取所有请求的参数名称4. Map&lt;String,String[]&gt; getParameterMap():获取所有参数的map集合 中文乱码问题：post方式会乱码，我们在获取前端传递的参数之前，都进行设置编码 request.setCharacterEncoding(&quot;utf-8&quot;); 请求转发的方法1request.getRequestDispatcher("String path").forward(request,response); 浏览器地址栏路径不发生变化 只能转发到当前服务器内部资源中 转发是一次请求，多个资源用的是同一个请求 共享数据的方法1231. void setAttribute(String name,Object obj):存储数据2. Object getAttitude(String name):通过键获取值3. void removeAttribute(String name):通过键移除键值对 域对象：一个有作用范围的对象，可以在范围内共享数据 request域：代表一次请求的范围，一般用于请求转发的多个资源中共享数据 9. BeanUtils工具类12用于封装标准JavaBean的工具类，按照属性进行映射。属性：setter和getter方法截取后的产物，例如：getUsername() --&gt; Username--&gt; username 方法： setProperty() getProperty() populate(Object obj , Map map)：将map集合的键值对信息，封装到对应的JavaBean对象中 10. 响应消息数据格式12345678910111213HTTP/1.1 200 OK &lt;!--1.响应行：协议/版本+响应状态码+状态码描述--&gt;Content-Type: text/html;charset=UTF-8&lt;!--2.响应头--&gt;Content-Length: 101Date: Wed, 06 Jun 2018 07:08:42 GMT &lt;!--3.响应空行--&gt;&lt;html&gt; &lt;!--4.响应体:传输的数据--&gt; &lt;head&gt; &lt;title&gt;$Title$&lt;/title&gt; &lt;/head&gt; &lt;body&gt; hello , response &lt;/body&gt;&lt;/html&gt; &lt;!--4.响应体:传输的数据--&gt; 响应状态码：服务器告诉客户端浏览器本次请求和响应的一个状态，状态码都是3位数字。 1xx：服务器接收客户端消息，但没有接受完成，等待一段时间后，发送1xx多状态码 2xx：成功。代表：200 3xx：重定向。代表：302(重定向)，304(访问缓存) 4xx：客户端错误。代表：404(请求路径没有对应的资源)，405：(请求方式没有对应的doXxx方法) 5xx：服务器端错误。代表：500(服务器内部出现异常，写的代码有bug) 常见的响应头： Content-Type：服务器告诉客户端本次响应体数据格式以及编码格式 Content-disposition：服务器告诉客户端以什么格式打开响应体数据 in-line：默认值，在当前页面内打开 attachment；filename=xxx：以附件形式打开响应体：文件下载 11. Response对象1request对象和response对象由tomcat创建，每次请求相互独立 Response方法： 设置状态码：setStatus(int sc) 设置响应头：setHeader(String name, String value) 设置响应体： 字符输出流：PrintWriter getWriter() 字节输出流：ServletOutputStream getOutputStream() 设置输出流的编码：response.setContentType(&quot;text/html;charset=utf-8&quot;); setContentType方法同时起到两个作用：1. 设置该流的默认编码 2. 告诉浏览器响应体使用的编码 12. 重定向123456重定向：资源跳转的方式//基本的重定向方法：1. 设置状态码为302；2.设置响应头locationresponse.setStatus(302);response.setHeader("location","/responseDemo2");//简化的重定向方法：response.sendRedirect("/responseDemo2"); 转发(forward)和重定向(redirect)的特点： 转发的特点： 转发地址栏路径不变 转发只能访问当前服务器下的资源 转发是一次请求，可以使用request对象来共享数据 跳转路径不需要加虚拟目录 重定向的特点 重定向地址栏路径变化 重定向可以访问其他站点(服务器)的资源 重定向是两次独立的请求，不能使用request对象来共享数据 跳转路径需要加虚拟目录 13. ServletContext对象1代表整个web应用，可以和程序的容器(服务器)来通信 ServletContext方法： 获取ServletContext： 通过request对象获取：equest.getServletContext(); 通过HttpServlet获取：this.getServletContext(); 获取MIME类型： MIME类型:在互联网通信过程中定义的一种文件数据类型（大类型/小类型：image/jpeg） String getMimeType(String file) 域对象：共享数据（对象范围：所有用户所有请求的数据） setAttribute(String name,Object value) getAttribute(String name) removeAttribute(String name) （由于ServletContext域对象范围太大，一般不用） 获取文件的真实(服务器)路径：String getRealPath(String path) 获取web目录下资源：getRealPath(&quot;/a.txt&quot;); 获取WEB-INF目录下资源：getRealPath(&quot;/WEB-INF/a.txt&quot;); 获取src目录下资源：getRealPath(&quot;/WEB-INF/classes/a.txt&quot;); 14. 案例：文件下载123456789101112131415161718192021222324//获取请求参数中的文件名称，找到该文件的真实路径，关联给字节输入流String filename = request.getParameter("filename"); ServletContext servletContext = this.getServletContext(); String realPath = servletContext.getRealPath("/img/" + filename); FileInputStream fis = new FileInputStream(realPath); //设置response响应头的"content-type"参数为图片的Mime格式 String mimeType = servletContext.getMimeType(filename); response.setHeader("content-type", mimeType);//通过工具将filename改造成对应浏览器能够解读的格式 String userAgent = request.getHeader("user-agent"); filename = DownLoadUtils.getFileName(userAgent, filename);//设置response响应头的"content-disposition"参数为附件形式 response.setHeader("content-disposition","attachment;filename=" + filename); //将输入流的数据写出到输出流中 ServletOutputStream sos = response.getOutputStream(); byte[] buff = new byte[1024 * 8]; int len = 0; while ((len = fis.read(buff)) != -1) &#123; sos.write(buff, 0, len); &#125; fis.close(); 15. Cookie1概念：客户端会话技术，将数据保存到客户端。基于响应头set-cookie和请求头cookie实现 方法： 创建Cookie对象，绑定数据：new Cookie(String name, String value) 发送Cookie对象：response.addCookie(Cookie cookie) 获取Cookie对象，拿到数据：request.getCookies()，返回Cookie[] 数组 持久化存储Cookie对象：setMaxAge(int seconds)(Cookie数据默认在览器关闭后被销毁) 正数：将Cookie数据写到硬盘的文件中，持久化存储，并指定cookie存活时间。 负数：默认值 零：删除cookie信息 共享： 同一服务器的Cookie共享：一个服务器中多个web项目默认无法共享Cookie对象，可以设置Cookie的获取范围：setPath(String path)。方法默认为当前虚拟目录，设置为”/“让一个服务器下所有项目共享 不同服务器的Cookie共享：setDomain(String path):如果设置一级域名相同，那么多个服务器之间cookie可以共享。(如setDomain(“.baidu.com”),那么tieba.baidu和news.baidu中cookie可以共享) 特点： 在tomcat 8 之前，cookie中不能直接存储中文数据。在tomcat 8 之后，cookie支持中文数据。特殊字符还是不支持，建议使用URL编码存储，URL解码解析。 URL编码：URLEncoder.encode(string, &quot;utf-8&quot;); URL解码：URLDecoder.decode(string, &quot;utf-8&quot;); cookie数据存储在客户端浏览器，一般情况下浏览器对单个cookie 的大小限制4kb，对同一个域名下的总cookie数量限制20个。 cookie一般用于存储少量的不太敏感的数据，用于不登录的情况下，完成服务器对客户端的身份识别。 16. Session1服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中,依赖于Cookie实现。 方法： 获取HttpSession对象：request.getSession(); 使用HttpSession对象： Object getAttribute(String name) void setAttribute(String name, Object value) void removeAttribute(String name) 存活： 客户端关闭后，服务器不关闭： 默认情况下两次获取session不是同一个。如果需要相同，则可以创建Cookie，键的名称一定为JSESSIONID，设置最大存活时间，让cookie持久化保存。 1234&gt; Cookie c = new Cookie("JSESSIONID",session.getId());&gt; c.setMaxAge(60*60);&gt; response.addCookie(c);&gt; 客户端不关闭，服务器关闭后： 两次获取的session不是同一个，但是要确保数据不丢失，tomcat自动完成以下工作： session的钝化：关闭服务器的时候，生成保存sessuib数据的文件.ser session的活化：再度开启服务器的时候，读取保存的.ser文件，并销毁文件 销毁： 服务器关闭时销毁 session对象调用invalidate() 方法时销毁 session默认失效时间 30分钟 session与Cookie的区别： 1. session存储数据在服务器端，Cookie在客户端 2. session没有数据大小限制，Cookie有 3. session数据安全，Cookie相对于不安全 17. JSP12Java Server Pages：java服务器端页面，既可以定义html标签，又可以使用java代码。JSP本质上是一个Servlet，IDEA编译：jsp页面-&gt;Servlet.java文件-&gt;.class文件 脚本： &lt;% 代码 %&gt;：定义的java代码，在service方法中。每一次访问该jsp都会执行此脚本中的代码 &lt;%! 代码 %&gt;：定义的java代码，在jsp转换后的java类的成员变量位置。 &lt;%= 代码 %&gt;：定义的java代码，会输出到页面上。（out.print方法的简写） 指令：用于配置JSP页面，导入资源文件，格式：&lt;%@ 指令名称 属性名1=属性值1 属性名2=属性值2 ... %&gt; page： contentType：设置响应体的mime类型以及字符集，在高级IDE中可设置当前jsp页面的编码 import：导包 errorPage：当前页面发生异常后，会自动跳转到指定的错误页面 isErrorPage：标识当前页面是否是错误页面。(值为true，页面可使用内置对象exception) 1234567&gt; &lt;%--代码演示--%&gt; &gt; &lt;%@ page contentType="text/html;charset=gbk" errorPage="500.jsp" pageEncoding="GBK" language="java" buffer="16kb" %&gt;&gt; &gt; &lt;%@ page contentType="text/html;charset=UTF-8" isErrorPage="true" language="java" %&gt;&gt; &gt; &lt;%@ page import="java.util.ArrayList" %&gt;&gt; include：导入其他页面的资源文件 &lt;%@include file=&quot;top.jsp&quot;%&gt; taglib：导入资源 &lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 注释： html注释：会显示到网页源码中，只能注释html代码片段 &lt;%– –%&gt; jsp注释：不会显示到网页源码中，可以注释所有代码，推荐使用 内置对象： 变量名 真实类型 作用 pageContext PageContext 共享当前页面数据，还可以获取其他八个内置对象 request HttpServletRequest 共享一次请求访问的多个资源数据(转发) session HttpSession 共享一次会话的多个请求间数据 application ServletContext 整个web项目，所有用户间共享数据 response HttpServletResponse 响应对象 page Object 当前页面(Servlet)的对象 this out JspWriter 输出对象，数据输出到页面上 config ServletConfig Servlet的配置对象 exception Throwable 异常对象 12&gt; tomcat服务器，会先找response缓冲区数据，再找out缓冲区数据,所以response.getWriter()数据输出永远在out.write()之前，推荐使用：out.write()。&gt; 18. MVC开发模式 M：Model，模型。JavaBean 定义的标准的java描述类，用于完成具体的业务操作。 V：View，视图。JSP页面，用于展示数据。 C：Controller，控制器。Servlet：获取用户输入的数据；调用模型处理数据；将数据交给视图展示 优点：耦合性低，方便维护，可以利于分工协作，重用性高 缺点：使得项目架构变得复杂，对开发人员要求高 19. EL表达式12Expression Language 表达式语言，用于替换和简化jsp页面中java代码的编写jsp默认支持EL表达式的，语法：$&#123;表达式&#125; 方法： ${empty list}：判断字符串、集合、数组对象是否为null或者长度为0 ${not empty str}：表示判断字符串、集合、数组对象是否不为null，并且长度&gt;0 ${域名称.键名}：从指定域中获取指定键的值，域名称有： pageScope –&gt; pageContext //当前页面 requestScope –&gt; request //当前次请求 sessionScope –&gt; session //当前次会话 applicationScope –&gt; application（ServletContext） //整个web项目 ${域名称.键名.属性名}：获取对象的属性值，不等于成员变量，本质上是调用对象的getter方法 ${域名称.键名[索引]}：获取List集合的元素 ${域名称.键名.key名称} ${域名称.键名[&quot;key名称&quot;]}：获取Map集合的值 \${表达式}或设置JSP的page指令中isELIgnored=&quot;true&quot;：忽略当前JSP页面中所有的EL表达式 隐式对象： ​ EL表达式中有11个隐式对象，我们需要使用pageContext获取其他对象 动态获取虚拟目录：${pageContext.request.contextPath} 20. JSTL12JavaServer Pages Tag Library：JSP标准标签库，由Apache组织提供的开源的免费的jsp标签用于简化和替换jsp页面上的java代码 使用步骤： 导入jstl相关jar包 引入标签库taglib指令：&lt;%@ taglib prefix=&quot;c&quot; uri=&quot;http://java.sun.com/jsp/jstl/core&quot; %&gt; 使用标签 常用标签： if：test为必须属性，接受boolean表达式，表达式为true时展示标签内容，false则不展示 1234&gt; &lt;c:if test="true"&gt;&gt; &lt;h2&gt;I am true!&lt;/h2&gt;&gt; &lt;/c:if&gt;&gt; choose：相当于java代码的switch语句 foreach：相当于java代码的for语句 123456&gt; &lt;c:forEach items="$&#123;list&#125;" var="str" varStatus="s"&gt;&gt; $&#123;s.index&#125; &lt;%--索引--%&gt;&gt; $&#123;s.count&#125; &lt;%--循环次数--%&gt;&gt; $&#123;str&#125; &lt;%--元素--%&gt;&gt; &lt;/c:forEach&gt;&gt; 21. 三层架构1231. 界面层(web层)：用户看的得界面，用户可以通过界面上的组件和服务器进行交互。2. 业务逻辑层（service层）：处理业务逻辑的。3. 数据访问层(dao层)：操作数据存储文件。 22. Filter 过滤器1当客户端访问服务器的资源时，过滤器可以将请求拦截下来，完成一些特殊的功能 实现步骤： 定义一个类，实现接口Filter（import javax.servlet.annotation.WebFilter;） 复写方法 配置拦截路径 配置拦截路径： 方式一：web.xml 123456789&gt; &lt;!-- &lt;filter&gt;&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt;&gt; &lt;filter-class&gt;cn.itcast.web.filter.FilterDemo1&lt;/filter-class&gt;&gt; &lt;/filter&gt;&gt; &lt;filter-mapping&gt;&gt; &lt;filter-name&gt;demo1&lt;/filter-name&gt;&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&gt; &lt;/filter-mapping&gt;--&gt;&gt; 方式二：注解：@WebFilter(&quot;/*&quot;) 路径详解： 拦截具体文件：/index.jsp 拦截目录：/user/* 拦截后缀名：*.jsp 拦截所有资源：/* 配置拦截方法： 注解配置：设置dispatcherTypes属性 REQUEST：默认值。浏览器直接请求资源 FORWARD：转发访问资源 INCLUDE：包含访问资源 ERROR：错误跳转资源 ASYNC：异步访问资源 web.xml配置：设置&lt;dispatcher&gt; &lt;/dispatcher&gt;标签即可 只有同时满足拦截路径&amp;拦截方式的资源，才会被过滤器拦截 方法： init()：在服务器启动后，会创建Filter对象，然后调用init方法，只执行一次，用于加载资源。 doFilter()：每一次请求被拦截资源时会执行，执行多次。 destroy()：服务器正常关闭后，Filter对象被销毁，执行destroy方法，只执行一次，用于释放资源。 filterChain.doFilter(servletRequest,servletResponse)：过滤放行 执行顺序： 注解配置执行顺序：过滤器1–&gt;过滤器2–&gt;资源执行–&gt;过滤器2–&gt; 过滤器1 按照类名的字符串比较规则比较，值小的先执行 web.xml配置执行顺序：&lt;filter-mapping&gt;谁定义在上边，谁先执行 12345678910111213141516171819202122//过滤未登录用户代码展示public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123; //0.强制转换 HttpServletRequest request = (HttpServletRequest) req; //1.获取资源请求路径 String uri = request.getRequestURI(); //2.排除和登录以及页面布局式样相关的路径 if (uri.contains("/loginServlet") || uri.contains("/login.jsp") || uri.contains("/checkCodeServlet") ||uri.contains("/css/") || uri.contains("/fonts/") || uri.contains("/js/")) &#123; chain.doFilter(req, resp); &#125; else &#123; //3.从request中获取用户登录后封装的user对象 Object user = request.getSession().getAttribute("user"); if (user != null) &#123; chain.doFilter(req, resp); &#125; else &#123; request.setAttribute("login_msg","您尚未登录，请您先登录"); request.getRequestDispatcher("/login.jsp").forward(req, resp); &#125; &#125;&#125; 23. 代理模式123代理对象通过代理真实对象，达到增强真实对象功能的目的，代理对象有两种实现方式：1. 静态代理：有一个类文件描述代理模式2. 动态代理：在内存中形成代理类，通过Proxy.newProxyInstance()方法生成代理对象 123456789101112131415161718192021222324252627//通过代理模式实现敏感词过滤代码展示public void doFilter(ServletRequest req, ServletResponse resp, FilterChain chain) throws ServletException, IOException &#123;//创建代理对象，三个参数：1.真实对象的类加载器；2.真实对象实现的接口； 3.实现动态代理的接口HttpServletRequest request = (HttpServletRequest) Proxy.newProxyInstance(req.getClass().getClassLoader(),req.getClass().getInterfaces(),new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; /*invoke方法的三个参数： * 1. proxy：真实的代理对象 * 2. method：代理对象调用的方法，被封装为的对象 * 3. args:代理对象调用的方法时，传递的实际参数 */ //获取方法的名称 if ("getParameter".equals(method.getName())) &#123; String value = (String) method.invoke(req,args); //检测是否含敏感词 if(value.contains("CNM"))&#123; value = value.replaceAll("CNM","***"); &#125; //返回代理修改后的value return value; &#125; //若不是"getParameter"方法，则直接返回，不修改 return method.invoke(req,args);&#125;&#125;);chain.doFilter(request, resp);&#125; //放行时参数要用代理对象的request，来替换原req 24. Listener 监听器1web三大组件之一，当事件源上发生某个事件后，执行监听器代码。 12345678ServletContextListener：监听ServletContext对象的创建和销毁@WebListener //注解//1. 定义一个类，实现ServletContextListener接口public class ContextLoaderListener implements ServletContextListener &#123; //2. 对象创建后会调用该方法 void contextInitialized(ServletContextEvent sce)：ServletContext //3. 对象被销毁之前会调用该方法 void contextDestroyed(ServletContextEvent sce)：ServletContext 25. Maven1Maven是一个项目管理工具，它包含了：一个项目对象模型 (POM：Project Object Model)，一组标准集合，一个项目生命周期(Project Lifecycle)，一个依赖管理系统(Dependency Management System)，和用来运行定义在生命周期阶段(phase)中插件(plugin)目标(goal)的逻辑。 环境变量及相关配置 M2_HOME：C:\Java\maven\apache-maven-3.5.2 MAVEN_HOME：C:\Java\maven\apache-maven-3.5.2 /conf/settings.xml文件中&lt;localRepository&gt;标签中配置本地仓库位置 idea的maven配置： Maven home directory：指定本地maven安装目录 User settings file：指定setting配置文件路径 Local respository：本地仓库的位置 创建maven的web工程时，选用archetype：maven-archetype-webapp 仓库的分类 本地仓库：通过maven下载的jar包会储存在本地仓库，项目会优先从本地仓库查找jar包 远程仓库：远程仓库可以在互联网内也可以在局域网内 中央仓库：maven中内置一个远程仓库：http://repo1.maven.org/maven2，服务于整个互联网，由Maven团队自己维护，里面存储了非常全的jar包，包含了世界上大部分的流行开源项目的构件。 maven插件 compile：maven工程的编译命令，将src/main/java的文件编译为class文件输出到target目录下。 test：maven工程的测试命令，会执行src/test/java下的单元测试类。 clean：maven工程的清理命令，执行 clean会删除target目录及内容。 package：maven工程的打包命令，对java工程执行package打成jar包，对web工程打成war包。 install：maven工程的安装命令，执行install将maven打成jar包或war包发布到本地仓库。 按上述插件排列顺序，当后面的命令执行时，前面的操作过程也都会自动执行。 Maven指令的生命周期 Clean Lifecycle：在进行真正的构建之前进行一些清理工作。 Default Lifecycle：构建的核心部分，编译，测试，打包，部署等等。 Site Lifecycle：生成项目报告，站点，发布站点。 上述三套生命周期相互独立 依赖范围 依赖范围 编译时有效 测试时有效 运行时有效 例子 compile(默认) √ √ √ spring-core test - √ - Junit provided √ √ - servlet-api runtime - √ √ JDBC驱动 system √ √ - 不推荐使用 因为tomcat自带servlet和jsp的jar包，所以这两类api设定运行时无效，防止冲突 坐标定义 1234567891011&gt; &lt;dependency&gt;&gt; &lt;!--项目名称，定义为组织名+项目名，类似包名--&gt;&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt;&gt; &lt;!-- 模块名称 --&gt;&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;&gt; &lt;!-- 当前项目版本号 --&gt;&gt; &lt;version&gt;3.0.1&lt;/version&gt;&gt; &lt;!-- 依赖范围 --&gt;&gt; &lt;scope&gt;provided&lt;/scope&gt;&gt; &lt;/dependency&gt;&gt; pom基本配置：Maven项目的核心配置文件 1234567891011&gt; &lt;project&gt;：文件的根节点 &gt; &lt;modelversion&gt;：pom.xml使用的对象模型版本 &gt; &lt;groupId&gt;：项目名称，一般写项目的域名 &gt; &lt;artifactId&gt;：模块名称，子项目名或模块名称 &gt; &lt;version&gt;：产品的版本号 &gt; &lt;packaging&gt;：打包类型，一般有jar、war、pom 等 &gt; &lt;name&gt;：项目的显示名，常用于 Maven 生成的文档&gt; &lt;description&gt;：项目描述，常用于 Maven 生成的文档&gt; &lt;dependencies&gt;：项目依赖构件配置，配置项目依赖构件的坐标&gt; &lt;build&gt;：项目构建配置，配置编译、运行插件等&gt; 26. 综合案例BaseServlet123456789//让项目中所有的Servlet删除service方法，并继承BaseServlet，当浏览器访问时会调用父类的service方法protected void service(HttpServletRequest req, HttpServletResponse resp) &#123; //获取请求路径 String uri = req.getRequestURI(); //获取方法名称 String methodName = uri.substring(uri.lastIndexOf('/') + 1); //通过反射，调用子类的方法 Method method = this.getClass().getMethod(methodName, HttpServletRequest.class,HttpServletResponse.class); method.invoke(this, req, resp);&#125; Jquery的serialize方法123$.get("user/regist", $(this).serialize(), function (data) &#123;...&#125;);//.serialize()可以将表单数据序列化为键值对的形式:username=eric&amp;password=123...//通常用于接收（登录、注册）用户提交的表单数据的序列化，便于getParameterMap()方法获取参数 Redis与数据库交互12345678910111213141516171819202122232425public List&lt;Category&gt; findAll() &#123; List&lt;Category&gt; cs = null; Jedis jedis = JedisUtil.getJedis(); //zrangeWithScores方法可以获取值和对应的score，存入Tuple对象中。 //Tuple对象含一个Double score和一个byte[] element 成员变量 Set&lt;Tuple&gt; categorys = jedis.zrangeWithScores("category", 0, -1); if (categorys == null || categorys.size() == 0) &#123; //redis缓存中没有数据，从数据库中读取 cs = categoryDao.findAll(); //将数据缓存到jedis内存中 for (int i = 0; i &lt; cs.size(); i++) &#123; jedis.zadd("category", cs.get(i).getCid(), cs.get(i).getCname()); &#125; &#125; else &#123; //redis缓存中有数据，将数据格式统一转换为List格式返回 cs = new ArrayList&lt;&gt;(); for (Tuple tuple : categorys) &#123; Category category = new Category(); category.setCname(tuple.getElement()); category.setCid((int) tuple.getScore()); cs.add(category); &#125; &#125; return cs;&#125; 根据参数name获取对应的值123456function getParameter(name) &#123; var reg = new RegExp("(^|&amp;)" + name + "=([^&amp;]*)(&amp;|$)","i"); var r = location.search.substr(1).match(reg); if (r!=null) return (r[2]); return null;&#125; SQL语句的拼接12345678910111213141516171819202122public int findTotalCount(int cid, String rname) &#123; //定义模板代码 String sql = "select count(*) from tab_route where TRUE "; StringBuilder sb = new StringBuilder(sql);//用于拼接不同条件 ArrayList params = new ArrayList();//用于存放参数 if (cid != 0) &#123; sb.append(" and cid = ? "); params.add(cid); &#125; if (rname != null &amp;&amp; rname.length() != 0 &amp;&amp; !rname.equals("null")) &#123; sb.append(" and rname like ? "); params.add("%" + rname + "%"); &#125; sql = sb.toString(); int count = -1; try &#123; count = template.queryForObject(sql, Integer.class, params.toArray()); &#125; catch (Exception e) &#123; &#125; return count;&#125; 解决中文乱码的两种方式第一种：在pom.xml下配置uriEncoding标签为utf-8 1234567&lt;configuration&gt; &lt;!-- 通过maven tomcat7:run运行项目时，访问项目的端口号 --&gt; &lt;port&gt;80&lt;/port&gt; &lt;!-- 项目访问路径 本例：localhost:9090, 如果配置的aa， 则访问路径为localhost:9090/aa--&gt; &lt;path&gt;/travel&lt;/path&gt; &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;&lt;/configuration&gt; 第二种：post提交方式下，request.setCharacterEncoding(“utf-8”); 三种前端往后端传参的方式 异步请求 表单提交 a标签 27. Linux1Linux是基于Unix的一种自由和开放源码的操作系统，存在着许多不同的Linux版本，但它们都使用了Linux内核。Linux的版本分为两种：内核版本和发行版本；内核版本是指在Linus领导下的内核小组开发维护的系统内核的版本号。 Linux常用命令 命令 功能 【cd】 cd app 切换到app目录（tab键可补全文件路径） cd .. 切换到上一层目录 cd / 切换到系统根目录 cd ~ 切换到用户主目录 cd - 切换到上一个所在目录 【ls】 ls 显示当前目录下的内容（在linux中以 . 开头的文件都是隐藏的文件） ls -a 显示所有文件或目录（包含隐藏的文件） ls -l (缩写ll) 显示当前目录下文件的详情信息 【dir】 mkdir app 在当前目录下创建app子目录 rmdir app app mkdir –p aaa/bbb 在当前目录下级联创建aaa/bbb子目录 【content】 cat 用于显示文件的内容 more 显示文件部分的内容，按空格显示下一页，回车显示下一行，q退出查看 less 用法和more类似，不同的是less可以通过PgUp、PgDn键来控制 tail -N 用于显示文件后N行的内容 tail -f 动态查看文件日志 【rm】 rm a.txt 删除文件（询问用户） rm -f a.txt 直接删除（不询问用户） rm -r a 询问递归删除 rm -rf a 不询问递归删除 rm -rf * 删除当前目录下所有文件 rm -rf /* 自杀式删除 【cp，mv】 cp a.txt b.txt 将a.txt复制成名为b.txt的文件 cp a.txt ../ 将a.txt文件复制到上一层目录中 mv a.txt b.txt 将a.txt文件重命名为b.txt mv a.txt ../ 将a.txt文件移动到上一层目录中 【tar】 -c 创建一个新tar文件 -v 显示运行过程的信息 -f 指定文件名 -z 调用gzip压缩命令进行压缩 -t 查看压缩文件的内容 -x 解开tar文件 tar –cvf xxx.tar 打包文件 打包 tar –zcvf xxx.tar.gz 打包文件 打包并且压缩 tar –xvf xxx.tar 拆包 tar -zxvf xxx.tar.gz -C 目标路径 解压 【find】 find / -name “ins*” 查找文件名称是以ins开头的文件 find / –user itcast –ls 查找用户itcast的文件 find / –user itcast –type d –ls 查找用户itcast的目录 find /-perm -777 –type d-ls 查找权限是777的文件 【grep】 grep lang 文件名 在文件中查找lang grep lang 文件名 –color 高亮显示 【other】 pwd 显示当前所在目录 touch a.txt 创建一个空文件 clear/ crtl + L 清屏 crtl + C 退出 ifconfig 查询IP地址 Vim编辑器 在Linux下一般使用vi编辑器来编辑文件，vi既可以查看文件也可以编辑文件。 vi有三种模式：命令行、插入、底行模式。 通过 vim 文件名 命令进入Vim编辑器，此时默认为命令行模式。 命令行模式—-按 i 、o、a键—-&gt;插入模式—-按Esc键—-&gt;命令行模式 命令行模式—-按 :（冒号）—-&gt;底行模式：退出：q；保存并退出：wq；不保存退出：q! 重定向输出 &gt; 重定向输出，覆盖原有内容；&gt;&gt; 重定向输出，追加在原内容后； 示例： cat /b.txt &gt; a.txt 将b.txt文件中内容输出定向到a.txt中 ifconfig &gt; ifconfig.txt 将网络配置信息输出定向到ifconfig.txt中 系统管理命令 ps 正在运行的某个进程的状态 ps –ef 查看所有进程 ps –ef | grep ssh 查找某一进程 kill 2868 杀掉2868编号的进程 kill -9 2868 强制杀死进程 管道 |123管道是Linux命令中重要的一个概念，其作用是将一个命令的输出用作另一个命令的输入。示例：ls --help | more 分页查询帮助信息ps –ef | grep java 查询名称中包含java的进程 Linux权限命令文件权限 文件类型 user user user group group group other other other - r w x r w x r w x score 4 2 1 4 2 1 4 2 1 user：属主权限 group：属组权限 other：其他用户权限 r：对文件是指可读取内容 对目录是可以ls w：对文件是指可修改文件内容，对目录是指可以在其中创建或删除子节点(目录或文件) x：对文件是指是否可以运行这个文件，对目录是指是否可以cd进入这个目录 chmod 变更文件或目录的权限：chmod 755 a.txt chmod u=rwx,g=rx,o=rx a.txt Linux三种文件类型 普通文件： 包括文本文件、数据文件、可执行的二进制程序文件等。 目录文件： Linux系统把目录看成是一种特殊的文件，利用它构成文件系统的树型结构。 设备文件： Linux系统把每一个设备都看成是一个文件 文件类型标识 进入etc可以查看：普通文件（-）、目录（d）、符号链接（l）、字符设备文件（c）、块设备文件（s）、套接字（s）命名管道（p） Linux网络操作 hostname 查看主机名 hostname xxx 修改主机名 重启后无效（如果想要永久生效，可以修改/etc/sysconfig/network文件） vim /etc/sysconfig/network-scripts/ifcfg-eth0 持久化修改ip地址 service iptables stop 关闭防火墙 service network status 查看指定服务的状态 service network stop 停止指定服务 service network start 启动指定服务 service network restart 重启指定服务 软件安装 安装方式： 二进制发布包： 软件已经针对具体平台编译打包发布，只要解压，修改配置即可。 RPM包： 软件已经按照redhat的包管理工具规范RPM进行打包发布，需要获取到相应的软件RPM发布包，然后用RPM命令进行安装。 Yum在线安装： 软件已经以RPM规范打包，但发布在了网络上的一些服务器上，可用yum在线安装服务器上的rpm软件，并且会自动解决软件安装过程中的库依赖问题。 源码编译安装： 软件以源码工程的形式发布，需要获取到源码工程后用相应开发工具进行编译打包部署。 上传与下载： FileZilla：文件交互图形化软件，解压后可直接使用，通过拖动文件完成本地与虚拟机的文件交互 lrzsz：使用yum方式安装：yum install lrzsz，可以在crt中设置上传与下载目录：选项→会话选项→X/Y/Zmodem，设置上传和下载目录。在CRT界面输入rz获取上传目录，输入sz获取下载目录 sftp：使用alt + p 组合键打开sftp窗口，使用put 命令上传，使用get命令下载，默认下载位置在当前计算的的文档位置 在Linux上安装JDK 卸载系统自带jdk： rpm -e --nodeps java-1.6.0-openjdk-1.6.0.35-1.13.7.1.el6_6.i686 rpm -e --nodeps java-1.7.0-openjdk-1.7.0.79-2.5.5.4.el6.i686 在Linux服务器上安装JDK： 直接解压就可以：tar –zxvf jdk.tar.gz -C 目标路径 配置JDK的环境变量： vi /etc/profile 在末尾行添加下列文本后，保存退出 123456&gt; #set java environment&gt; JAVA_HOME=/usr/local/jdk/jdk1.7.0_71&gt; CLASSPATH=.:$JAVA_HOME/lib.tools.jar&gt; PATH=$JAVA_HOME/bin:$PATH&gt; export JAVA_HOME CLASSPATH PATH&gt; source /etc/profile 使更改的配置立即生效 在Linux上安装Mysql 卸载系统自带mysql： rpm -e --nodeps mysql-libs-5.1.73-5.el6_6.i686 安装MYSQL服务端： rpm -ivh MySQL-server-5.6.22-1.el6.i686.rpm 查看系统随机生成的root初始密码： cat /root/.mysql_secret 开启mysql服务： service mysql start 登录mysql： mysql -u root -p随机初始密码 第一次操作mysql前修改root用户密码： set password=password(&#39;root&#39;) 设置mysql远程访问： grant all privileges on *.* to &#39;root&#39; @&#39;%&#39; identified by &#39;root&#39;; flush privileges; 关闭防火墙： service iptables stop; 在Linux上安装tomcat 在Linux服务器上安装tomcat： 直接解压就可以：tar –zxvf apache-tomcat-7.0.57 -C 目标路径 启动tomcat： 在tomcat/bin目录下执行 startup.sh（注意防火墙） 查看目标： tomcat/logs/catalina.out 在Linux上安装redis 安装gcc-c++：yum install gcc-c++ 下载redis：wget http://download.redis.io/releases/redis-3.0.4.tar.gz 解压：tar -xzvf redis-3.0.4.tar.gz 切换至程序目录，执行make命令进行编译：make 执行安装命令：make PREFIX=/usr/local/redis install 复制配置文件到redis/bin目录下：cd redis-3.0.4 cp redis.conf/usr/local/redis/bin bin目录下启动redis服务端：./redis-server redis.conf 克隆新窗口，启动redis客户端：./redis-cli 28. Nginx1Nginx 是一款高性能的 http 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，由俄罗斯的程序设计师伊戈尔·西索夫（Igor Sysoev）所开发，官方测试 nginx 能够支支撑5万并发链接，cpu、内存等资源消耗却非常低，运行非常稳定。 Nginx 应用场景 Nginx 可以做网页静态服务器，独立提供 http 服务。 可以实现在一台服务器虚拟出多个网站。 反向代理，负载均衡。高并发需要用多台服务器集群时可以使用 nginx 做反向代理，并且可以设定每台服务器分担负载的概率，不会出现某台服务器负载高宕机而某台服务器闲置的情况。 Nginx启动与访问 创建临时目录：mkdir /var/temp/nginx/client -p 进入到Nginx目录下的sbin目录：cd /usr/local/ngiux/sbin 输入命令启动Nginx：./nginx 启动后查看进程：ps aux|grep nginx 关闭 nginx：./nginx -s stop ./nginx -s quit 重启 nginx：./nginx -s reload 反向代理1以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。 IP绑定域名：本地可以通过修改 hosts 文件（C:\Windows\System32\drivers\etc），配置域名和 ip 的映射关系，如果 hosts 文件中配置了域名和 ip 的对应关系，不需要走dns 服务器。 例如：192.168.177.129 www.hmtravel.com 12345678910111213&gt; 配置反向代理：&gt; upstream tomcat-travel&#123;&gt; server 192.168.177.129:8080;&gt; &#125;&gt; server &#123;&gt; listen 80; # 监听的端口&gt; server_name www.hmtravel.com; # 域名或ip&gt; location / &#123; # 访问路径配置&gt; # root index;# 根目录&gt; proxy_pass http://tomcat-travel; # 通过此步设置代理的目录&gt; index index.html index.htm; # 默认首页&gt; &#125;&#125;&gt; 负载均衡1英文名称为Load Balance，其意思就是分摊到多个操作单元上进行执行，提供了一种廉价有效透明的方法扩展网络设备和服务器的带宽、增加吞吐量、加强网络数据处理能力、提高网络的灵活性和可用性。 123456789101112131415配置负载均衡:修改 Nginx配置文件 upstream tomcat-travel &#123; server 192.168.177.129:8080; server 192.168.177.129:8081 weight=2; server 192.168.177.129:8082; &#125; server &#123; listen 80; # 监听的端口 server_name www.hmtravel.com; # 域名或ip location / &#123; # 访问路径配置 # root index;# 根目录 proxy_pass http://tomcat-travel; index index.html index.htm; # 默认首页 &#125; &#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[java核心]]></title>
    <url>%2F2019%2F06%2F16%2FJava%E6%A0%B8%E5%BF%83%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[Java核心知识点总结【入门程序、常量、变量】1. Java语言用途1开发网站的后台业务逻辑，例如：传统行业和电商 2. 十进制和二进制的转换规则123十进制转二进制：辗转相除法，一直到商为0为止，取余数，将余数倒着连接就是二进制二进制转十进制：位权乘以二进制数，再相加 3.计算机存储单元123最小的存储单元是字节，一个字节 = 8 bit，100Mbps ≈ 12MB/s进制单位是1024 4. Java的跨平台性？1因为Java运行在虚拟机上，不同的系统对应不同版本的虚拟机（JVM） 5. JDK、JRE和JVM1234567JDK：是开发工具包，能进行开发，运行环境JRE：是java的运行环境JVM：是java的核心，虚拟机包含关系: jdk --&gt; jre --&gt; jvm 6. 环境变量配置的意义1配置环境变量的意义是让操作系统知道去哪里找java命令，使计算机能够在任意目录下运行java和javac这两个命令 7. Java程序编写的三个步骤12345编写：程序员编写代码编译：将我们编写的代码编程计算机能识别的代码运行：运行字节码文件，.class文件，显示效果 8. 常用命令提示符 功能 输入 切换盘符 盘符名称： 进入文件夹 cd 文件夹1\文件夹2\文件夹3 返回上一级 cd .. 直接回根路径 cd \ 查看当前文件夹内容 dir 清屏 cls 退出 exit 9. 注释及其格式1注释是对代码进行解释说明的文字，提高代码的可读性 java中的注释分三种： 单行注释: // 文字 多行注释: /* 文字 */ 文档注释: /** 文字 */ 10. 关键字123关键字：被java语言赋予了特殊的含义的单词，Java一共定义了50个关键字。特点：（1）全部小写；（2）在不同的编辑器下关键字的颜色是不一样的 目前已学的关键字可分为4类：（更新至Day05课程） 定义数据类型：class byte short int long float double char boolean void 定义数据值类型：true false null 定义流程控制：if else switch case default while do for break continue return 其他类型：public static new package import 11. 标识符及其定义规范1标识符：自己定义的单词 硬性要求： 标识符包含英文26字母（大小写）、数字0-9、$、_ 不能以数字开头 不能是关键字 软性建议： 类名：大驼峰（单词的首字母全部大写） 变量名：小驼峰（如果有多个单词，那么第一个单词首字母小写，后面单词首字母大写） 方法名：小驼峰 12. 数据类型123java是强类型语言, 对于每一种数据类型都规定了明确的取值范围。数据类型分为两种：基本数据类型（四类八种）、引用数据类型（目前有String和数组） 四类 八种 字节数 表示范围 整型 byte 1 -128~127 整型 short 2 正负3万多 整型 *int * 4 正负21亿多 整型 long 8 正负19位数 布尔型 boolean 1 true, false 字符型 char 2 一个字符’A’，’a’ 浮点型 float 4 正负38位数 浮点型 double 8 正负308位数 13. 常量及其分类1常量：在程序的执行过程中, 其值不可以发生改变的量 整数常量：所有整数 浮点数常量：所有小数 字符常量：被单引号括起来的内容, 里面只能装单个字 字符串常量：被双引号括起来的内容 布尔常量：true、false 空常量：null 14. 变量及其定义格式1变量：在程序的执行过程中, 其值在某个范围内可以发生改变的量。变量就像一个容器，可以不断修改其中的内容。 三种定义格式： 一步到位 ： int a = 10； 分开定义，赋值： int a； a = 10； 简便格式： int a = 10, b = 20, c = 30; 变量需注意的细节： 变量不赋值，不能使用 变量名不能重复定义 变量赋值的范围，不能超过数据类型的最大表示范围 变量有作用域，作用域是一对大括号 long类型数据需加上标识L，float类型数据需加上标识F 【数据类型转换、运算符、方法入门】1. 数据类型转换123自动类型转换：是程序自动完成的，将小的数据类型转换成大的数据类型强制类型转换：需要手动进行转换，将大的数据类型转换成小的数据类型 格式：int a = (int) 10.5; 2. 精度损失和数据溢出123精度损失：当一个浮点数转为整数的时候，会发生精度损失，精度损失是直接舍弃小数部分数据溢出：当一个表示范围大的数据类型强转为范围小的数据类型的时候，会发生数据溢出，造成部分数据丢失 3. 运算时数据类型的转换规则123范围小的类型向范围大的类型提升，byte、short、char 运算时直接提升为intbyte、short、char--&gt;int--&gt;long--&gt;float--&gt;double 4. 编译器的两点优化1234优化一：对于byte/short/char三种类型来说，如果右侧赋值的数值没有超过范围，那么javac编译器将会自动隐含地为我们补上一个(byte)(short)(char)。byte num1 = /*(byte)*/ 30; // 右侧没有超过左侧的范围 12345优化二：在给变量进行赋值的时候，如果右侧的表达式当中全都是常量，没有任何变量，那么编译器javac将会直接将若干个常量表达式计算得到结果。但是注意：一旦表达式当中有变量参与，那么就不能进行这种优化了。short a = 5;short result = 5 + 8; //编译通过short result2 = a + 8; //编译报错 5. 加号的三种用法123451.数值运算2.和char类型参数运算的时候，会将char类型按照ASCII码表，查表找到对应的ASCII值，进行计算3.用于字符串拼接，所有的数据类型和字符串进行拼接，都会变成字符串，也要看运算顺序 6. ASCII码表美国标准信息交换码(American Standard Code for Information Interchange ） 123人类定义的一个字符和计算机中二进制存储的对照关系表，是所有编码表的核心。编码表本身是字符和一个十进制数进行对应起来组成一张表格，需要记住：&apos;0&apos;-48，&apos;A&apos;-65，&apos;a&apos;-97 7. 运算符 类型 符号 算数运算符 + - * / % ++ -- 赋值运算符 = += -= *= /= %= 比较运算符 &gt; &lt; == &gt;= &lt;= != 逻辑运算符 &amp; ` 三元运算符 数据类型 变量名 = 条件判断？表达式A：表达式B 运算符注意事项： 除法，不会出现小数，会将小数部分舍弃 + 符号在遇到字符串的时候，表示连接、拼接的含义 比较运算符返回的一定是布尔值true、false 逻辑运算符符号两边一定是布尔值 短路效果：如果已经得到结果，那么不会进行后面的操作（双写&amp; | 得到短路效果） 三元运算符的结果必须被使用，必须同时保证表达式A和表达式B都符合左侧数据类型的要求。 8. ++、–的使用场景123单独操作: 就是自身完成+1或者是-1的动作;参数运算：++在前, 先自增, 再赋值；++在后, 先赋值, 再自增。 9. a += 1和a = a + 1的区别1a += 1 等价于 a = (a的数据类型)(a+1)，当中存在隐含了一个强制类型转换的过程 10. 定义方法的好处1231. 将代码按照功能进行划分，提高代码的可读性2. 提高代码的复用性 11. 方法定义和调用的注意事项12345671. 不能嵌套定义，方法中不能定义方法2. 方法的执行顺序和定义顺序无关，和调用顺序有关3. 方法不调用就不执行,main方法不能人为调用4. 在定义方法形式参数的时候,参数需要用逗号隔开 【流程控制语句】1. if语句的三种格式123451.if--一种情况的判断2.if...else两种情况的判断3.if...else if...else多种情况判断 2. 程序的健壮性1健壮性：我们需要尽可能多的考虑程序出现的情况，并给出解决方案 3. switch语句的格式1234567891011121314151617181920public static void main(String[] args) &#123; int num = 1; switch (num) &#123; case 1: System.out.println("春天"); break; case 2: System.out.println("夏天"); break; case 3: System.out.println("秋天"); break; case 4: System.out.println("冬天"); break; default: System.out.println("输入数据超出范围"); break; &#125;&#125; switch语句的注意事项： switch可以接受的4+2种数据类型：4种基本：byte/short/char/int ； 2种引用：String/enum case后面的表达式不能重复 case语句的穿透效果：没有break会往下穿透 switch语句很灵活，前后顺序可颠倒 4. 三种循环语句的格式（1）for循环1234567格式： for(初始化语句;条件判断语句;步进语句)&#123; 循环体; &#125;示例： for(int i = 1; i &lt;= 10; i++)&#123; sop(i); &#125; （2）while循环1234567891011格式： 初始化语句; while(条件判断语句)&#123; 循环体; 步进语句; &#125;示例： int i = 0; while(i &lt;= 10)&#123; sop(i); i++; &#125; （3）do..while循环1234567891011格式： 初始化语句; do&#123; 循环体; 步进语句; &#125;while(条件判断语句);示例： int i = 0; do&#123; sop(i); i++; &#125;while(i &lt;= 10); 5. 三种循环语句的区别123451. for循环的初始化表达式出了循环不能使用，while循环可以使用2. for循环和while循环条件不满足，一次不会执行；do...while循环无论如何执行一次3. 当已知循环次数的情况下，建议使用for循环，不知道次数建议使用while循环 6. break和continue123break：在switch语句中，表示遇到break，switch语句结束；在循环语句中，表示跳出循环，继续往下执行代码continue：结束本次循环，进入下一次循环 7. 死循环的格式123while(true);for(;;); 【Idea、方法】1. 什么是方法12345方法就是经常使用的一部分代码抽取成的代码块方法可以理解为工厂，给方法一些参数，方法换给我们一个结果方法可以理解为模板，方法是写的通用的逻辑，可以重复调用多次，根据传入的参数不同，返回的结果也不同 2. 方法的定义格式1234567修饰符 返回值类型 方法名（参数列表）&#123; 方法体； return (返回值）；&#125; 3. return的作用1231. 将返回值返回给方法的调用处2. 结束方法 4.方法的调用的方式123451. 单独调用：适用于有返回值的和无返回值的方法，有返回值的方法单独调用没有意义2. 打印调用：只适用于有返回值的方法，打印调用返回值结果只能使用一次3. 赋值调用：只适用于有返回值的方法，返回值使用变量接收，可以使用多次 5. 方法的执行流程12345671. 以main方法为起点，虚拟机调用main方法，main方法中调用其他方法2. 调用方法，传递参数3. 将传递的实参给方法中定义的形参进行赋值 ，执行方法体4. 使用return语句将返回值，返回给方法的调用处 6. 方法的三要素123451. 返回值类型：看需求，说是想让你给出结果，还是直接在方法中打印2. 参数列表：看该方法完成任务，需不需要外部提供的参数3. 方法名：小驼峰命名规则，见名知意 7. 方法的重载1方法的重载：是指方法名称相同，但参数列表不同的一组方法。用户希望相似的功能，只需要记一个方法名称。 方法重载的三个相关： 参数列表的个数 参数列表的数据类型 参数列表的参数顺序 方法重载的三个无关： 和参数的变量名称无关 和方法的返回值类型无关 和方法的修饰符无关 8. IDEA 常用快捷键 功能 快捷键 调出结果窗口 Alt + 4 自动导包+修正代码 Alt + Enter 删除光标所在行 Ctrl + Y 往下复制一行 Ctrl + D 格式化代码 Ctrl + Alt + L 自动生成常用方法 Alt + Insert 移动当前代码行 Alt + Shift + 上下箭头 选中一个变量的所有使用处 Shift + F6 快速生成for循环 XXX.fori 【数组】1. 什么是数组1数组是Java中的一种容器，用于存储数据 数组中存储的数据类型一致 数组是引用数据类型 数组的长度一旦确定，不可改变 2. 数组的初始化12345678910动态初始化：int[] array = new int[3];静态初始化：int[] array = new int[]&#123;1,2,3&#125;;静态初始化的省略格式：int[] array = &#123;1,2,3&#125;;动态初始化的拆分：int[] array; array = new int[3];静态初始化拆分：int[] array; array = new int[]&#123;1,2,3&#125;; (拆分后不能使用省略格式进行初始化：array = &#123;1,2,3&#125;) 3. 索引1索引就是数组元素的编号，从0开始，到length-1为止 赋值：数组名[索引值] = 值； 访问：数据类型 变量名 = 数组名[索引值]； 4. Java内存的5个组成部分123451.栈(Stack)：方法运行时使用的内存，比如main方法运行，进入方法栈中执行，存放方法中的局部变量。2.堆(Heap)：存储对象或者数组，new来创建的，都存储在堆内存3.方法区(Method Area)：存储可以运行的class文件4.本地方法栈(Native Method Stack)：JVM在使用操作系统功能的时候使用，和开发无关5.寄存器(pc Register)：与CPU相关，性能极高，和开发无关 5. 数组越界索引异常12系统访问了数组中不存在的索引，将抛出数组越界索引异常。(ArrayIndexOutOfBoundsException) 1234public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; System.out.println(arr[3]);&#125; 6. 数组空指针异常12给数组赋值null之后，数组将不会保存数组的内存地址，也不允许再操作数组了，运行时会抛出空指针异常。(NullPointerException) 12345 public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; arr = null; System.out.println(arr[0]);｝ 7. 方法的参数类型区别123方法的参数为基本类型时,传递的是数据值，值不会受到影响；方法的参数为引用类型时,传递的是地址值，所以在方法中将引用数据类型中的值进行修改，那么会永久性的修改 8. 数组的直接打印123直接打印数组名称，得到的是数组对应的内存地址哈希值[I@7575412c2f 其中[代表数组，I代表int 9. 数组的内存执行流程 编写代码，编译代码，生成.class字节码文件 字节码文件，将信息加载到方法区中，方法区中有类的方法信息 JVM虚拟机去找程序的入口——main方法 main方法进栈执行 main方法中定义的变量，会在栈内存中生成 在堆内存中，开辟了一块空间，将空间中的数值赋默认值，JVM将数组的内存地址赋值给引用类型变量 打印数组名称，找到堆内存中的地址值. 先通过数组名找到堆内存中的地址值，然后通过索引值找到对应的数据值，在数据值进行修改 main方法会出栈/弹栈 堆内存中的两块区域，没有变量去引用了，堆内存中的内容会被JVM垃圾回收机制回收 10. 数组的反转12345678910111213public static void main(String[] args) &#123; int[] arr = &#123; 1, 2, 3, 4, 5 &#125;; for (int min = 0, max = arr.length ‐ 1; min &lt;= max; min++, max‐‐) &#123; //利用第三方变量完成数组中的元素交换 int temp = arr[min]; arr[min] = arr[max]; arr[max] = temp; &#125; // 反转后，遍历数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.println(arr[i]); &#125;&#125; 【类与对象、封装、构造方法】1. 面向对象123就是当我们需要做一件事情的时候，不是去自己亲力亲为的考虑每一个细节，而是找到能做这件事情的人，帮我们做事在代码中，就是找到能完成这个功能的类，并调用这个类中的方法。 2. 类与对象123类：是一个模板，描述了现实事物的信息对象：是根据类这个模板生成的一个实体，会在堆内存中开辟空间 类是对象的模板，对象是类的实体 3. 类描述的信息123属性：事物具备什么特征，在代码中叫做成员变量行为：事物能做什么事情，在代码中叫做成员方法 4. 对象的使用方式12345导包：通常不用考虑，IDEA会进行自动导包创建对象：根据类生成一个对象实例使用：给对象中的成员变量进行赋值，调用方法 5. 成员变量和局部变量区别 成员变量 局部变量 类中位置 类中，方法外 方法内 作用范围 类中 方法中 初始化值 有默认值 无默认值 内存中位置 堆内存 栈内存 生命周期 随着对象存在 随着方法存在 6. 封装12345就是将细节隐藏起来，对外只暴露实现方式（1）方法是一种封装（2）private关键字也是一种封装 7. private关键字1将成员变量私有，只允许本类访问，不允许外界访问，对外提供Getter/Setter方法 8. this关键字123this代表所在类的当前对象的引用（地址值），即对象自己的引用。方法被哪个对象调用，方法中的this就代表那个对象。即谁在调用，this就代表谁。 9. 成员变量的默认值 数据类型 默认值 基本类型 整数 0 浮点数 0.0 字符 ‘/u0000’ 布尔 false 引用类型 数组，类，接口 null 10. 构造方法注意事项 构造方法的名称必须和所在的类名称完全一样，就连大小写也要一样 构造方法不要写返回值类型，连void都不写 构造方法不能return一个具体的返回值 如果你不提供构造方法，系统会给出无参数构造方法。 如果你提供了构造方法，系统将不再提供无参数构造方法。 构造方法是可以重载的，既可以定义参数，也可以不定义参数。 11. 标准代码——JavaBean123456789101112131415161718192021222324public class Student &#123; //成员变量 private String name; private int age; //构造方法 public Student() &#123;&#125; public Student(String name,int age) &#123; this.name = name; this.age = age; &#125; //成员方法 public void setName(String name) &#123; this.name = name; &#125; public String getName() &#123; return name; &#125; public void setAge(int age) &#123; this.age = age; &#125; public int getAge() &#123; return age; &#125;&#125; 12. 对象的内存图流程 方法区加载类的方法信息 JVM去找main方法，main方法进栈执行 在栈内存中生成一个变量Phone one，在堆内存中开辟一块空间，内含成员变量和成员方法 对成员变量进行赋值 调用成员方法，方法进栈执行，执行完毕之后，方法出栈 最后main方法出栈 垃圾回收机制回收堆内存中的两块区域 【Scanner类、Random类、ArrayList类】1. API的使用方式 （Application Programming Interface） 应用程序编程接口 12345（1）看包路径 --&gt;导包（2）构造方法--&gt;创建（3）成员方法--&gt;使用 2. Scanner类使用步骤1234567Scanner sc = new Scanner(System.in);sc.nextInt();录入整数sc.next();录入字符串，不含空格，Tab。有效字符之前的空格、Tab被视为无效；之后的空格、Tab视为结束符号sc.nextLine();可以包含空格和Tab,只以回车为结束符号 3. Random类使用步骤12345Random ran = new Random();ran.nextInt()；生成一个int范围的随机数生成(a~b)范围的随机数: ran.nextInt(b-a+1)+a 4. 匿名对象12345匿名对象就是没有变量名接受的对象，new 类名（）；优点：省略变量名，减少代码的编写缺点：对象只能使用一次 5. 数组与集合的不同 数组 集合 运行期间长度 不可变 可变 存储数据类型 基本+引用数据类型 引用数据类型 直接打印 地址值 集合的内容 可操作方法 查、改 增、删、改、查 获取长度 数组名.length 集合名称.size() 6. ArrayList类1ArrayList集合是Java中的一种容器，底层是数组，默认初始长度是10 特点： 长度是可变的 只能存储引用数据类型，如果想存储基本数据类型，要使用其包装类 直接打印显示的是集合的内容 7. ArrayList中的常用方法12345public boolean add(E e)：向集合当中添加元素，参数的类型和泛型一致，返回值是boolean(Always true)public E remove(int index)：从集合当中删除元素，参数是索引编号，返回值就是被删除掉的元素public E set(int index, E element): 用指定的元素替代此列表中指定位置上的元素,返回被替代的元素public E get(int index)：从集合当中获取元素，参数是索引编号，返回值就是对应位置的元素public int size(): 获取集合的尺寸长度，返回值就是集合中包含的元素个数 8. 包装类 基本类型 基本类型包装类 byte Byte short Short int Integer long Long float Float double Double char Character boolean Boolean 自动装箱：基本类型 –&gt;包装类型自动拆箱：包装类型 –&gt;基本类型 【String类、static关键字、Arrays类、Math类】1. String类的三个特点123451. 字符串不变：字符串的值在创建后不能被更改。2. 因为String对象是不可变的，所以它们可以被共享。3. "abc" 等效于 char[] data=&#123;'a','b','c'&#125;，底层原理是byte[]字节数组。 2. 创建字符串的1+3种方法123456一种直接创建：直接写上双引号，就是字符串对象三种构造方法：1. public String()：初始化新创建的 String对象，以使其表示空字符序列2. public String(char[] array)：根据字符数组的内容，来创建对应的字符串3. public String(byte[] array)：根据字节数组的内容，来创建对应的字符串 字符串常量池：直接写“ ”的字符串，在常量池中，如果常量池中有相同的字符串，那么不会创建新的，而是使用以前的。双引号直接写的字符串在常量池当中，new出来的不在池当中。 1234567public static void main(String[] args) &#123; String s1 = "Java"; String s2 = "Java"; char[] chars = &#123;'J', 'a', 'v', 'a'&#125;; String s3 = new String(chars); System.out.println("s1和s2是否直接相等" + (s1 == s2)); //true System.out.println("s1和s3是否直接相等" + (s1 == s3)); //false 3.String常用方法判断12public boolean equals(Object anObject)：将此字符串与指定对象进行比较。public boolean equalsIgnoreCase(String anotherString)：将此字符串与指定对象进行比较，忽略大小写。 获取123456public int length () ：返回此字符串的长度。public String concat (String str) ：将指定的字符串连接到该字符串的末尾。public char charAt (int index) ：返回指定索引处的 char值。public int indexOf (String str) ：返回指定子字符串第一次出现在该字符串内的索引。public String substring (int begin) ：返回一个子字符串，从begin开始截取字符串到字符串结尾。public String substring (int begin, int end) ：返回一个子字符串，从[begin,end)截取字符串。 转换123public char[] toCharArray () ：将此字符串转换为新的字符数组。public byte[] getBytes () ：使用平台的默认字符集将该 String编码转换为新的字节数组。public String replace (CharSequence target, CharSequence replacement) ：将与target匹配的字符串使用replacement字符串替换。 分割1public String[] split(String regex) ：将此字符串按照给定的regex（规则）拆分为字符串数组。 String可以比，接，截，割，替，从内容获取索引，从索引获取内容 equal, concat, substring, split, replace, indexof, charAt 4. 正则表达式 正则表达式也是一个字符串，是专门解决字符串规则匹配的工具，用来定义匹配规则 表达式 含义 x 字符 x \\ 反斜线字符 [abc] a、b 或 c（简单类） [^abc] 任何字符，除了 a、b 或 c（否定） [a-zA-Z] a 到 z 或 A 到 Z，两头的字母包括在内（范围） \w 单词字符：[a-zA-Z_0-9] X? X，一次或一次也没有 X* X，零次或多次 X+ X，一次或多次 X{n} X，恰好 n 次 X{n,} X，至少 n 次 X{n,m} X，至少 n 次，但是不超过 m 次 5. static关键字123static关键字可以用来修饰的成员变量和成员方法，被修饰的成员是属于类的，而不是单单是属于某个对象的。也就是说，既然属于类，就可以不靠创建对象来调用了。 静态存储在方法区中，既不在堆中，也不在栈中（方法中有一块独立的静态区） 类变量123当 static 修饰成员变量时，该变量称为类变量。该类的每个对象都共享同一个类变量的值。任何对象都可以更改该类变量的值，也可以在不创建该类的对象的情况下对类变量进行操作。 静态方法1当static修饰成员方法时，该方法称为类方法,习惯称为静态方法。建议使用类名来调用，而不需要创建类的对象。 静态方法调用的注意事项： 静态方法可以直接访问类变量和静态方法。 静态方法不能直接访问普通成员变量或成员方法。反之，成员方法可以直接访问类变量或静态方法。 静态方法中，不能使用this关键字。 静态代码块1类中方法外，使用static修饰的代码块&#123; &#125;。 当第一次用到本类时，静态代码块执行唯一的一次，优先于main方法和构造方法的执行。 作用：给类变量进行初始化赋值。 6. Arrays类12public static String toString(int[] a) ：返回指定数组内容的字符串表示形式。public static void sort(int[] a) ：对指定的 int 型数组按数字升序进行排序。 123456public static void main(String[] args) &#123; int[] arr = &#123;2,34,35,4,657,8,69,9&#125;; System.out.println(arr); // [I@2ac1fdc4 System.out.println(Arrays.toString(arr)); // [2, 34, 35, 4, 657, 8, 69, 9] Arrays.sort(arr); System.out.println(Arrays.toString(arr)); //[2, 4, 8, 9, 34, 35, 69, 657] 备注：如果是数值，sort方法默认按照升序从小到大如果是字符串，sort方法默认按照字母升序如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持 1234567// 冒泡排序法代码 public static void mySort(int[] arr)&#123; for (int i = 1; i &lt; arr.length; i++) &#123; for (int j = i; j &gt; 0 &amp;&amp; arr[j] &lt; arr[j-1] ; j--) &#123; int temp = arr[j]; arr[j] = arr[j-1]; arr[j-1] = temp;&#125; &#125; &#125; 7. Math类1234public static double abs(double a)：获取绝对值public static double ceil(double a)：向上取整public static double floor(double a)：向下取整public static long round(double a)：四舍五入 【继承、super、this、抽象类】1. 继承123就是子类继承父类的属性和行为，使得子类对象具有与父类相同的属性、相同的行为。子类可以直接访问父类中的非私有的属性和行为。 语法格式：子类 extends 父类 继承的作用：提高代码复用性，类与类之间产生了关系，是多态的前提。 继承的特点： 一个子类只能有一个直接父类，不能有多个直接父类 继承可以支持多级继承，一个子类只能有一个直接父类，但可以有多个间接父类 一个父类可以有多个子类 2. 抽象类1对子类共性的内容进行抽取，有可能包含抽象方法的类 语法格式：abstract关键字 抽象类的作用： 为子类提供便利：抽象类中可以定义一些方法，子类继承之后可以直接使用 对子类进行约束：抽象类中的抽象方法，子类继承之后，必须重写，否则子类也是一个抽象类 注意事项： 抽象类不能创建对象，如果要创建，需要创建的是子类（抽象类的对象调用方法无方法体，无意义） 抽象类中可以包含构造方法，用于初始化父类成员 抽象类中可以没有抽象方法，但是只要类中有抽象方法，那这个类一定是一个抽象类 子类继承抽象类必须重写全部抽象方法，否则该子类也是一个抽象类 3. 继承后的特点成员变量重名1使用super关键字区分 成员方法重名——重写(Override)1子类中出现与父类一模一样的方法时（返回值类型，方法名和参数列表都相同），会出现覆盖效果，也称为重写或者复写。 方法重写的注意事项： 必须保证父子类之间方法的名称相同，参数列表也相同。 @Override:写在方法前面，用来检测是不是有效的正确覆盖重写，也可以不写。 子类方法的返回值必须【小于等于】父类方法返回值的范围。 子类方法的权限必须【大于等于】父类方法的权限修饰符。 备注：public &gt; protected &gt;(default) &gt; private，（default）不是关键字，是什么都不写，留空。 构造方法 构造方法注意事项： 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。 4. super关键字的三种用法12345（1）在子类的成员方法中，访问父类的成员变量（2）在子类的成员方法中，访问父类的成员方法（3）在子类的构造方法中，访问父类的构造方法 5. this关键字的三种用法12345（1）在本类的成员方法中，访问本类的成员变量（2）在本类的成员方法中，访问本类的成员方法（3）在本类的构造方法中，访问本类的另一种重载的构造方法 注意：super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 【接口、多态】1. 接口的定义1接口，是Java语言中一种引用类型，是方法的集合，使用interface关键字，是一种公共的规范标准。 作用：（1）提供功能的拓展（2）提出约束 定义格式：public interface 接口名称{接口内容} 注意：接口也会被编译成.class文件，但一定要明确它并不是类，而是另外一种引用数据类型。 2. 接口包含的内容常量（Java 7）123接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。一旦赋值，不可以修改，从效果上看，这其实就是接口的【常量】。 注意事项： 三个修饰符可以省略，但是不写也默认有 接口当中的常量，必须进行赋值；不能不赋值。 接口中常量的名称，使用完全大写的字母，用下划线进行分割： public static final int NUM_OF_PEOPLE = 10; 抽象方法（Java 7）1public abstract 返回值 方法名称（参数列表）; public abstract 可以省略不写 默认方法(Java 8)1public default 返回值类型 方法名称（参数列表）&#123;方法体&#125; 接口中的默认方法用于接口的升级和修改，可以保证所有的实现类不必被强制要求重写抽象方法。 如果重写使用重写的方法，如果不重写使用默认方法。 静态方法(Java 8)1public static 返回值类型 方法名称（参数列表）&#123;方法体&#125; 注意：不能通过接口实现类的对象来调用接口当中的静态方法！因为一个实现类可能实现多个接口，通过对象调用接口的静态方法有可能方法名重复导致冲突。正确用法：通过接口名称，直接调用其中的静态方法。 私有方法(Java 9)123（1）普通私有方法：private 返回值 方法名称（参数列表）&#123;&#125;（2）静态私有方法：private static 返回值 方法名称（参数列表）&#123;&#125; 解决多个默认方法和静态方法代码重复度过高问题，同时避免该方法被接口的实现类使用。 从设计的角度讲，私有的方法是对默认方法和静态方法的辅助。 3. 接口的多实现1一个类可以实现多个接口 注意事项： 有多个抽象方法时，实现类必须重写所有抽象方法。如果抽象方法有重名的，只需要重写一次。 有多个默认方法时，实现类都可继承使用。如果默认方法有重名的，必须重写一次。 存在同名的静态方法并不会冲突，原因是只能通过各自接口名访问静态方法。 当一个类既继承一个父类，又实现若干个接口时，父类中的成员方法与接口中的默认方法重名，子类就近 选择执行父类的成员方法。 4. 接口的特点1234567891. 一个接口能继承另一个或者多个接口，使用 extends 关键字，子接口继承父接口的方法。2. 如果父接口中的默认方法有重名的，那么子接口需要重写一次。3. 如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。4. 接口中，没有构造方法，不能创建对象。5. 接口中，没有静态代码块。 5. 多态1父类引用指向子类对象，一个对象的多种形态 多态使用的前提条件：必须以继承或者实现为前提条件（用父类或者接口去接收对象都行） 多态的表现形式：父类类型 变量名 = new 子类（）; 接口类型 变量名 = new 实现类（）; 6. 多态成员的访问123456789多态成员变量的访问方式：编译看左边，运行也看左边（1）直接访问：看等号左边是谁就优先用谁，没有向上找（2）间接访问：方法属于谁，就优先用谁，没有向上找多态成员方法的访问方式：编译看左边，运行看右边看等号右边对象创建的是谁，就优先用谁，没有向上找 7. 多态的好处和弊端123好处：提高代码复用性弊端：不能使用子类独有的方法 8. 引用、对象、对象名称的区分1234567Animal a = new Cat();引用：等号左侧的数据类型叫引用（Animal）对象：等号右边new的就是对象（new Cat()）对象名称：变量名称就叫对象名称（a） 9. 向上转型和向下转型123向上转型：向上转型一定是安全的，因为左父右子，从小范围转向了大范围 向下转型：子类类型 变量名 = （子类类型）父类对象；不安全 对象的向下转型，其实是一个【还原】的动作。由哪个子类转成的父类类型，再转回去要注意，不能转为其 他子类类型，否则会报错。(ClassCastException) 10. instanceof 关键字123格式：变量名 instanceof 数据类型如果变量属于该数据类型，返回true；如果变量不属于该数据类型，返回false instanceof 可用于判断对象属于哪一个实例，一般都在方法中使用。 对传入的父类类型的对象进行实例判断，强转回子类，目的是调用子类特有的方法 12345678910public class Test &#123; public static void main(String[] args) &#123; // 向上转型 Animal a = new Cat(); if (a instanceof Cat)&#123; Cat c = (Cat)a; c.catchMouse(); // 调用的是 Cat 的 catchMouse &#125; else if (a instanceof Dog)&#123; Dog d = (Dog)a; d.watchHouse(); // 调用的是 Dog 的 watchHouse 【final、权限、内部类、引用类型】1. final 关键字1被final关键字修饰的类、方法和变量不可改变。有以下四种主要用法： 修饰类12final class 类名 &#123;&#125; 修饰方法123修饰符 final 返回值类型 方法名(参数列表)&#123; //方法体&#125; 修饰局部变量1因为局部变量无初始化默认值，可以先定义后赋值。&#123;final int a; a = 10;&#125; 修饰成员变量123451. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。&#123;final int a = 10;&#125;2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值，二者选其一。3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 2. 权限修饰符 public protected (default) private 同一类中 √ √ √ √ 同一包中 √ √ √ 不同包的子类 √ √ 不同包的无关类 √ 3. 成员内部类123456定义在类中方法外的类。class 外部类 &#123; class 内部类&#123; &#125;&#125; 访问特点： 内部类可以直接访问外部类的成员，包括私有成员。 外部类要访问内部类的成员，必须要建立内部类的对象。 创建内部类对象格式：外部类名.内部类名 对象名 = new 外部类型().new 内部类型()； 注意： 内部类仍然是一个独立的类，在编译之后会内部类会被编译成独立的.class文件，但是前面冠以外部类的类名和$符号 。比如，Outer$Heart.class 如果内部类和外部类的变量出现了重名现象，那么在内部类调用外部类变量的格式是： 外部类名称.this.对象名 123456789101112public class Outer &#123; int num = 10; // 外部类的成员变量 public class Inner &#123; int num = 20; // 内部类的成员变量 public void methodInner() &#123; int num = 30; // 内部类方法的局部变量 System.out.println(num); // 30 局部变量，就近原则 System.out.println(this.num); // 20 内部类的成员变量 System.out.println(Outer.this.num); // 10 外部类的成员变量 &#125; &#125;&#125; 4. 类的权限修饰符1234567定义一个类的时候，权限修饰符规则：1. 外部类：public/(default)2. 成员内部类：四个都行3. 局部内部类：什么都不能写 5. 局部内部类的final问题123456789//局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。public void methodOuter() &#123; int num = 10; // 所在方法的局部变量,从Java 8+开始,只要局部变量事实不变,那么final关键字可以省略 class MyInner &#123; public void methodInner() &#123; System.out.println(num); &#125; &#125;&#125; 原因： new出来的对象在堆内存当中。 局部变量是跟着方法走的，在栈内存当中。 方法运行结束之后，立刻出栈，局部变量就会立刻消失。 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。 6. 匿名内部类1是内部类的简化写法。它的本质是一个带具体实现的【父类或者父接口的】匿名的子类对象。 12345678//格式new 父类名或者接口名()&#123; // 方法重写 @Override public void method() &#123; // 执行语句 &#125;&#125;; 匿名内部类特点： 匿名内部类的好处：不用编写实现类，就能创建实现类对象。 匿名内部类的弊端：创建的这个实现类对象，模板只能使用一次。 匿名内部类和匿名对象不是一回事，但是可以【匿名内部类】+【匿名对象】组合使用 【Object类、常用API】1. Object类1java.lang.Object类是Java语言中的根类，即所有类的父类。它中描述的所有方法子类都可以使用。如果一个类没有特别指定父类， 那么默认则继承自Object类。 2. toString方法12toString方法返回该对象的字符串表示，其实该字符串内容就是对象的类型+@+内存地址值。直接打印对象的名字，其实就是调用对象的toString方法。toString方法可以通过快捷键快速覆盖重写。 3. equals方法1234567891011121314调用成员方法equals并指定参数为另一个对象，则可以判断这两个对象是否是相同的。默认进行的比较是 == 运算符的对象地址比较，只要不是同一个对象，结果必然为false。希望进行对象内容的比较时，可以通过重写进行对象内容的比较：@Override public boolean equals(Object o) &#123; // 如果对象地址一样，则认为相同 if (this == o) return true; // 如果参数为空，或者类型信息不一样，则认为不同 if (o == null || getClass() != o.getClass()) return false; //向下转型 Student student = (Student) o; // 要求基本类型相等，并且将引用类型交给java.util.Objects类的equals静态方法取用结果 return age == student.age &amp;&amp; Objects.equals(name, student.name);&#125; 4. Objects类1在JDK7添加了一个Objects工具类，它由一些静态的实用方法组成，这些方法是null-save（空指针安全的）或null-tolerant（容忍空指针的），在比较两个对象的时候，Object的equals方法容易抛出空指针异常，而Objects类中的equals方法就优化了这个问题。 public static boolean equals(Object a, Object b) :判断两个对象是否相等 12345//源码public static boolean equals(Object a, Object b) &#123; //短路与，若a为null，则避免了a.equals(b)的执行 return (a == b) || (a != null &amp;&amp; a.equals(b));&#125; 5. Date类1表示特定的瞬间，精确到毫秒。 注意： 时间原点：1970年1月1日 00:00:00（英国格林威治时间） 中国属于东八区，会把时间增加8个小时 两个构造方法： Date():返回当前时间的日期对象 Date(long date):返回一个从1970年1月1日 0点0分0秒 + 毫秒值 所对应的日期对象 一个成员方法： getTime():将一个日期对象，转为对象的毫秒值表示 6. DateFormat类1DateFormat用于将日期对象格式化成指定的字符串表示，或者将一个字符串解析成Date对象。 构造方法：public SimpleDateFormat(String pattern) 格式化：按照指定的格式，从Date对象转换为String对象： public String format(Date date) 解析：按照指定的格式，从String对象转换为Date对象： public Date parse(String source) 格式规则 字母 日期或时间元素 y 年 M 年中的月份 D 年中的天数 d 月份中的天数 E 星期中的天数 H 一天中的小时数（0-23） m 小时中的分钟数 s 分钟中的秒数 S 毫秒数 7. Calendar类1Calendar 类是一个抽象类，它为特定瞬间与一组诸如 YEAR、MONTH、DAY_OF_MONTH、HOUR等日历字段之间的转换提供了一些方法，并为操作日历字段（例如获得下星期的日期）提供了一些方法。 常用方法： public static Calendar getInstance()： 通过静态方法创建对象 public int get(int field)：返回给定日历字段的值 public abstract void add(int field, int amount) ：根据日历的规则，为给定的日历字段添加或减去指定的时间量。 public Date getTime()：返回一个表示此Calendar时间值(从历元到现在的毫秒偏移量)的Date对象。 public void set(int field, int value)：将给定的日历字段设置为给定值。 （也可以同时设置年月日：set(int year, int month, int day)） Calendar类中提供很多成员常量，代表给定的日历字段： 字段值 含义 YEAR 年 MONTH 月（月份特殊，西方是0-11表示12个月，可以+1使用） DAY_OF_MONTH 月中的天（几号） HOUR 时（12小时制） HOUR_OF_DAY 时（24小时制） MINUTE 分 SECOND 秒 DAY_OF_WEEK 周中的天（西方是从星期日开始每周的第一天，可以-1使用） 8. 日期、字符串、毫秒值和日历的相互转换123456789 SimpleDateFormat.parse(s) Date.getTime(d) 字符串 ------------------------&gt; 日期 -----------------------&gt; 毫秒值 (String) &lt;------------------------ (Date) &lt;----------------------- (long) SimpleDateFormat.format(d) /|\ | new Date(l) | | getTime() | | setTime(Date date) | | | \|/ 日历（Calendar） Date类是另外三种时间格式连接的桥梁，相互之间转换时都需要通过Date类。 9. System类12public static long currentTimeMillis() ：返回以毫秒为单位的当前时间，经常用来测试程序性能。public static void arraycopy(Object src, int srcPos, Object dest, int destPos, int length) ：将源数组中指定的数据拷贝到目标数组中。数组的拷贝动作是系统级的，性能很高。 参数名称 参数类型 参数含义 src Object 源数组 srcPos int 源数组索引起始位置 dest Object 目标数组 destPos int 目标数组索引起始位置 length int 复制元素个数 10. StringBuilder类1StringBuilder又称为可变字符序列，它是一个类似于String的字符串缓冲区，支持可变的字符串，可以提高字符串的操作效率。底层也是一个数组，但是没有被final修饰，可以改变长度在数组中加入新内容。 构造方法： public StringBuilder() ：构造一个空的StringBuilder容器。 public StringBuilder(String str)：构造一个StringBuilder容器，并将字符串添加进去。 常用方法： public StringBuilder append(…) ：添加任意类型数据的字符串形式，并返回当前对象自身。 public String toString() ：将当前StringBuilder对象转换为String对象。 11. 基本类型与字符串之间的转换 基本类型转换为String 基本类型的值 + “” (推荐方法） static String toString(基本数据类型):String s = Integer.toString(int i) static String valueOf(基本数据类型):String s = String.valueOf(int i) String转换为基本类型 除了Character类之外，其他所有包装类都具有parseXxx静态方法可以将字符串参数转换为对应的基本类型。 例如：Integer类: static int parseInt(String s) 【Collection、泛型】1. Collection1单列集合类的根接口，有两个重要的子接口，分别是java.util.List和java.util.Set List 特点：元素有序、元素可重复 主要实现类：java.util.ArrayList和java.util.LinkedList Set 特点：元素无序，而且不可重复 主要实现类：java.util.HashSet和java.util.LinkedHashSet 2. 集合和数组的区别 长度不同 集合：集合的长度是可变的，因为集合的底层就是数组，当增删元素的时候，会进行数组的扩容 数组：数组的长度在运行期间不可变，一旦创建，就固定 存储的数据类型不同 集合：只能存储引用数据类型，如果想存储基本数据类型，需要存储对应的包装类 数组：基本数据类型和引用数据类型都可以存储 3. Collection 常用功能1Collection中定义了单列集合(List和Set)通用的一些方法，这些方法可用于操作所有的单列集合: public boolean add(E e)： 把给定的对象添加到当前集合中 。 public void clear() :清空集合中所有的元素。 public boolean remove(E e): 把给定的对象在当前集合中删除。 public boolean contains(E e): 判断当前集合中是否包含给定的对象。 public boolean isEmpty(): 判断当前集合是否为空。 public int size(): 返回集合中元素的个数。 public Object[] toArray(): 把集合中的元素，存储到数组中。 4. Iterator接口1【迭代器】Iterator是一种通用的Collection集合元素的获取方式，通过判断集合中是否有元素，有则取出，继续判断，直到把集合中的元素全部取出为止。 获取迭代器的方法： collection.iterator():由于接口不能直接实例化，使用集合的Iterator方法获取 常用的两个方法： public E next():返回迭代的下一个元素。 public boolean hasNext():如果仍有元素可以迭代，则返回 true。 并发修改异常：迭代器的底层实现原理，运用到指针。在使用迭代器的过程中，修改了集合的长度，就会抛出该异常。使用Iterator接口的一个子接口ListIterator接口可以解决这个问题。 1234567//代码展示：public static void main(String[] args) &#123; Collection&lt;String&gt; coll = new ArrayList&lt;String&gt;(); Iterator&lt;String&gt; it = coll.iterator(); //通过集合获取迭代器 while(it.hasNext())&#123; //判断是否有迭代元素 String s = it.next();//获取迭代出的元素 System.out.println(s);&#125;&#125; 5. ListIterator接口1Iterator接口有一个子接口ListIterator接口，其中定义了add方法和remove方法，可以对集合添加\删除元素。由迭代器自己添加\删除的不会抛出异常。 使用步骤： 创建的集合首先不能使用Collection，因为Collection获取不了ListIterator接口，需要使用List接口获取ListIterator接口实现类 调用listIterator（）方法，获取listIterator接口实现类 使用hasNext和next方法进行迭代 使用接口实现类的add方法进行添加，remove方法进行删除元素。注意：不要使用集合进行添加删除 12345678910//代码展示public static void main(String[] args) &#123; List&lt;String&gt; list = new ArrayList&lt;&gt;(); list.add("黑马"); ListIterator&lt;String&gt; lit = list.listIterator(); while (lit.hasNext()) &#123; String s = lit.next(); System.out.println(s); if ("黑马".equals(s)) &#123; lit.add("金马");&#125;&#125; 6. 增强for1234增强for循环是基于迭代器设计的一种高级for循环，专门用于遍历数组和集合。它的内部原理其实是个Iterator迭代器，所以在遍历的过程中，不能对集合中的元素进行增删操作。格式：for(元素的数据类型 变量 : Collection集合or数组)&#123; //写操作代码&#125; 7. 泛型1在定义类或方法时，对于未知类型的数据进行占位，用于后期接收数据类型，以便预支使用的一种未知的数据类型。 泛型的好处： 避免了类型转换的麻烦，使用API时更加直观简洁。 把运行期异常，提升到了编译期 含有泛型的类 定义格式：修饰符 class 类名&lt;代表泛型的变量&gt; {} 确定泛型：在创建对象的时候 含有泛型的方法 定义格式：修饰符 &lt;代表泛型的变量&gt; 返回值类型 方法名(参数){} 确定泛型：调用方法时 含有泛型的接口 定义格式：修饰符 interface 接口名&lt;代表泛型的变量&gt; {} 确定泛型：1、定义类时确定泛型的类型； 2、始终不确定泛型的类型，直到创建对象时，确定泛型的类型 8. 泛型通配符12不知道使用什么类型来接收的时候,此时泛型可以使用“?”表示,“?”表示未知通配符。但是一旦使用泛型的通配符后，只能使用Object类中的共性方法，集合中元素自身方法无法使用。 受限泛型：泛型没有继承概念，JAVA的泛型中可以指定一个泛型的上限和下限。 泛型的上限： 格式： 类型名称 &lt;? extends 类 &gt; 对象名称 意义： 只能接收该类型及其子类 泛型的下限： 格式： 类型名称 &lt;? super 类 &gt; 对象名称 意义： 只能接收该类型及其父类型 【List、Set、数据结构、Collections】1. 数据结构栈1stack,又称堆栈，它是运算受限的线性表，其限制是仅允许在标的一端进行插入和删除操作 特点：先进后出 压栈：就是存元素。即，把元素存储到栈的顶端位置，栈中已有元素依次向栈底方向移动一个位置。 弹栈：就是取元素。即，把栈的顶端位置元素取出，栈中已有元素依次向栈顶方向移动一个位置。 队列1也是一种运算受限的线性表，其限制是仅允许在表的一端进行插入，而在表的另一端进行删除。 特点：先进先出 数组1数组是有序的元素序列，在内存中开辟一段连续的空间，并在此空间存放元素 特点：有索引值，查询快，增删慢 链表1链表中的每一个元素也称之为一个节点，一个节点包含了一个数据源，两个指针域（存储地址）：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。 特点：查询慢，增删快 单项链表：链表中只有一条链，不能保证元素的顺序（存储元素和取出元素的顺序可能不一致） 双向链表：链表中有两条链子，有一条链子是专门记录元素的顺序，是一个有序的集合 红黑树1是一种比较平衡的二叉树 特点：速度特别快，趋近平衡树，查询叶子节点最大次数和最小次数不能超过2倍 约束： 节点可以是红色的或者黑色的 根节点是黑色的 叶子节点(特指空节点)是黑色的 每个红色节点的子节点都是黑色的 任何一个节点到其每一个叶子节点的所有路径上黑色节点数相同 2. List 接口 特点： 有序的集合,存储元素和取出元素的顺序是一致的(存储123 取出123) 有索引,包含了一些带索引的方法 允许存储重复的元素 12345常用方法： - public void add(int index, E element): 将指定的元素，添加到该集合中的指定位置上。 - public E get(int index):返回集合中指定位置的元素。 - public E remove(int index): 移除列表中指定位置的元素, 返回的是被移除的元素。 - public E set(int index, E element):用指定元素替换集合中指定位置的元素,返回值的更新前的元素。 3. LinkedList 集合1LinkedList是一个双向链表，查询慢，增删快，包含了大量操作首尾元素的方法。 123456789- public void addFirst(E e):将指定元素插入此列表的开头。- public void addLast(E e):将指定元素添加到此列表的结尾。- public E getFirst():返回此列表的第一个元素。- public E getLast():返回此列表的最后一个元素。- public E removeFirst():移除并返回此列表的第一个元素。- public E removeLast():移除并返回此列表的最后一个元素。- public E pop():从此列表所表示的堆栈处弹出一个元素。- public void push(E e):将元素推入此列表所表示的堆栈。- public boolean isEmpty()：如果列表不包含元素，则返回true。 4. HashSet 集合1是Set接口的一个实现类，存储的元素不可重复，并且元素都是无序的(即存取顺序不一致),没有索引,不能使用普通的for循环遍历。HashSet根据对象的哈希值来确定元素在集合中的存储位置，因此具有良好的存取和查找性能。 HashSet集合存储数据的结构（哈希表）： jdk1.8版本之前：哈希表 = 数组 + 链表 jdk1.8版本之后：哈希表 = 数组 +链表/红黑树； （当链表长度超过阈值（8）时，将链表转换为红黑树提高查询的速度） 5. LinkedHashSet 集合1HashSet是无序的，LinkedHashSet是有序的 特点：底层是一个哈希表（数组+链表/红黑树）+ 链表：多了一条链表(记录元素的存储顺序)，保证元素有序 6. 重写HashCode()方法 为什么需要重写HashCode()方法？ 如果两个对象需要判断是否内容相同，可以调用equals方法进行比较，但如果一个对象的字段过多，那就会偏频繁的进行字段的比较，非常的耗费性能。我们可以对Object类继承过来的hashCode方法进行覆盖重写，不让他生成地址值，而是根据我们对象的内容，生成hash值进行比较。因为比较hash值比equals方法容易得多。如果hash值相同，再调用equals方法进行内容比较。 哈希值：是一个十进制的整数，由系统随机给出(就是对象的地址值，是一个逻辑地址，是模拟出来得到地址，不是数据实际存储的物理地址) 重写HashCode()进行比较的步骤： 重写Object类中继承过来的HashCode()方法，自定义，根据对象的内容生成的哈希值 我们在进行集合元素存储的时候，比如向HashSet集合添加元素的时候，会先调用HashCode()方法，生成哈希值，不同对象生成的哈希值可能相同（虽然概率比较低） 哈希值不同，对象的内容肯定不同；哈希值相同，对象的内容有可能相同，有可能不同 比较哈希值，如果不同，直接存；如果相同，再调用equals方法进行内容比较 7. 可变参数12当方法的参数列表数据类型已经确定，但是参数的个数不确定，就可以使用可变参数格式：修饰符 返回值类型 方法名(参数类型... 形参名)&#123; &#125; 原理：可变参数底层就是一个数组，根据传递参数个数不同，会创建不同长度的数组，来存储这些参数，传递的参数个数，可以是0个（不传递），1,2,…多个 注意事项： 一个方法的参数列表，只能有一个可变参数 如果方法的参数有多个，那么可变参数必须写在参数列表的末尾 可变参数的终极写法：Object…obj 8. Collections 工具类1234567public static &lt;T&gt; boolean addAll(Collection&lt;? super T&gt; c, T... elements)：往集合中添加一些元素public static void shuffle(List&lt;?&gt; list)：打乱集合顺序public static void sort(List&lt;T&gt; list)（&lt;T extends Comparable&lt;? super T&gt;&gt;）：根据元素的自然顺序对指定列表按升序进行排序public static void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c)：根据指定比较器产生的顺序对指定列表进行排序 9. Comparable/Comparator 接口 Comparable和Comparator的区别： Comparable：自己(this)和别人(参数)比较,在源代码类中需要实现Comparable接口，重写比较的规则compareTo方法，耦合度太高 Comparator：在需要做排序的时候去选择的Comparator，相当于找一个第三方的裁判 排序规则：this - 参数：升序；参数 - this：降序 12345678//Comparable使用示例，在源码类中实现Comparable接口public class People implements Comparable&lt;People&gt; &#123; String name; int age; @Override public int compareTo(People o) &#123; return this.age - o.age; &#125;&#125; 1234567//Comparator使用示例，在Collections.sort方法中实现Comparator接口的匿名内部类 Collections.sort(list, new Comparator&lt;People&gt;() &#123; @Override public int compare(People o1, People o2) &#123; return o1.age - o2.age; &#125; &#125;); 1234567891011//Comparator如果想实现更多规则，示例如下：Collections.sort(list, new Comparator&lt;People&gt;() &#123; @Override public int compare(People o1, People o2) &#123; int result = o1.age - o2.age; if (o1.age - o2.age == 0) &#123; result = o1.name.charAt(0) - o2.name.charAt(0); &#125; return result; &#125; &#125;); 【Map、Debug】1. Map接口1Collection 中的集合称为单列集合， Map 中的集合称为双列集合。 特点： 是一个双列集合，一个元素包含两个值（一个key，一个value） Map集合中的元素，key和value的数据类型可以相同，也可以不同 Map集合中的元素，key是不允许重复的，value是可以重复的 Map集合中的元素，key和value是一一对应的 2. Map的常用子类 HashMap：存储数据采用的哈希表结构，元素的存取顺序不能保证一致。由于要保证键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 LinkedHashMap：存储数据采用的哈希表结构+链表结构。通过链表结构可以保证元素的存取顺序一致；通过哈希表结构可以保证的键的唯一、不重复，需要重写键的hashCode()方法、equals()方法。 HashTable：底层也是一个哈希表，是一个线程安全的集合，单线程集合，速度慢。不能存储空值，空键。Hashtable和Vector集合一样，在jdk1.2版本之后被更先进的集合取代了。 3. Map的常用方法1234567public V put(K key, V value) : 把指定的键与指定的值添加到Map集合中。//返回值V的说明：存储键值对的时候，key不重复，返回值V是null;key重复，会使用新的value替换map中重复的value，返回被替换的value值public V remove(Object key) : 把指定的键所对应的键值对元素在Map集合中删除，返回被删除元素的值。如果不存在指定的键，则返回空。public V get(Object key) 根据指定的键，在Map集合中获取对应的值。如果不存在指定的键，则返回空。public boolean containsKey(Object key): 集合中是否包含指定的键public Set&lt;K&gt; keySet() : 获取Map集合中所有的键，存储到Set集合中。public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 4. Entry键值对对象1一对key(键)+value(值)称做Map中的一个Entry(项)，Entry将键值对的对应关系封装成了对象，即键值对对象。 12345//Entry相关方法public K getKey() ：获取Entry对象中的键。public V getValue() ：获取Entry对象中的值。在Map集合中也提供了获取所有Entry对象的方法：public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() : 获取到Map集合中所有的键值对对象的集合(Set集合)。 5. Map的两种遍历方式1234567891011121314public static void main(String[] args) &#123; Map&lt;Integer, String&gt; map = new HashMap&lt;&gt;(); map.put(1, "one"); map.put(2, "two"); map.put(3, "thr"); //keySet遍历方式 for (Integer key : map.keySet()) &#123; System.out.println(key + " = " + map.get(key)); &#125; //entrySet遍历方式（更快） Set&lt;Map.Entry&lt;Integer, String&gt;&gt; entries = map.entrySet(); for (Map.Entry&lt;Integer, String&gt; entry : entries) &#123; System.out.println(entry.getKey + "=" + entry.getValue()); &#125; 6. JDK9对集合添加的优化1Java 9给List接口，Set接口和Map接口增加了一个静态的方法of，可以给集合一次性添加多个元素。 12345678910public class HelloJDK9 &#123; public static void main(String[] args) &#123; Set&lt;String&gt; str1=Set.of("a","b","c"); //str1.add("c");这里编译的时候不会错，但是执行的时候会报错，因为是不可变的集合 System.out.println(str1); Map&lt;String,Integer&gt; str2=Map.of("a",1,"b",2); System.out.println(str2); List&lt;String&gt; str3=List.of("a","b"); System.out.println(str3); &#125;&#125; 注意： of()方法只是Map，List，Set这三个接口的静态方法，其父类接口和子类实现并没有这类方法，比如HashSet，ArrayList等； of方法的返回值时一个不能改变的集合，集合不能再使用add,put方法添加元素，会抛出异常； Set接口和Map接口在调用of方法的时候，不能有重复的元素，否则会抛出异常 7. Debug追踪1使用IDEA的断点调试功能，可以让代码逐行执行，查看代码执行的过程，调试程序中出现的bug。 使用方式： 在行号的右边，鼠标左键单击，添加断点（哪里有bug添加到哪里） 右键选择Debug执行程序 程序就会停留在添加的第一个断点处 执行程序： F7：逐句执行程序（进入到方法中） F8：逐行执行程序（不进入方法中） Shift + F8：跳出方法 F9：跳到下一个断点，如果没有下一个断点，那么就结束程序 Ctrl + F2：退出Debug模式，停止程序 【异常、线程】1. 异常12在Java等面向对象的编程语言中，异常本身是一个类，产生异常就是创建异常对象并抛出了一个异常对象。Java处理异常的方式是中断处理。 异常指的并不是语法错误,语法错了,编译不通过,不会产生字节码文件,根本不能运行。 2. Throwable体系 Error：严重错误，无法通过处理的错误，只能事先避免，好比绝症。（内存不够用或和系统相关） Exception：异常，产生后程序员可以通过代码的方式纠正，使程序继续运行，好比感冒。 1234//Throwable常用方法：String getMessage()：返回此throwable的简短描述,一般用于提示给用户String toString()：返回此throwable的详细消息字符串void printStackTrace():JVM打印异常对象，默认此方法，信息是最全面的，用于开发和调试阶段 3. 异常的分类 编译时期异常：必须要处理。在编译时期就会检查，如果没有处理异常，则编译失败。 运行时期异常：可以不处理。在运行时期检查异常，在编译时期，运行异常不会被编译器报错。 4. 异常产生过程解析12345678910// 定义一个对给定的数组通过给定的索引获取元素的方法public static int getElement(int[] arr, int index) &#123; int element = arr[index]; return element;&#125;// 在主方法中调用getElement方法public static void main(String[] args) &#123; int[] arr = &#123;1,2,3&#125;; intnum = ArrayTools.getElement(arr, 4)&#125; 过程解析：getElement方法由于没有找到4索引，导致运行发生了异常，接下来JVM会： Jvm会根据异常产生的原因创建一个异常对象，这个对象包含了异常产生的（内容，原因，位置） new ArrayIndexOutOfBoundsException(“4”); 在getElement方法中，没有异常的处理逻辑（try…catch），那么JVM就会把异常对象抛出给方法的调用者main方法来处理这个异常 main方法接受后也没有处理异常的逻辑，继续把对象抛给main方法的调用者JVM处理 JVM收到这个异常对象，做了两件事： 把异常对象（内容、原因、位置）以红色的字体打印在控制台 JVM会终止当前正在执行的Java程序—&gt;中断处理 5. throw关键字123throw用在方法内，用来抛出一个异常对象，将这个异常对象传递到调用者处，并结束当前方法的执行。例如：throw new NullPointerException("要访问的arr数组不存在");throw new ArrayIndexOutOfBoundsException("该索引在数组中不存在，已超出范围"); throw将异常抛出，也就是将问题返回给该方法的调用者。对于调用者来说，该怎么处理呢？一种是进行捕获处理，另一种就是继续将问题声明出去，使用throws声明处理。 注意： throw关键字必须写在方法的内部 throw关键字后边new的对象必须是Exception或者Exception的子类对象 throw关键字抛出RuntimeException或者是其子类对象，我们可以不处理，默认交给JVM处理 throw关键字后边创建的是编译异常，我们就必须处理这个异常（try…catch） 6. Objects非空判断12345public static &lt;T&gt; T requireNonNull(T obj) :查看指定引用对象不是null//源码： if (obj == null) throw new NullPointerException() ; return obj; 7. throws声明异常12声明异常：如果方法内通过throw抛出编译时异常，而没有捕获处理，那么必须通过throws进行声明，将问题标识出来。抛出异常：关键字throws运用于方法声明之上,用于表示当前方法不处理异常,而是提醒该方法的调用者来处理异常。 123456789101112//代码演示：public static void main(String[] args) throws IOException &#123; read("a.txt");&#125;public static void read(String path)throws FileNotFoundException, IOException &#123; if (!path.equals("a.txt")) &#123; throw new FileNotFoundException("文件不存在"); &#125; if (!path.equals("b.txt")) &#123; throw new IOException(); &#125;&#125; 子父类的异常：子类抛出的异常在数量和继承关系上不能超出父类 8. try…catch捕获异常1234567捕获异常：Java中对异常有针对性的语句进行捕获，可以对出现的异常进行指定方式的处理。try&#123; 编写可能会出现异常的代码&#125;catch(异常类型 e)&#123; 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 1234567891011121314//代码演示public static void main(String[] args) &#123; try &#123; read("b.txt"); &#125; catch (FileNotFoundException e) &#123; System.out.println(e); &#125; System.out.println("over");&#125;public static void read(String path) throws FileNotFoundException &#123; if (!path.equals("a.txt")) &#123; throw new FileNotFoundException("文件不存在"); &#125;&#125; 9. finally代码块1因为异常会引发程序跳转，导致有些语句执行不到。但有一些特定的代码必须执行，将这些代码放在finally代码块中是一定会被执行的。 1234567891011//代码演示public static void main(String[] args) &#123; try &#123; read("a.txt"); &#125; catch (FileNotFoundException e) &#123; throw new RuntimeException(e); &#125; finally &#123; System.out.println("不管程序怎样，这里都将会被执行。"); &#125; System.out.println("over");&#125; 注意： finally不能单独使用。 如果finally有return语句,永远返回finally中的结果,避免该情况。 当只有在try或者catch中调用退出JVM的相关方法,此时finally才不会执行,否则finally永远会执行。 10. 多个异常使用捕获12345678910//一般多个异常一次捕获，多次处理。try&#123; 编写可能会出现异常的代码&#125;catch(异常类型A e)&#123; 当try中出现A类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125;catch(异常类型B e)&#123; 当try中出现B类型异常,就用该catch来捕获. 处理异常的代码 //记录日志/打印异常信息/继续抛出异常&#125; 注意：这种异常处理方式，要求多个catch中的异常不能相同，并且若catch中的多个异常之间有子父类异常的关系，那么子类异常要求在上面的catch处理，父类异常在下面的catch处理。 11. 自定义异常12345678910//格式：public class XXXException extends Exception/RuntimeException&#123; //空参数的构造方法 public XXXException() &#123; &#125; //添加一个带异常信息的构造方法 public XXXException(String message) &#123; super(message); &#125;&#125; 注意： 自定义异常类一般都是以Exception结尾，说明该类是一个异常类 所有的异常类都会有一个带异常信息的构造方法，方法内部会调用父类带异常信息的构造方法 自定义异常类，必须继承Exception/RuntimeException 继承RuntimeException：那么就是一个运行期异常，无需处理，交给虚拟机 继承Exception：那么就是一个编译期异常，如果方法内部抛出了编译期异常，就必须处理这个异常，要么throws，要么try…catch 12. 并发与并行12并发：指两个或多个事件在同一个时间段内发生（交替执行）。并行：指两个或多个事件在同一时刻发生（同时执行）。 13. 线程与进程123进程：一个应用程序可以同时运行多个进程，每个进程都有一个独立的内存空间，是系统运行程序的基本单位。线程：是CPU和任务之间的执行通道，是任务的执行单元，一个进程中可以有多个线程。一个应用程序可以有多个进程，一个进程可以有多个线程。 线程调度： 分时调度：所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。 抢占式调度：优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，Java使用的为抢占式调度。 【线程、同步】1. Thread类12345//构造方法：public Thread() :分配一个新的线程对象。public Thread(String name) :分配一个指定名字的新的线程对象。public Thread(Runnable target) :分配一个带有指定目标新的线程对象。public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。 123456//常用方法：public String getName() :获取当前线程名称。public void start() :导致此线程开始执行; Java虚拟机调用此线程的run方法。public void run() :此线程要执行的任务在此处定义代码。public static void sleep(long millis) :使当前正在执行的线程以指定的毫秒数暂停（暂时停止执行）。public static Thread currentThread() :返回对当前正在执行的线程对象的引用。 2. 创建线程-继承Thread类1创建多线程的第一种方式：创建Thread类的子类 实现步骤： 创建一个Thread类的子类，并重写Thread类中的run方法，设置线程任务 创建Thread类的子类对象 调用线程对象的start()方法，开启新的线程，执行run方法 1234567891011121314//代码演示//创建Thread类的子类public class MyThread extends Thread &#123; @Override public void run() &#123; for (int i = 0; i &lt; 10; i++) &#123; System.out.println(getName()+"：正在执行！"+i); &#125;&#125;//测试类public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start();&#125; 3. 创建线程-Runnable接口1创建多线程的第二种方式：Thread构造器实现Runnable接口 实现步骤： 创建一个Runnable接口的实现类 在实现类中重写Runnable接口的run方法，设置线程任务 创建一个Runnable接口的实现类对象 创建Thread类对象，构造方法中传递Runnable接口的实现类对象 调用Thread类中的start方法，开启新的线程执行run方法 12345678910111213141516//代码演示//创建Runnable接口的实现类public class MyRunnable implements Runnable&#123; @Override public void run() &#123; for (int i = 0; i &lt; 20; i++) &#123; System.out.println(Thread.currentThread().getName()+" "+i); &#125; &#125;&#125;//测试类public static void main(String[] args) &#123; MyRunnable mr = new MyRunnable(); Thread t = new Thread(mr); t.start();&#125;//也可以使用匿名内部类方式实现线程的创建 4. Runnable接口具有的优势 适合多个相同的程序代码的线程去共享同一个资源。 可以避免java中的单继承的局限性。 增加程序的健壮性，实现解耦操作，代码可以被多个线程共享，代码和线程独立。 线程池只能放入实现Runable或Callable类线程，不能直接放入继承Thread的类。 5. 线程安全1当多个线程对象访问同一个资源，并且多个线程中对资源有写的操作，就容易产生线程安全问题。 6. 同步代码块1synchronized 关键字可以用于方法中的某个区块中，表示对这个区块的资源实行互斥访问。 123456789101112//代码演示public class Ticket implements Runnable&#123; private int ticket = 100; Object lock = new Object(); @Override public void run() &#123; while(true)&#123; synchronized (lock) &#123; //对卖票的操作进行锁 if(ticket&gt;0)&#123; String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); &#125; 同步锁：对象的同步锁只是一个概念,可以想象为在对象上标记了一个锁 锁对象可以是任意类型。 多个线程对象要使用同一把锁。 在任何时候，最多允许一个线程拥有同步锁，谁拿到锁就进入代码块，其他的线程只能在外等着。 7. 同步方法1使用synchronized修饰的方法，就叫做同步方法，保证一个线程执行该方法的时候，其他线程只能在方法外等着。 12345678910111213//代码演示public class Ticket implements Runnable&#123; private int ticket = 100; @Override public void run() &#123; while(true)&#123; sellTicket(); &#125; &#125; public synchronized void sellTicket()&#123; if(ticket&gt;0)&#123; String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); 同步锁是谁? 对于非static方法，同步锁就是this。 对于static方法，我们使用当前方法所在类的字节码对象(类名.class)。 8. Lock锁1java.util.concurrent.locks.Lock 机制提供了比synchronized代码块和synchronized方法更广泛的锁定操作,同步代码块/同步方法具有的功能Lock都有,除此之外Lock更强大,更体现面向对象。 12345678910111213//代码演示public class Ticket implements Runnable&#123; private int ticket = 100; Lock lock = new ReentrantLock(); //1.创建锁对象 @Override public void run() &#123; while(true)&#123; lock.lock(); //2.加同步锁 if(ticket&gt;0)&#123; String name = Thread.currentThread().getName(); System.out.println(name+"正在卖:"+ticket‐‐); &#125; lock.unlock(); //3.释放同步锁 9. 六种线程状态 线程状态 说明 新建状态(New) 线程刚被创建，但是还没调用start方法启动。 运行状态(Runnable) 线程可以在java虚拟机中运行的状态。 阻塞状态(Blockd) 当一个线程试图获取一个对象锁，而该对象锁被其他的线程持有，则该线程进入Blocked状态。 计时等待状态(Timed waiting) 一个线程在等待另一个线程调用notify或者notifyAll方法（唤醒）动作时，该线程进入Waiting状态，进入这个状态后是不能自动唤醒的。 无限等待状态(Waiting) 同waiting状态，这一状态将一直保持到超时期满或者接收到唤醒通知。 死亡状态(Terminated) 因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。 10. 等待与唤醒方法12345678进入到TimeWaiting(计时等待)有两种方式： 1. sleep(long m)方法,在毫秒值结束之后,线程睡醒进入到Runnable/Blocked状态。sleep方法使用后线程失 去CPU执行权，但仍然拥有锁对象。 2. wait(long m)方法,wait方法如果在毫秒值结束之后,还没有被notify唤醒,就会自动醒来,线程睡醒进入到 Runnable/Blocked状态。wait方法同时释放锁对象和cpu执行权。唤醒的两种方式: 1. void notify() 唤醒在此对象监视器上等待的单个线程。 2. void notifyAll() 唤醒在此对象监视器上等待的所有线程。 wait和notify方法是来源于Object类，不是Thread类，等待和唤醒都是Object的方法 【线程池、Lambda表达式】1. 等待唤醒机制1一个线程进行了规定操作后，通过wait()方法进入等待状态，等待其他线程执行完他们的指定代码过后再通过notify()方法将其唤醒，是线程间的一种协作机制。 注意： wait方法与notify方法必须要由同一个锁对象调用。 wait方法与notify方法必须要在同步代码块或者是同步函数中使用，因为要通过锁对象调用这2个方法。 被唤醒的线程不一定能立即恢复执行，需要再次获取锁后才能在从 wait() 方法之后的地方恢复执行。 2. 线程池1容纳多个线程的容器，其中的线程可以反复使用，省去了频繁创建线程对象的操作，无需反复创建线程而消耗过多资源。 线程池的好处： 降低资源消耗。减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。 提高响应速度。当任务到达时，任务可以不需要的等到线程创建就能立即执行。 提高线程的可管理性。可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。 线程池使用步骤： 用线程池的工厂类Executors里边提供的静态方法newFixedThreadPool生产一个指定线程数量的线程池 创建一个类，实现Runnable接口，重写run方法，设置线程任务 调用ExecutorService中的方法submit，传递线程任务(实现类)，开启线程，执行run方法 调用ExecutorService中的方法shutdown销毁线程池(不建议执行) 123456//代码展示public static void main(String[] args) &#123; ExecutorService es = Executors.newFixedThreadPool(3); es.submit(() -&gt; System.out.println(Thread.currentThread().getName())); es.shutdown();&#125; 3. Lambda表达式1Lambda表达式的标准格式为：(参数类型 参数名称) ‐&gt; &#123; 代码语句 &#125; 使用前提： 必须有函数式接口——只包含一个抽象方法的接口 必须有上下文引用（必须有接口作为数据类型接收） 省略格式（可推导,可省略）： 小括号内参数的类型可以省略； 如果小括号内有且仅有一个参，则小括号可以省略； 如果大括号内有且仅有一个语句，则无论是否有返回值，都可以省略大括号、return关键字及语句分号。 1234567//代码演示public static void main(String[] args) &#123; //重写Runnable接口 new Thread(() -&gt; System.out.println("创建并执行线程")).start(); //重写Comparator接口，降序排序 Collections.sort(list,(o1, o2) -&gt; o2 - o1); &#125; 【File类、递归】1. File类12File类是文件和目录路径名的抽象表示，主要用于文件和目录的创建、查找和删除等操作。File类的实例是不可变的，一旦创建，File对象表示的抽象路径名将永不改变 构造方法123public File(String pathname) ：通过将给定的路径名字符串创建新的 File实例。public File(String parent, String child) ：父路径名字符串+子路径名字符串创建新的File实例。public File(File parent, String child) ：从父File实例路径名+子路径名字符串创建新的File实例。 获取的方法12345public String getAbsolutePath() ：返回此File的绝对路径名字符串。//File对象的toString方法调用的就是getPath()方法public String getPath() ：将此File转换为路径名字符串。public String getName() ：返回由此File表示的文件或目录的名称。public long length() ：返回由此File表示的文件的长度。 判断的方法123public boolean exists() ：此File表示的文件或目录是否实际存在。public boolean isDirectory() ：此File表示的是否为目录。public boolean isFile() ：此File表示的是否为文件。 创建删除的方法1234public boolean createNewFile() ：当且仅当具有该名称的文件尚不存在时，创建一个新的空文件。public boolean delete() ：删除由此File表示的文件或目录，目录项下有内容的话无法删除。public boolean mkdir() ：创建由此File表示的目录。public boolean mkdirs() ：创建由此File表示的目录，包括任何必需但不存在的父目录。 遍历的方法12public String[] list() ：返回一个String数组，表示该File目录中的所有子文件或目录。public File[] listFiles() ：返回一个File数组，表示该File目录中的所有的子文件或目录。 调用listFiles方法的File对象，表示的必须是实际存在的目录，否则返回null，无法进行遍历。 2. 绝对路径和相对路径12绝对路径：从盘符开始的路径，这是一个完整的路径。相对路径：相对于项目目录的路径，这是一个便捷的路径，开发中经常使用。 File.pathSeparator：获取当前系统路径分隔符；（Windows用” ; “ Linux用” : “）File.separator：获取当前系统文件名称分隔符；（Windows用”反斜杠\“ Linux用”正斜杠/“） 3. 递归1递归：指在当前方法内调用自己的这种现象。 注意事项： 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。(StackOverflowError) 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。(StackOverflowError) 构造方法,禁止递归。 1234567891011121314//代码演示 #暴力删除#public static void deleteAll(File f) &#123; if (f.exists()) &#123; if (f.isDirectory()) &#123; for (File file : f.listFiles()) &#123; if (file.isFile()) &#123; file.delete(); &#125; else &#123; deleteAll(file); &#125;&#125;&#125; f.delete(); &#125;else&#123; System.out.println("该路径不是有效路径"); &#125;&#125; 123456789101112131415//代码演示 #阶乘#public static double factorial(int n) &#123; if (n == 1) &#123; return 1; &#125; return n * factorial(n - 1);&#125;//代码演示 #内存容量测试#public static void main(String[] args) &#123; b(1); &#125;public static void b(int i)&#123; System.out.println(i); b(++i); &#125; 4. 文件过滤器1234567public File[] listFiles():返回指定目录中的子目录和文件。public File[] listFiles(FileFilter filter):返回指定目录中符合自定义规则的子目录和文件。FileFilter接口中抽象方法： boolean accept(File pathname) 测试指定格式路径名是否包含在某个路径名列表中。public File[] listFiles(FilenameFilter filter):返回指定目录中指定文件。FilenameFilter接口中抽象方法： boolean accept(File dir, String name) 测试指定文件是否应该包含在某一文件列表中。 12345678910//定义一个方法，输出文件夹里的所有的java文件public static void showJava(File f) &#123; File[] files = f.listFiles(pathname-&gt;pathname.isDirectory()|| pathname.getName().toLowerCase().endsWith(".java")); for (File file : files) &#123; if (file.isDirectory()) &#123; showJava(file); &#125;else&#123; System.out.println(file.getAbsolutePath()); &#125;&#125;&#125; 【字节流、字符流】1. IO流12输入流 ：把数据从其他设备上读取到【内存中】的流。输出流 ：把数据从【内存中】写出到其他设备上的流。 顶级父类们 输入流 输出流 字节流 字节输入流【InputStream】 字节输出流【OutputStream】 字符流 字符输入流【Reader】 字符输出流【Writer】 2. 字节输出流【OutputStream】1java.io.OutputStream 抽象类是表示字节输出流的所有类的超类，将指定的字节信息写出到目的地。 12345//OutputStream 基本方法：public void close() ：关闭此输出流并释放与此流相关联的任何系统资源。public void flush() ：刷新此输出流并强制任何缓冲的输出字节被写出。public void write(byte[] b) ：将 b.length字节从指定的字节数组写入此输出流。public void write(byte[] b, int off, int len) ：从指定的字节数组写入len字节，从偏移量off开始输出到此输出流。 FileOutputStream123//构造方法：true 表示追加数据， false 表示清空原有数据public FileOutputStream(String name, boolean append) ： 创建文件输出流以指定的名称写入文件。public FileOutputStream(File file, boolean append) ：创建文件输出流以写入由指定的File对象表示的文件。 3. 字节输入流【InputStream】1java.io.InputStream 抽象类是表示字节输入流的所有类的超类，可以读取字节信息到内存中。 1234//InputStream 基本方法：public void close() ：关闭此输入流并释放与此流相关联的任何系统资源。public abstract int read() ： 从输入流读取数据的下一个字节。public int read(byte[] b) ： 从输入流中读取一些字节数，并将它们存储到字节数组b中，返回读取的字节数。 FileInputStream123//构造方法FileInputStream (File file)：通过打开与实际文件的连接来创建一个FileInputStream，该文件由文件系统中的File对象file命名。FileInputStream (String name)：通过打开与实际文件的连接来创建一个 FileInputStream，该文件由文件系统中的路径名name命名。 12345678910111213141516//文件复制代码演示public static void main(String[] args) throws IOException &#123; //创建输入输出流对象 FileInputStream fis = new FileInputStream("src.jpg"); FileOutputStream fos = new FileOutputStream("des.jpg"); //创建容器 byte[] bys = new byte[1024]; int len; //读取源文件 while ((len = fis.read(bys)) != -1) &#123; //输出文件 fos.write(bys, 0, len); &#125; //释放资源 fos.close(); fis.close(); 4. 字符输入流【Reader】1java.io.Reader抽象类是表示用于读取字符流的所有类的超类，可以读取字符信息到内存中。 1234//Reader 基本方法：public void close() ：关闭此流并释放与此流相关联的任何系统资源。public int read() ： 从输入流读取一个字符。public int read(char[] cbuf) ： 从输入流中读取一些字符，并将它们存储到字符数组cbuf中 。 FileReader123//构造方法FileReader(File file)：创建一个新的 FileReader，给定要读取的File对象。FileReader(String fileName)：创建一个新的 FileReader，给定要读取的文件的名称。 123456789//代码演示public static void main(String[] args) throws IOException &#123; FileReader fr = new FileReader("a.txt"); char[] chars = new char[1024]; int len; while ((len = fr.read(chars)) != -1) &#123; System.out.println(new String(chars,0,len)); &#125;&#125; 5. 字符输出流【Writer】1java.io.Writer 抽象类是表示用于写出字符流的所有类的超类，将指定的字符信息写出到目的地。 12345678//Writer 基本方法void flush() 刷新该流的缓冲。void close() 关闭此流，但会自动先刷新它。void write(int c) 写入单个字符。void write(char[] cbuf) 写入字符数组。void write(char[] cbuf, int off, int len) 写入字符数组的某一部分,off数组的开始索引,len字符个数。void write(String str) 写入字符串。void write(String str, int off, int len) 写入字符串的某一部分,off字符串的开始索引,len字符个数。 FileWriter123//构造方法FileWriter(File file)：创建一个新的 FileWriter，给定要读取的File对象。FileWriter(String fileName)：创建一个新的 FileWriter，给定要读取的文件的名称。 注意： 使用FileWriter中的方法write，是把数据写入到内存缓冲区中，需要刷新缓冲区，才能将数据保存到文件中。 flush ：刷新缓冲区，流对象可以继续使用。 close :先刷新缓冲区，然后通知系统释放资源。流对象不可以再被使用了。 6. IO异常的处理JDK7前处理123456789101112131415//代码演示public static void main(String[] args) &#123; FileWriter fw = null; try &#123; fw = new FileWriter("fw.txt"); fw.write("黑马程序员"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fw != null) &#123; fw.close(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125;&#125; JDK7的处理123456//JDK7优化后用()包裹流对象语句，确保每个流对象在结束使用后关闭public static void main(String[] args) &#123; try ( FileWriter fw = new FileWriter("fw.txt"); ) &#123; fw.write("黑马程序员"); &#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125; JDK9的改进1234567//JDK9中使用引入对象的方式，同样可以确保每个流对象在结束使用后自动关闭public static void main(String[] args) throws IOException &#123; FileWriter fw = new FileWriter("fw.txt"); try (fw) &#123; fw.write("黑马程序员"); &#125; catch (IOException e) &#123; e.printStackTrace();&#125;&#125; 7. Properties类12java.util.Properties继承于Hashtable，使用键值结构存储数据，每个键及其对应值都是一个字符串。可以方便地在双列集合和数据文件之间转换。 123456789//构造方法public Properties() :创建一个空的属性列表。//存储方法public Object setProperty(String key, String value)：添加一个键值对。public String getProperty(String key)：通过键获取对应的值。public Set&lt;String&gt; stringPropertyNames()：获取所有键名称的集合。//流相关方法public void load(InputStream in)：从字节输入流中读取键值对,生成Properties集合。public void store(OutputStream out,String comments)：从Properties集合中获取键值对，输出到字节输出流的文件中。 12345678910//代码演示public static void main(String[] args) throws FileNotFoundException &#123; Properties pro = new Properties(); //创建Properties对象 pro.load(new FileInputStream("read.txt")); //从read.txt中读取数据 pro.setProperty("one", "111"); //往对象中添加数据 Set&lt;String&gt; strings = pro.stringPropertyNames(); //获取对象所有键名称的集合 for (String key : strings ) &#123; //遍历集合并打印 System.out.println(key+" ‐‐ "+pro.getProperty(key)); &#125; pro.store(new FileOutputStream("write.txt"),"Saving"); //将对象的信息输出到文件中 【缓冲流、转换流、序列化流】1. 缓冲流字节缓冲流12public BufferedInputStream(InputStream in) ：创建一个 新的缓冲输入流。public BufferedOutputStream(OutputStream out) ： 创建一个新的缓冲输出流。 字符缓冲流12345public BufferedReader(Reader in) ：创建一个 新的缓冲输入流。public BufferedWriter(Writer out) ： 创建一个新的缓冲输出流。//特有方法BufferedReader： public String readLine() : 读一行文字。BufferedWriter： public void newLine() : 写一行行分隔符,由系统属性定义符号。 12345678910111213//通过缓冲流复制文件，代码演示：public static void main(String[] args) throws IOException&#123; BufferedOutputStream bos = new BufferedOutputStream(new FileOutputStream("des.jpg")); BufferedInputStream bis = new BufferedInputStream(new FileInputStream("src.jpg")); byte[] bys = new byte[1024]; int len; while ((len = bis.read(bys)) != -1) &#123; bos.write(bys, 0, len); &#125; bos.close(); bis.close(); &#125; 2. 字符集1也叫编码表。是一个系统支持的所有字符的集合，包括各国家文字、标点符号、图形符号、数字等。 ASCII字符集 ：基本的ASCII字符集，使用7位（bits）表示一个字符，共128字符。ASCII的扩展字符集使用8位（bits）表示一个字符，共256字符，方便支持欧洲常用字符。 GBK：最常用的中文码表。是在GB2312标准基础上的扩展规范，使用了双字节编码方案，共收录了21003个汉字，完全兼容GB2312标准，同时支持繁体汉字以及日韩汉字等。 Unicode字符集 ：为表达任意语言的任意字符而设计，是业界的一种标准，也称为统一码、标准万国码，其中最为常用的是UTF-8编码： 128个US-ASCII字符，只需一个字节编码。 拉丁文等字符，需要二个字节编码。 大部分常用字（含中文），使用三个字节编码。 其他极少使用的Unicode辅助字符，使用四字节编码。 3. 转换流InputStreamReader类12345转换流java.io.InputStreamReader ，是Reader的子类，是从字节流到字符流的桥梁。它读取字节，并使用指定的字符集将其解码为字符。它的字符集可以由名称指定，也可以接受平台的默认字符集。//构造方法InputStreamReader(InputStream in) : 创建一个使用默认字符集的字符流。InputStreamReader(InputStream in, String charsetName) : 创建一个指定字符集的字符流。 OutputStreamWriter类12345转换流java.io.OutputStreamWriter ，是Writer的子类，是从字符流到字节流的桥梁。使用指定的字符集将字符编码为字节。它的字符集可以由名称指定，也可以接受平台的默认字符集。//构造方法OutputStreamWriter(OutputStream in) : 创建一个使用默认字符集的字符流。OutputStreamWriter(OutputStream in, String charsetName) : 创建一个指定字符集的字符流。 12345678910111213//将GBK编码的文件转换为UTF-8编码，代码演示：public static void main(String[] args) throws IOException&#123; OutputStreamWriter osw = new OutputStreamWriter(new FileOutputStream("U8code.txt")); InputStreamReader isr = new InputStreamReader(new FileInputStream("GBKcode.txt"), "GBK"); int len; char[] chars = new char[1024]; while ((len = isr.read(chars)) != -1) &#123; osw.write(chars,0,len); &#125; osw.close(); isr.close();&#125; 4. 序列化1Java提供了一种对象序列化的机制，使【内存中对象的数据】与【硬盘中文件里的数据】可以相互转化。字节序列写出到文件之后，相当于文件中持久保存了一个对象的信息。字节序列还可以从文件中读取回来，重构对象，对它进行反序列化。 ObjectOutputStream类12345java.io.ObjectOutputStream 类，将Java对象的原始数据类型写出到文件,实现对象的持久存储。//构造方法public ObjectOutputStream(OutputStream out)：创建一个指定OutputStream的序列化流对象。//写出方法public final void writeObject (Object obj) : 将指定的对象写出。 序列化操作注意事项： 要实现序列化的类必须实现java.io.Serializable接口，否则会抛出NotSerializableException异常。 被瞬态transient或静态static修饰的属性不会被序列化。 ObjectInputStream类12345ObjectInputStream反序列化流，将之前使用ObjectOutputStream序列化的原始数据恢复为对象。//构造方法public ObjectInputStream(InputStream in) ： 创建一个指定InputStream的ObjectInputStream。//读取方法public final Object readObject () : 读取一个对象。 serialVersionUID序列版本号：Serializable 接口给需要序列化的类，提供了一个序列版本号，目的在于验证序列化的对象和对应类是否版本匹配。如果对类进行和修改，那么其序列标本号也会发生修改。可通过在类中写死序列版本号，使修改后的类依然能够匹配序列化的对象。 1234567891011121314151617181920212223//序列化代码演示//定义学生类public class Student implements Serializable&#123; private String name; private int age; private static final long serialVersionUID = 8206478034432139083L; public Student(String name, int age) &#123; this.name = name; this.age = age; &#125;//测试类public static void main(String[] args) throws IOException, ClassNotFoundException &#123; //序列化 ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream("Student.txt")); oos.writeObject(new Student("Eric", 20)); oos.close(); //反序列化 ObjectInputStream ois = new ObjectInputStream(new FileInputStream("Student.txt")); Student stu = (Student)ois.readObject(); System.out.println(stu); //Student&#123;name='Eric', age=20&#125; ois.close();&#125; 5. 打印流1java.io.PrintStream 类，该类能够方便地打印各种数据类型的值，是一种便捷的输出方式。 PrintStream类1234567//构造方法public PrintStream(String fileName) ： 使用指定的文件名创建一个新的打印流。//改变打印流向public static void main(String[] args) throws IOException &#123; PrintStream ps = new PrintStream("ps.txt"); System.setOut(ps); System.out.println("Hello,World");&#125; //在ps.txt中输出Hello,World 【网络编程】1. 软件结构 C/S结构 ：全称为Client/Server结构，是指客户端和服务器结构。常见程序有ＱＱ、迅雷等软件。 B/S结构 ：全称为Browser/Server结构，是指浏览器和服务器结构。常见浏览器有谷歌、火狐等。 2. 网络通信协议1传输控制协议/因特网互联协议( Transmission Control Protocol/Internet Protocol)，是Internet最基本、最广泛的协议。它定义了计算机如何连入因特网，以及数据如何在它们之间传输的标准。它的内部包含一系列的用于处理数据通信的协议，并采用了4层的分层模型，每一层都呼叫它的下一层所提供的协议来完成自己的需求。 分层 协议 应用层 HTTP/FTP/TFTP/SMTP/SNMP/DNS 传输层 TCP/UDP 网络层 ICMP/IGMP/IP/ARP/RARP 数据链路层+物理层 由底层网络定义的协议 3. TCP协议12TCP：传输控制协议 (Transmission Control Protocol)。TCP协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数据，它提供了两台计算机之间可靠无差错的数据传输。 三次握手建立连接：在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠。 客户端向服务器端发出连接请求，等待服务器确认。 服务器端向客户端回送一个响应，通知客户端收到了连接请求。 客户端再次向服务器端发送确认信息，确认连接。 四次挥手断开连接：客户端与服务器之间的四次交互后断开，保证了数据的完整性。 客户端先向服务器发送断开请求，问询服务器是否可以断开（说明客户端没有数据要传输了） 服务器向客户端发送数据，需要客户端确认（说明服务器没有数据要传输了） 客户端再次问询服务器是否可以断开连接 断开连接 4. UDP协议1UDP：用户数据报协议(User Datagram Protocol)。UDP协议是一个面向无连接的协议。传输数据时，不需要建立连接，不管对方端服务是否启动，直接将数据、数据源和目的地都封装在数据包中，直接发送。每个数据包的大小限制在64k以内。它是不可靠协议，因为无连接，所以传输速度快，但是容易丢失数据。日常应用中,例如视频会议、QQ聊天等。 5. IP地址12IP地址：指互联网协议地址（Internet Protocol Address），俗称IP。IP地址用来给一个网络中的计算机设备做唯一的编号。假如我们把“个人电脑”比作“一台电话”的话，那么“IP地址”就相当于“电话号码”。 IP地址分类： IPv4：是一个32位的二进制数，通常被分为4个字节，表示成a.b.c.d 的形式，例如192.168.65.100，最多可以表示42亿个。有资料显示，全球IPv4地址在2011年2月分配完毕。 IPv6：采用128位地址长度，每16个字节一组，分成8组十六进制数，解决了网络地址资源数量不够的问题。表示成：ABCD:EF01:2345:6789:ABCD:EF01:2345:6789 。 查看本机IP地址，在控制台输入：ipconfig 检查网络是否连通，在控制台输入：ping 空格 IP地址 本机IP地址：127.0.0.1 6. 端口号1网络的通信，本质上是两个进程（应用程序）的通信，端口号可以标识设备中的不同进程（应用程序）。 用两个字节表示的整数，它的取值范围是0~65535。 0~1023之间的端口号用于一些知名的网络服务和应用，普通的应用程序需要使用1024以上的端口号。 常用端口号： 网络端口 https:443 http:80 数据库 mysql:3306 oracle:1521 Tomcat服务器:8080 【协议+ IP地址+ 端口号】 三元组合可以标识网络中的进程，进程间的通信可以利用这个标识与其它进程交互。 7. Socket类1java.net.Socket类表示客户端。创建Socket对象向服务器发出连接请求，服务器响应请求，两者建立连接开始通信。 1234567//构造方法public Socket(String host, int port) :创建套接字对象并将其连接到指定主机上的指定端口号。如果指定的host是null，则相当于指定地址为回送地址。//成员方法public InputStream getInputStream()：返回此套接字的输入流。public OutputStream getOutputStream()：返回此套接字的输出流。public void close()：关闭此套接字,关闭socket也将关闭相关的InputStream和OutputStream 。public void shutdownOutput()：禁用此套接字的输出流,任何先前写出的数据将被发送，随后终止输出流。 8. ServerSocket类1java.net.ServerSocket类表示服务端。创建ServerSocket 对象，相当于开启一个服务，并等待客户端的连接。 1234//构造方法public ServerSocket(int port)：使用该构造方法在创建ServerSocket对象时，就可以将其绑定到一个指定的端口号上，参数port就是端口号。//成员方法public Socket accept()：侦听并接受连接，返回一个新的Socket对象，用于和客户端实现通信。 1234567891011121314151617181920212223242526//客户端代码演示public class TCPClient &#123; public static void main(String[] args) throws IOException &#123; Socket socket = new Socket("127.0.0.1", 8888); OutputStream os = socket.getOutputStream(); os.write("你好服务器".getBytes()); InputStream is = socket.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); System.out.println(new String(bys,0,len)); System.out.println(socket); socket.close();&#125;&#125;//服务端代码演示public class TCPServer &#123; public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); InputStream is = socket.getInputStream(); byte[] bys = new byte[1024]; int len = is.read(bys); System.out.println(new String(bys, 0, len)); OutputStream os = socket.getOutputStream(); os.write("收到谢谢".getBytes()); System.out.println(server); socket.close(); server.close();&#125;&#125; 9. 文件上传优化分析1234567891011121314151617181920212223242526272829303132//文件上传案例服务端代码演示public static void main(String[] args) throws IOException &#123; ServerSocket server = new ServerSocket(8888); Socket socket = server.accept(); ② FileOutputStream fos = new FileOutputStream("copy.jpg"); ① InputStream is = socket.getInputStream(); int len; byte[] bys = new byte[1024]; while ((len = is.read(bys)) != -1) &#123; fos.write(bys, 0, len); &#125; socket.getOutputStream().write("上传成功".getBytes()); fos.close(); socket.close(); server.close();//文件上传案例客服端代码演示public static void main(String[] args)throws IOException &#123; FileInputStream fis = new FileInputStream("src.jpg"); Socket socket = new Socket("127.0.0.1", 8888); OutputStream os = socket.getOutputStream(); int len; byte[] bys = new byte[1024]; while ((len = fis.read(bys)) != -1) &#123; os.write(bys, 0, len); &#125; socket.shutdownOutput(); //避免阻塞问题 InputStream is = socket.getInputStream(); while ((len = is.read(bys)) != -1) &#123; System.out.println(new String(bys, 0, len)); &#125; socket.close(); fis.close(); ① 文件名称写死的问题12服务端，保存文件的名称如果写死，那么最终导致服务器硬盘，只会保留一个文件，建议使用系统时间优化，保证文件名称唯一，代码如下：FileOutputStream fis = new FileOutputStream(System.currentTimeMillis()+".jpg") // 文件名称 ② 循环接收的问题12345服务端，指保存一个文件就关闭了，之后的用户无法再上传，这是不符合实际的，使用循环改进，可以不断的接收不同用户的文件，代码如下：while（true）&#123; Socket socket = server.accept(); ......&#125; ③ 效率问题12345678910服务端，在接收大文件时，可能耗费几秒钟的时间，此时不能接收其他用户上传，所以，使用多线程技术优化，代码如下：while（true）&#123; Socket socket = serverSocket.accept(); // socket 交给子线程处理. new Thread(() ‐&gt; &#123; ...... InputStream is = socket.getInputStream(); ...... &#125;).start();&#125; 【函数式接口】1. 函数式接口1有且仅有一个抽象方法的接口。 @FunctionalInterface注解：使用该注解来定义接口，编译器将会强制检查该接口是否确实有且仅有一个抽象方法，否则将会报错。 2. Lambda的延迟执行12345678910111213141516171819202122232425//无论level是多少，都会先把字符串拼接并传入方法内。如果level不符合要求，拼接操作就白做了public static void main(String[] args) &#123; String msgA = "Hello"; String msgB = "World"; String msgC = "Java"; log(1, msgA + msgB + msgC);&#125;private static void log(int level, String msg) &#123; if (level == 1) &#123; System.out.println(msg);&#125;&#125;//使用Lambda的延迟执行进行优化，只有满足要求的时候才会进行三个字符串的拼接；否则三个字符串将不会进行拼接。public static void main(String[] args) &#123; String msgA = "Hello"; String msgB = "World"; String msgC = "Java"; log(1, () ‐&gt; msgA + msgB + msgC );&#125;private static void log(int level, MessageBuilder builder) &#123; if (level == 1) &#123; System.out.println(builder.buildMessage());&#125;&#125;@FunctionalInterfacepublic interface MessageBuilder &#123; String buildMessage();&#125; 3. Supplier接口12java.util.function.Supplier&lt;T&gt;接口用来获取一个泛型参数指定类型的对象数据。仅包含一个无参的抽象方法：T get() 。 1234567//代码演示public static void main(String[] args) &#123; String s = getString(() -&gt; "Eric" + "loset"); System.out.println(s);&#125;public static String getString(Supplier&lt;String&gt; sup) &#123; return sup.get();&#125; 4. Consumer接口123456java.util.function.Consumer&lt;T&gt; 接口与Supplier接口相反，是消费一个数据，其数据类型由泛型决定。包含一个有参的抽象方法void accept(T t)，一个默认方法andThen(),可以组合多个步骤。//andThen方法源码：default Consumer&lt;T&gt; andThen(Consumer&lt;? super T&gt; after) &#123; Objects.requireNonNull(after); return (T t) ‐&gt; &#123; accept(t); after.accept(t); &#125; 123456789//代码演示public static void main(String[] args) &#123; method("方法", (t) -&gt; System.out.print(t + "1"), (t) -&gt; System.out.print(t + "2"), (t) -&gt; System.out.print(t + "3"));&#125; //方法1方法2方法3public static void method(String name, Consumer&lt;String&gt; con1, Consumer&lt;String&gt; con2, Consumer&lt;String&gt; con3)&#123; con1.andThen(con2).andThen(con3).accept(name);&#125; 5. Predicate接口123java.util.function.Predicate&lt;T&gt;接口返回一个boolean值结果，用于对某种类型的数据进行判断。接口中包含一个抽象方法： boolean test(T t)，用于条件判断的场景。接口中包含三个默认方法： and(),or(),negate() 1234567891011//代码演示public static void main(String[] args) &#123; String s = "abcdefg"; boolean b = checkString(s, (str) -&gt; str.length() &gt; 20, (str) -&gt; str.contains("bc")); System.out.println(b);&#125; //truepublic static boolean checkString(String s, Predicate&lt;String&gt; pre1, Predicate&lt;String&gt; pre2) &#123; return pre1.or(pre2).test(s);&#125; 6. Function接口12java.util.function.Function&lt;T,R&gt; 接口用来根据一个类型的数据得到另一个类型的数据。包含一个有参的抽象方法 R apply(T t)，一个默认方法andThen()，可以组合多个步骤。 12345678//代码演示private static void method(String str, Function&lt;String, Integer&gt; function) &#123; int num = function.apply(str); System.out.println(num + 20); &#125;public static void main(String[] args) &#123; method("100",s-&gt;Integer.parseInt(s)); &#125; 【Stream流、方法引用】1. 流式思想123Stream（流）是一个来自数据源（集合、数组等）的元素队列，元素是特定类型的对象，形成一个队列。Java中的Stream并不会存储元素，而是按需计算。中间操作都会返回流对象本身，这样多个操作可以串联成一个管道， 如同流式风格（fluent style）。这样做可以对操作进行优化，比如延迟执行(laziness)和短路( short-circuiting)。 Stream流支持并行，效率高 2. 获取流1234567891011//单列集合中，Collecion接口中加入了stream方法用于获取流Collection&lt;String&gt; c = new ArrayList();Stream&lt;String&gt; collectionStream = c.stream();//双列集合中，获取流需要先获得key集合或value集合或者entry集合Map&lt;String, String&gt; map = new HashMap&lt;&gt;();Stream&lt;String&gt; keyStream = map.keySet().stream();Stream&lt;String&gt; valueStream = map.values().stream();Stream&lt;Map.Entry&lt;String, String&gt;&gt; entryStream = map.entrySet().stream();//要获取数组的流对象，可以通过Stream接口中提供的静态方法ofString[] arr = &#123;"one", "two", "three"&#125;;Stream&lt;String&gt; arrStream = Stream.of(arr); 备注： of 方法的参数其实是一个可变参数，所以支持数组。 3. 常用方法 延迟方法：返回值类型仍然是Stream 接口自身类型的方法，因此支持链式调用。（除了终结方法外，其余方法均为延迟方法。） 终结方法：返回值类型不再是Stream 接口自身类型的方法，因此不再支持类似StringBuilder 那样的链式调用。终结方法包括count 和forEach 方法。 forEach：逐一处理1void forEach(Consumer&lt;? super T&gt; action); filter：过滤1Stream&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate); map：映射1&lt;R&gt; Stream&lt;R&gt; map(Function&lt;? super T, ? extends R&gt; mapper); count：统计个数1long count(); limit：取用前几个1Stream&lt;T&gt; limit(long maxSize); 参数是一个long型，如果集合当前长度大于参数则进行截取；否则不进行操作。 skip：跳过前几个1Stream&lt;T&gt; skip(long n); 如果流的当前长度大于n，则跳过前n个；否则将会得到一个长度为0的空流。 concat：组合1static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b) collect：将流元素生成集合12List&lt;T&gt; list = stream.collect(Collectors.toList());Set&lt;T&gt; set = stream.collect(Collectors.toSet()); toArray：将流元素生成数组1Object[] array = stream.toArray(); 1234567//代码演示// 第一个队伍只要名字为3个字的成员姓名；// 第一个队伍筛选之后只要前3个人；Stream&lt;String&gt; streamOne = one.stream().filter(s ‐&gt; s.length() == 3).limit(3);// 第二个队伍只要姓张的成员姓名；// 第二个队伍筛选之后不要前2个人；Stream&lt;String&gt; streamTwo = two.stream().filter(s ‐&gt; s.startsWith("张")).skip(2);// 将两个队伍合并为一个队伍；// 根据姓名创建Person对象；// 打印整个队伍的Person对象信息。Stream.concat(streamOne, streamTwo).map(Person::new).forEach(System.out::println); 注意：Stream分为三类方法： 初始操作，将数据源转换为Stream流 中间操作，调用之后返回值也是Stream对象 终止操作，调用之后返回值不是Streasm对象 流中的数据只能被消费一次，流在操作过程中，如果执行的是初始操作、中间操作，那么实际上不会对流元素进行处理，只有在进行Stream的终止操作的时候才执行 4. 方法引用1双冒号::为引用运算符，它所在的表达式被称为方法引用，是简化Lambda的书写。如果Lambda要表达的函数方案已经存在于某个方法的实现中，那么则可以通过双冒号来引用该方法作为Lambda的替代者。前提是括号内的所有内容都是依赖于一个对象的某个方法实现的，并不是所有的Lambda表达式都能被简化为方法引用。 1234567891011121314151617181920212223//代码演示public static int method(int i, Function&lt;Integer, Integer&gt; f) &#123; return f.apply(i);&#125;public static void main(String[] args) &#123; System.out.println(method(-5, Math::abs));&#125;//数组的构造器引用public static void main(String[] args) &#123; int[] ints = createArray(5, int[]::new); System.out.println(Arrays.toString(ints));&#125;public static int[] createArray(int i, Function&lt;Integer, int[]&gt; f) &#123; return f.apply(i);&#125;//类的构造器引用public static void main(String[] args) &#123; personBuilder("Eric", (Person::new));&#125;public static void personBuilder(String s, Function&lt;String, Person&gt; f) &#123; Person p = f.apply(s); System.out.println(p);&#125; 【单元测试、反射、注解】1. 单元测试123测试分类： 1. 黑盒测试：不需要写代码，给输入值，看程序是否能够输出期望的值，不用懂程序的知识也可以进行测试 2. 白盒测试：需要写代码的，关注程序具体的执行流程。 白盒测试步骤： 定义一个测试类，类名为被测试类名+Test（CalculatorTest） 定义一个测试方法，可以独立运行，方法名为test+被测方法名（testAdd() ） 方法的返回值：void；参数列表：空参 给方法加@Test 导入junit依赖环境 注意事项： 使用断言操作Assert.assertEquals(期望的结果,运算的结果)来处理结果 红色结果为失败，绿色结果为成功 @Before：修饰的方法会在测试方法之前被自动执行 @After：修饰的方法会在测试方法执行之后自动被执行 123456789101112131415161718//代码演示public class CalculatorTest &#123; @Before public void before() &#123; System.out.println("初始化...");&#125; @Test public void testAdd()&#123; Calculator c = new Calculator(); int add = c.add(1, 2); Assert.assertEquals(3, add);&#125; @Test public void testSub()&#123; Calculator c = new Calculator(); int sub = c.sub(1, 2); Assert.assertEquals(-1, sub);&#125; @After public void after()&#123; System.out.println("释放资源");&#125;&#125; 2. 反射1反射：将类的各个组成部分封装为其他对象，这就是反射机制。通过反射，可以在程序运行过程中操作这些对象，是框架的基础。运用反射可以解耦，提高程序的可拓展性。 获取Class对象1234561. Class.forName("全类名")：用于配置文件 Class personClass = Class.forName("Reflect.Person");2. 类名.class：用于参数的传递 Class personClass = Person.class;3. 对象.getClass()：用于对象的获取字节码的方式 Person p = new Person(); Class personClass = p.getClass(); 操作成员变量对象123456789//获取成员变量对象Field getField(String name)：获取指定名称的public修饰的成员变量Field[] getFields()：获取所有public修饰的成员变量Field getDeclaredField(String name)：获取指定名称的成员变量，不考虑修饰符Field[] getDeclaredFields()：获取所有的成员变量，不考虑修饰符//设置成员变量方法void set(Object obj, Object value)：设置值get(Object obj)：获取值setAccessible(true)：忽略访问权限修饰符的安全检查（暴力反射） 操作构造方法对象1234567//获取构造方法对象Constructor&lt;T&gt; getConstructor(parameterTypes.class)：获取指定参数列表的public修饰的成员变量Constructor&lt;?&gt;[] getConstructors()：获取所有public修饰的构造方法 Constructor&lt;T&gt; getDeclaredConstructor(parameterTypes.class)：获取指定参数列表的成员变量Constructor&lt;?&gt;[] getDeclaredConstructors()：获取所有的构造方法，不考虑修饰符 //创建对象的方法 T newInstance(Object... initargs) 操作成员方法对象1234567//获取成员方法对象Method getMethod(String name，parameterTypes.class)：获取指定名称和参数列表的public修饰的方法Method[] getMethods()：获取所有public修饰的成员方法Method getDeclaredMethod(String name，parameterTypes.class)：获取指定名称和参数列表的成员方法Method[] getDeclaredMethods()：获取所有的成员方法，不考虑修饰符（含继承的方法） //执行方法method invoke(Object obj) 3. “框架”案例12345678910111213// 配置文件ClassMessage.properties:// className = Reflect.Person// methodName = eatpublic static void main(String[] args) throws Exception &#123; Properties pro = new Properties(); pro.load(new FileInputStream("ClassMessage.properties")); String className = pro.getProperty("className"); //Reflect.Person String methodName = pro.getProperty("methodName"); //eat Class cls = Class.forName(className); Object o = cls.getConstructor().newInstance(); Method method = cls.getMethod(methodName); method.invoke(o); //调用了Person类中的eat方法&#125; 4. 注解12注解（Annotation），也叫元数据。一种代码级别的说明，与类、接口、枚举是在同一个层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用来对这些元素进行说明，注释。JDK1.5及以后版本引入的特性。格式：@注解名称 作用分类： 编写文档：通过代码里标识的注解生成文档【生成文档doc文档】 代码分析：通过代码里标识的注解对代码进行分析【使用反射】 编译检查：通过代码里标识的注解让编译器能够实现基本的编译检查【Override】 JDK中预定义的一些注解： @override：方法重写注解 @Deprecated：过期注解 @SuppressWarnings：压制警告，将当前所有的类警告都去除 一般传递参数all @SuppressWarnings(“all”) 5. 自定义注解12345//格式： 元注解 public @interface 注解名称&#123; 属性列表; &#125; 注解本质上就是一个接口，该接口默认继承Annotation接口： public interface MyAnno extends java.lang.annotation.Annotation {} 注解接口中的要求： 接口中的抽象方法称为属性，返回值类型为： ①基本数据类型；②String；③枚举；④注解；⑤以上类型的数组 定义了属性，在使用时需要给属性赋值，若定义时已经给了默认值，可以不用赋值，如果只有一个属性需要赋值，并且属性的名称是value，则赋值的时候，value的字样可以省略 数组赋值时，需要使用{}包裹，如果数组中只有一个值，则{}省略 6. 元注解1用于描述注解的注解。 @Target(ElementType)：描述注解能够作用的位置 ElementType取值： ElementType.TYPE：可以作用于类上 ElementType.METHOD：可以作用于方法上 ElementType.FIELD：可以作用于成员变量上 @Retention(RetentionPolicy)：描述注解被保留的阶段 RetentionPolicy取值： RetentionPolicy.RUNTIME：当前被描述的注解，会保留到class字节码文件中，并被JVM读取到 RetentionPolicy.CLASS：当前被描述的注解，会保留到class字节码文件中，不会被JVM读取 RetentionPolicy.SOURCE：当前被描述的注解，不会被class字节码文件保留 @Documented：描述注解是否被抽取到api文档中 @Inherited：描述注解是否被子类继承 7. ”测试框架“案例12345678910111213141516171819202122232425public static void main(String[] args) throws IOException &#123; Calculator c = new Calculator(); Class cls = c.getClass(); //获取类中的所有方法 Method[] methods = cls.getMethods(); //创建输出流和记录异常次数的变量count BufferedWriter bw = new BufferedWriter(new FileWriter("error.txt")); int count = 0; for (Method method : methods) &#123; //遍历所有方法，筛选出被@Check标记的方法 if (method.isAnnotationPresent(Check.class)) &#123; try &#123; method.invoke(c); &#125; catch (Exception e) &#123; count++; //将异常打印到日志文件中 bw.write(method.getName() + "方法出异常了"); bw.newLine(); bw.write("异常的名称" + e.getCause().getClass().getSimpleName()); bw.newLine(); bw.write("异常的原因" + e.getCause()); bw.newLine(); bw.write("-----------------"); bw.newLine();&#125;&#125;&#125; bw.write("本次测试共出现了" + count + "次异常"); bw.close();&#125;]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据库]]></title>
    <url>%2F2019%2F06%2F16%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[数据库知识点总结1. MySQL1. 数据库的基本概念12数据库(DataBase,简称:DB)，用于存储和管理数据的仓库。类比：数据库：文件夹(仓库)；表：文件（货架子）； 数据：数据（货物）。 数据库的特点： 持久化存储数据，数据库就是一个文件系统 方便存储和管理数据 使用了统一的方式操作数据库 – SQL 2. MySQL配置操作123456789服务启动: net start mysql：启动mysql的服务 net stop mysql：关闭mysql服务登录: mysql -u用户名 -p密码 mysql -hip地址 -u用户名 -p连接目标的密码退出: exit/quit配置文件 my.ini 3. SQL概念12Structured Query Language：结构化查询语言。SQL定义了操作所有关系型数据库的规则。每一种数据库操作的方式存在不一样的地方，称为“方言”。 SQL通用语法： SQL 语句可以单行或多行书写，以分号结尾。 可使用空格和缩进来增强语句的可读性。 MySQL 数据库的 SQL 语句不区分大小写，关键字建议使用大写。 注释： 单行注释: – 注释内容 或 # 注释内容(mysql 特有) 多行注释: /* 注释 */ SQL分类： DDL（Data Definition Language）数据定义语言：用来定义数据库对象：数据库，表，列等。 DML（Data Manipulation Language）数据操作语言：用来对数据库中表的数据进行增删改。 DQL（Data Query Language）数据查询语言：用来查询数据库中表的记录(数据)。 DCL（Data Control Language）数据控制语言：用来定义数据库的访问权限和安全级别，创建用户。 4. DDL 定义数据库操作数据库 操作 代码 备注 创建 create database 数据库名称 创建数据库 创建 create database if not exists 数据库名称 创建数据库，判断不存在，再创建 创建 create database 数据库名称 character set 字符集名称 创建数据库，并指定字符集 查询 show databases 查询所有数据库的名称 查询 show create database 数据库名称 查询某个数据库的字符集/创建语句 修改 alter database数据库名称 character set 字符集名称 修改数据库的字符集 删除 drop database 数据库名称 删除数据库 删除 drop database if exists 数据库名称 判断数据库存在，存在再删除 使用 select database() 查询当前正在使用的数据库名称 使用 use 数据库名称 使用数据库 注意：数据库的名称不可修改 操作表 操作 代码 备注 创建 create table 表名(列名1 数据类型1,....列名n 数据类型n); 创建一个表 创建 create table 表名 like 被复制的表名 复制表 查询 show tables 查询某个数据库中所有的表名称 查询 desc 表名 查询表结构 修改 alter table 表名 rename to 新的表名 修改表名 修改 alter table 表名 character set 字符集名称 修改表的字符集 修改 show create table 表名 查看表的字符集 修改 alter table 表名 add 列名 数据类型 添加一列 修改 alter table 表名 add 列名 数据类型 after 指定列名 在指定的列后添加一列 修改 alter table 表名 change 列名 新列别 新数据类型 修改列名称和数据类型 修改 alter table 表名 modify 列名 新数据类型 修改数据类型 修改 alter table 表名 drop 列名 删除列 删除 drop table 表名 删除表 删除 drop table if exists 表名 判断表存在，存在再删除 数据类型： int：整数类型 age int double：小数类型 score double(5,2) date：日期，只包含年月日 yyyy-MM-dd datetime：日期，包含年月日时分秒 yyyy-MM-dd HH:mm:ss timestamp：时间戳，包含年月日时分秒 yyyy-MM-dd HH:mm:ss（默认使用系统当前时间赋值） varchar：字符串 name varchar(20) （括号里数字为可接收最大字符数） 5. DML 增删改表中数据 操作 代码 备注 添加 insert into 表名 values (值1,值2,...值n) 给表中每一列赋值 添加 insert into 表名(列名1,列名2,...列名n)values(值1,值2,...值n) 选择地给表中某一列赋值 删除 delete from 表名 [where 条件] 删除符合条件的记录 删除 truncate table 表名 删除整张表 修改 update 表名 set 列名1 = 值1, 列名2 = 值2,... [where 条件] 修改指定列的数据 注意： 除了数字类型，其他类型需要使用引号(单双都可以)引起来，数值类型加引号也不会报错，但是不推荐加 若要删除整表，推荐使用truncate table，效率高；delete from 内部采用逐个删除，效率低 若要修改多条记录，可以指定条件数据范围in() 6. DQL 查询表中记录123456789101112131415语法格式： select 字段列表 from 表名列表 where 条件列表 group by 分组字段 having 分组之后的条件 order by 排序 limit 分页限定 基础查询 多个字段的查询：select 字段名1，字段名2... from 表名；(*来替代查询所有字段) 去除重复：select distinct 字段名1，字段名2... from 表名； 计算列：一般可以使用四则运算计算一些列的值。（一般只会进行数值型的计算） null参与的运算，计算结果都为null。ifnull(表达式1,表达式2)： 表达式1：需要判断是否为null的字段；表达式2：若该字段为null后的替换值 起别名：as（as也可以省略） 条件查询 1. where子句后跟条件 2. 运算符 * &lt;&gt; (相当于!=) * BETWEEN...AND * IN( 集合) 3. 模糊查询 LIKE：占位符：`_`：单个任意字符；`%`：多个任意字符（含0个） 4. IS NULL (是否为空，不能用=null判断) ；IS NOT NULL：不为空 排序查询 语法：order by 排序字段1 排序方式1 ，排序字段2 排序方式2... 排序方式：ASC：升序，默认的；DESC：降序 如果有多个排序条件，则当前边的条件值一样时，才会判断第二条件 聚合函数 将一列数据作为一个整体，进行纵向的计算，需要排除null值 count：计算个数（count(*)：只要该数据有一列不为空） max：计算最大值 min：计算最小值 sum：计算和 avg：计算平均值 分组查询 语法：group by 分组字段； 要求：查询条件的字段只能是分组字段和聚合函数 分页查询 语法：limit 要开始显示的索引，每页查询的条数； 公式：开始的索引 = （当前的页码 - 1） * 每页显示的条数 limit 是一个MySQL”方言” where 和 having 的区别？ where 在分组之前进行限定，如果不满足条件，则不参与分组；having在分组之后进行限定，如果不满足结果，则不会被查询出来。 where 后不可以跟聚合函数，having可以进行聚合函数的判断。 7. 约束非空约束1not null，某一列的值不能为null 创建表时，添加非空约束：CREATE TABLE stu(id INT,NAME VARCHAR(20) NOT NULL); 创建表后，添加非空约束：ALTER TABLE stu MODIFY NAME VARCHAR(20) NOT NULL; 删除非空约束：ALTER TABLE stu MODIFY NAME VARCHAR(20); 唯一约束1unique，某一列的值不能重复，但可以有多个NULL值 创建表时，添加唯一约束：CREATE TABLE stu(id INT, NAME VARCHAR(20) UNIQUE ); 创建表后，添加唯一约束：ALTER TABLE stu MODIFY NAME VARCHAR(20) UNIQUE; 删除唯一约束：ALTER TABLE stu DROP INDEX NAME; 主键约束1primary key，非空且唯一，一张表只能有一列的值设为主键，是表中记录的唯一标识，一般是数据无关列 创建表时，添加主键约束：CREATE TABLE stu(id INT PRIMARY KEY, NAME VACHAR(20)); 创建表后，添加主键约束：ALTER TABLE stu MODIFY id INT PRIMARY KEY; 删除主键约束：ALTER TABLE stu DROP PRIMARY KEY; 主键约束添加自增长：id INT PRIMARY KEY AUTO_INCREMENT； 外键约束1foreign key，让表于表产生关系，从而保证数据的正确性 创建表时，添加外键约束： constraint 外键名称 foreign key(外键列名称) references 主表名称(主键列名称) ① 外键列名称为受约束的列名称，主键列名称为约束别人的列名称； 外键名称可以自定义，起到删除时索引的作用 。一般格式：当前表名 _ 外键表名 _ fk 创建表之后，添加外键约束：ALTER TABLE stu ADD + ① 删除外键约束：ALTER TABLE stu DROP FOREIGN KEY 外键名称； 级联操作：级联更新：ON UPDATE CASCADE ；级联删除：ON DELETE CASCADE 8. 数据库的设计123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263641. 一对一：实现方式：一对一关系实现，可以在任意一方添加唯一外键指向另一方的主键。2. 一对多(多对一)：实现方式：在多的一方建立外键，指向一的一方的主键。3. 多对多：实现方式：多对多关系实现需要借助第三张中间表。中间表至少包含两个字段，这两个字段作为第三张表的外键，分别指向两张表的主键。-- 旅游网案例展示：一个旅游线路分类中有多个旅游线路；一个用户收藏多个线路，一个线路被多个用户收藏。/*创建旅游线路分类表 tab_category cid 旅游线路分类主键，自动增长 cname 旅游线路分类名称非空，唯一，字符串 100*/CREATE TABLE tab_category ( cid INT PRIMARY KEY AUTO_INCREMENT, cname VARCHAR(100) UNIQUE NOT NULL);/*创建旅游线路表 tab_route rid 旅游线路主键，自动增长 rname 旅游线路名称非空，唯一，字符串 100 price 价格 rdate 上架时间，日期类型 cid 外键，所属分类*/CREATE TABLE tab_route( rid INT PRIMARY KEY AUTO_INCREMENT, rname VARCHAR(100) NOT NULL UNIQUE, price DOUBLE, rdate DATE, cid INT, FOREIGN KEY (cid) REFERENCES tab_category(cid));/*创建用户表 tab_user uid 用户主键，自增长 username 用户名长度 100，唯一，非空 password 密码长度 30，非空 name 真实姓名长度 100 birthday 生日 sex 性别，定长字符串 1 telephone 手机号，字符串 11 email 邮箱，字符串长度 100*/CREATE TABLE tab_user ( uid INT PRIMARY KEY AUTO_INCREMENT, username VARCHAR(100) NOT NULL UNIQUE, PASSWORD VARCHAR(30) NOT NULL, NAME VARCHAR(100), birthday DATE, sex CHAR(1) DEFAULT &apos;男&apos;, telephone VARCHAR(11), email VARCHAR(100));/*创建收藏表 tab_favorite rid 旅游线路 id，外键 date 收藏时间 uid 用户 id，外键 rid 和 uid 不能重复，设置复合主键，同一个用户不能收藏同一个线路两次*/CREATE TABLE tab_favorite ( rid INT, FOREIGN KEY (rid) REFERENCES tab_route(rid), DATE DATETIME, uid INT, FOREIGN KEY (uid) REFERENCES tab_user(uid), PRIMARY KEY (rid,uid) -- 联合主键); 9. 数据库设计范式1231. 第一范式（1NF）：每一列都是不可分割的原子数据项2. 第二范式（2NF）：在1NF的基础上，非码属性必须完全依赖于码（在1NF基础上消除部分函数依赖）3. 第三范式（3NF）：在2NF基础上，任何非主属性不依赖于其它非主属性（在2NF基础上消除传递依赖） 几个概念： 函数依赖：A–&gt;B，如果通过A属性(属性组)的值，可以确定唯一B属性的值，则称B依赖于A。 完全函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值的确定需要依赖于A属性组中所有的属性值。 部分函数依赖：A–&gt;B， 如果A是一个属性组，则B属性值得确定只需要依赖于A属性组中某一些值即可。 传递函数依赖：A–&gt;B, B – &gt;C . 如果通过A属性(属性组)的值，可以确定唯一B属性的值，在通过B属性（属性组）的值可以确定唯一C属性的值，则称 C 传递函数依赖于A。 码：一张表中，一个属性或属性组，被其他所有属性所完全依赖，则称这个属性(属性组)为该表的码。 第一范式表（1NF）：原子数据项 学号 姓名 系名 系主任 课程名称 分数 10010 张无忌 经济系 张三丰 高等数学 95 10010 张无忌 经济系 张三丰 大学英语 87 10010 张无忌 经济系 张三丰 计算机基础 65 10011 令狐冲 法律系 任我行 法理学 77 10011 令狐冲 法律系 任我行 大学英语 87 10011 令狐冲 法律系 任我行 法律社会学 65 10012 杨过 法律系 任我行 法律社会学 95 10012 杨过 法律系 任我行 法理学 97 10012 杨过 法律系 任我行 大学英语 99 存在问题： 存在非常严重的数据冗余(重复)：姓名、系名、系主任 数据添加存在问题：添加新开设的系和系主任时，数据不合法 数据删除存在问题：张无忌同学毕业了，删除数据，会将系的数据一起删除。 第二范式表（2NF）：消除部分函数依赖 学号 课程名称 分数 学号 姓名 系名 系主任 10010 高等数学 95 10010 张无忌 经济系 张三丰 10010 大学英语 87 10011 令狐冲 法律系 任我行 10010 计算机基础 65 10012 杨过 法律系 任我行 10011 法理学 77 10011 大学英语 87 10011 法律社会学 65 10012 法律社会学 95 10012 法理学 97 10012 大学英语 99 第三范式表（3NF）：消除传递依赖 学号 课程名称 分数 学号 姓名 系名 系名 系主任 10010 高等数学 95 10010 张无忌 经济系 经济系 张三丰 10010 大学英语 87 10011 令狐冲 法律系 法律系 任我行 10010 计算机基础 65 10012 杨过 法律系 10011 法理学 77 10011 大学英语 87 10011 法律社会学 65 10012 法律社会学 95 10012 法理学 97 10012 大学英语 99 10. 数据库的备份和还原 备份： mysqldump -u用户名 -p密码 数据库名称 &gt; 保存的路径 还原：登录数据库—&gt;创建数据库—&gt;使用数据库—&gt;执行文件 source 文件路径 11. 多表查询隐式内连接 使用where条件消除无用数据：SELECT * FROM emp,dept WHERE emp.dept_id = dept.id 显式内连接 表名1 [inner] join 表名2 on 条件：SELECT * FROM emp INNER JOIN dept ON emp.dept_id= dept.id 外链接查询 左外连接：查询左表所有数据以及其和右表交集部分 语法：select 字段列表 from 表1 left [outer] join 表2 on 条件 右外连接与左外连接正好相反：select 字段列表 from 表1 right [outer] join 表2 on 条件； 子查询1查询中嵌套查询，称嵌套查询为子查询。 子查询的结果是单行单列的：子查询可以作为条件，使用运算符去判断。 子查询的结果是多行单列的：子查询可以作为条件，使用in(结果)来判断。 子查询的结果是多行多列的：子查询可以作为一张虚拟表参与查询。 12. 事务1如果一个包含多个步骤的业务操作，被事务管理，那么这些操作要么同时成功，要么同时失败。 基本操作： 开启事务： start transaction; 回滚：rollback; 提交：commit; 提交方式： 自动提交：一条DML(增删改)语句会自动提交一次事务。（mysql） 手动提交：需要先开启事务，再提交。（Oracle） 修改事务的默认提交方式： 查看事务的默认提交方式：SELECT @@autocommit; 1 代表自动提交，0 代表手动提交 修改默认提交方式： set @@autocommit = 0; 四大特征ACID 原子性Atomic：是不可分割的最小操作单位，要么同时成功，要么同时失败。 一致性Consistent：事务操作前后，数据总量不变 隔离性Isolated：多个事务之间。相互独立。 持久性Duration：当事务提交或回滚后，数据库会持久化的保存数据。 隔离级别1234多个事务之间隔离的，相互独立的。但是如果多个事务操作同一批数据，则会引发一些问题：1. 脏读：一个事务，读取到另一个事务中没有提交的数据2. 不可重复读(虚读)：在同一个事务中，两次读取到的数据不一样。3. 幻读：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。 四种隔离级别： read uncommitted：读未提交。产生的问题：脏读、不可重复读、幻读 read committed：读已提交 （Oracle）。产生的问题：不可重复读、幻读 repeatable read：可重复读 （MySQL默认）。产生的问题：幻读 serializable：串行化。可以解决所有的问题 数据库查询隔离级别：select @@tx_isolation; 数据库设置隔离级别：set global transaction isolation level 级别字符串; 注意：隔离级别从小到大安全性越来越高，但是效率越来越低 13. DCL 控制用户权限用户管理 操作 代码 备注 添加 CREATE USER &#39;用户名&#39;@&#39;主机名&#39;IDENTIFIED BY&#39;密码&#39; 创建一个用户 删除 DROP USER &#39;用户名&#39;@&#39;主机名&#39; 删除指定用户 修改 UPDATE USER SET PASSWORD = PASSWORD(&#39;新密码&#39;)WHERE USER =&#39;用户名&#39; 修改用户密码 修改 SET PASSWORD FOR &#39;用户名&#39;@&#39;主机名&#39;= PASSWORD(&#39;新密码&#39;) 修改用户密码 查询 切换到mysql数据库后，SELECT * FROM 用户名 查询用户信息 重置root用户密码： 停止mysql服务：管理员运行cmd – &gt; net stop mysql 使用无验证方式启动mysql服务： mysqld –skip-grant-tables 打开新的cmd窗口,直接输入mysql命令，敲回车。就可以登录成功 切换到mysql数据库：use mysql; 重置密码：update user set password = password(‘你的新密码’) where user = ‘root’; 关闭两个窗口 打开任务管理器，手动结束mysqld.exe 的进程 启动mysql服务：net start mysql 使用新密码登录 权限管理 操作 代码 备注 查询 SHOW GRANTS FOR &#39;用户名&#39;@&#39;主机名&#39; 查询权限 授予 grant 权限列表 on数据库名.表名 to &#39;用户名&#39;@&#39;主机名&#39; 授予权限 撤销 revoke 权限列表 on数据库名.表名 from &#39;用户名&#39;@&#39;主机名&#39; 撤销权限 通配符： % 表示可以在任意主机使用用户登录数据库；localhost主机名仅限于本机使用。 给user用户授予所有权限，在任意数据库任意表上： GRANT ALL ON * . * TO ‘user’ @ ‘%’; 2. JDBC1. JDBC12Java DataBase Connectivity Java ：数据库连接本质：官方（sun公司）定义的一套操作所有关系型数据库的规则，即接口。各个数据库厂商去实现这套接口，提供数据库驱动jar包。我们可以使用这套接口（JDBC）编程，真正执行的代码是驱动jar包中的实现类。 操作步骤： 导入驱动jar包 复制mysql-connector-java-5.1.37-bin.jar到项目的libs目录下 右键–&gt;Add As Library 注册驱动（mysql5之后的驱动jar包可以省略注册驱动的步骤） Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 获取数据库连接对象 Connection Connection conn = DriverManager.getConnection(String url, String user, String password); 定义sql语句 String sql = &quot;update account set balance = 500 where id = 1&quot;; 获取执行sql的对象 StatementStatement stmt = conn.createStatement(); 执行sqlint count = stmt.executeUpdate(sql); 处理结果 System.out.println(count); 释放资源stmt.close(); conn.close(); Connection 数据库连接对象123Connection conn = DriverManager.getConnection(String url, String user, String password)；url是指定的连接路径，例如jdbc:mysql://localhost:3306/数据库名称；如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则可以简写为jdbc:mysql:///数据库名称 功能： 获取执行sql 的对象： Statement createStatement() PreparedStatement prepareStatement(String sql) 管理事务： 开启事务：setAutoCommit(boolean autoCommit) ：调用该方法设置参数为false，即开启事务 提交事务：commit() 回滚事务：rollback() Statement 执行sql的对象 boolean execute(String sql)：可以执行任意的sql int executeUpdate(String sql)：执行DML（insert、update、delete）语句、DDL(create，alter、drop)语句。返回值为影响的行数，可以通过这个影响的行数判断DML语句是否执行成功：返回值&gt;0的则执行成功，反之，则失败。 ResultSet executeQuery(String sql)：执行DQL（select)语句 ResultSet 结果集对象 boolean next()：游标向下移动一行，判断当前行是否是最后一行末尾(是否有数据)，如果是，则返回false，如果不是则返回true。 getXxx(参数)：获取数据，XXX如：int getInt()，String getString() 参数可以是int，代表列的编号，从1开始；也可以是String，代表列名称。 1234567891011121314//代码展示,展示指定表中数据public static void main(String[] args) &#123; try (Connection conn = DriverManager.getConnection("jdbc:mysql:///db_day01", "root", "root"); Statement stmt = conn.createStatement(); ResultSet rs = stmt.executeQuery("select * from dept");) &#123; while (rs.next()) &#123; String DEPTON = rs.getString("DEPTNO"); String DNAME = rs.getString("DNAME"); String LOC = rs.getString("LOC"); System.out.println(DEPTON + "---" + DNAME + "---" + LOC); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125; 2. JDBCUtils 抽取JDBC工具类1234567891011121314151617181920212223242526272829303132333435363738394041424344//JDBCUtils 代码展示public class JDBCUtils &#123; private static String url; //配置文件的四个参数 private static String user; private static String password; private static String driver; static&#123; //静态代码块，完成各个参数的赋值，省略了try...catch语句 Properties pro = new Properties(); InputStream is = JDBCUtils.class.getClassLoader().getResourceAsStream ("jdbc.properties"); //通过类加载器获得配置文件路径 pro.load(is); url = pro.getProperty("url"); user = pro.getProperty("user"); password = pro.getProperty("password"); driver = pro.getProperty("driver"); Class.forName(driver);&#125; //获取Connection对象的方法 public static Connection getConnection() throws SQLException &#123; return DriverManager.getConnection(url, user, password); &#125; //释放资源的方法，两种重载形式 public static void close(Statement stmt,Connection conn)&#123; if( stmt != null)&#123; try &#123;stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125; if( conn != null)&#123; try &#123;conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125;&#125; public static void close(ResultSet rs, Statement stmt, Connection conn)&#123; if( rs != null)&#123; try &#123;rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125; if( stmt != null)&#123; try &#123;stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125; if( conn != null)&#123; try &#123;conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125;&#125;&#125; 3. 用户登录案例与sql注入问题1在拼接sql时，有一些sql的特殊关键字参与字符串的拼接，会造成安全性问题。PreparedStatement对象可以解决这个问题，预编SQL语句时使用“？”作为占位符，可以防止SQL注入，同时效率更高。 12345678910111213141516171819202122232425262728293031323334353637383940414243// 使用JDBCUtils完成登录案例代码展示public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println("请输入用户名："); String username = sc.nextLine(); System.out.println("请输入密码："); String password = sc.nextLine(); boolean flag = login(username, password); if (flag) &#123; System.out.println("登录成功"); &#125;else&#123; System.out.println("用户名或密码错误"); &#125;&#125;public static boolean login(String username, String password)&#123; if (username == null || password == null) &#123; return false; &#125; Connection conn = null; PreparedStatement pstmt = null; ResultSet rs = null; try &#123; conn = JDBCUtils.getConnection(); /*特殊关键字拼接sql时会造成安全性问题，例如密码：a' or 'a' = 'a String sql = "select * from user where username = '"+username+"' and password = '"+password+"' "; stmt = conn.createStatement(); rs = stmt.executeQuery(sql); */ //使用PreparedStatement对象来解决,参数使用?作为占位符 String sql = "select * from user where username = ? and password = ?"; pstmt = conn.prepareStatement(sql); pstmt.setString(1, username); //setXXX方法，参数1为第几个问号的位置，参数2为赋值 pstmt.setString(2, password); rs = pstmt.executeQuery(); return rs.next(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; finally &#123; JDBCUtils.close(rs, pstmt, conn); &#125; return false;&#125; 4. JDBC事务控制1234567891011121314151617181920212223242526272829303132333435363738394041public static void main(String[] args) &#123; Connection conn = null; PreparedStatement pstmt1 = null; PreparedStatement pstmt2 = null; try &#123; conn = JDBCUtils.getConnection(); //开启事务 conn.setAutoCommit(false); //张三 - 500 String sql1 = "update account set balance = balance - ? where id = ?"; //李四 + 500 String sql2 = "update account set balance = balance + ? where id = ?"; //获取执行sql对象 pstmt1 = conn.prepareStatement(sql1); pstmt2 = conn.prepareStatement(sql2); //设置参数 pstmt1.setDouble(1,500); pstmt1.setInt(2,1); pstmt2.setDouble(1,500); pstmt2.setInt(2,2); //执行张三sql pstmt1.executeUpdate(); // 手动制造异常 int i = 3/0; //执行李四sql pstmt2.executeUpdate(); //提交事务 conn.commit(); &#125; catch (Exception e) &#123; //发生任何异常，事务回滚 try &#123; if(conn != null) &#123; conn.rollback(); &#125; &#125; catch (SQLException e1) &#123; e1.printStackTrace(); &#125; e.printStackTrace(); &#125;finally &#123; JDBCUtils.close(pstmt1,conn); JDBCUtils.close(pstmt2,null); &#125; 5. 数据库连接池1本质是一个存放数据库连接的容器(集合)。当系统初始化好后，容器被创建，容器中会申请一些连接对象，当用户来访问数据库时，从容器中获取连接对象，用户访问完之后，会将连接对象归还给容器。 好处：针对数据库连接对象的复用，可以节约创建以及销毁数据库连接对象的资源，提高用户访问效率。 标准接口：DataSource 常用方法：获取连接：getConnection()；归还连接：Connection.close() C3P0 数据库连接池技术1234567//使用步骤：//1. 导入jar包：【c3p0-0.9.5.2.jar】和【mchange-commons-java-0.2.12.jar】//2. 定义配置文件：【c3p0.properties】或【c3p0-config.xml】直接放在src目录下//3. 创建数据库连接池对象DataSource ds = new ComboPooledDataSource();//4. 获取连接对象Connection conn = ds.getConnection(); Druid 数据库连接池技术1234567891011//使用步骤：//1. 导入jar包【druid-1.0.9.jar】//2. 定义配置文件：properties文件，可以叫任意名称，放在任意目录下InputStream is = Demo.class.getClassLoader().getResourceAsStream("druid.properties");//3. 加载配置文件：Properties pro = new Properties(); pro.load(is);//4. 获取数据库连接池对象：通过工厂来来获取 DataSource ds = DruidDataSourceFactory.createDataSource(pro);//5. 获取连接：Connection conn = ds.getConnection(); 12345678910111213141516171819202122232425262728293031323334//代码展示：根据Druid技术，定义工具类JDBCUtilsprivate static DataSource ds;//静态代码块中加载配置文件，生成DataSource对象static&#123; Properties pro = new Properties(); pro.load (DruidUtils.class.getClassLoader().getResourceAsStream("druid.properties")); ds = DruidDataSourceFactory.createDataSource(pro);&#125;//返回DataSource对象的方法，用于SpringJDBCpublic static DataSource getDataSource()&#123; return ds;&#125;//返回Connection对象的方法public static Connection getConnection() throws SQLException &#123; return ds.getConnection();&#125;//两个重载的归还连接方法public static void close(Statement stmt, Connection conn) &#123; close(null, stmt, conn);&#125;public static void close(ResultSet rs, Statement stmt, Connection conn) &#123; if (rs != null) &#123; try &#123;rs.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125; if (stmt != null) &#123; try &#123;stmt.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125; if (conn != null) &#123; try &#123;conn.close(); &#125; catch (SQLException e) &#123; e.printStackTrace();&#125;&#125;&#125; 6. Spring JDBC1Spring框架对JDBC的简单封装，提供了一个JDBCTemplate对象简化JDBC的开发。 常用方法： 使用数据源DataSource，创建JdbcTemplate对象： JdbcTemplate template = new JdbcTemplate(ds); update()：执行DML增、删、改语句： int count = template.update(sql); queryForMap()：将列名作为key，值作为value，将一条记录封装为一个map集合 Map&lt;String, Object&gt; map = template.queryForMap(sql); queryForList()：将每一条记录封装为一个Map集合，再将Map集合装载到List集合中 List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(sql); query()：查询结果，将结果封装为JavaBean对象 List&lt;T&gt; list = template.query(sql, new BeanPropertyRowMapper&lt;T&gt;(T.class)); queryForObject：查询结果，将结果封装为对象，一般用于获取单行单列的数值数据 String count = template.queryForObject(sql, String.class); 3. Redis1. Redis1Redis是用C语言开发的一个开源的高性能键值对的NOSQL(Not Only SQL)非关系型数据库，通过将数据缓存于内存中，提升程序的读写效率。官方测试：50个并发执行100000个请求,读的速度是110000次/s,写的速度是81000次/s。 NOSQL和关系型数据库 比较 非关系型数据库 关系型数据库 成本 基本开源，部署简单 价格高昂 性能 不支持事务处理，不经过SQL层解析，性能高 事务支持，安全性高，可实现多表复杂查询 查询速度 数据存储于缓存中，速度快 数据存储于硬盘中，速度慢 拓展性 数据间没有耦合，容易水平拓展 多表查询机制导致拓展艰难 维护性 新技术维护工具和资料有限 长时间积累，工具丰富 存储格式 格式丰富（value、文档、图片等等） 只支持基础类型 学习成本 没有统一工业标准，学习成本较高 支持sql标准，技能易迁移 对于这两类数据库，对方的优势就是自己的弱势，反之亦然。两者是互补的关系，一般会将全部数据存储在关系型数据库中，然后在nosql数据库中备份存储不常变化，使用频率高的数据。 主流的NOSQL产品 键值(Key-Value)存储数据库：Tokyo Cabinet/Tyrant、Redis、Voldemort、Berkeley DB 列存储数据库：Cassandra, HBase, Riak 文档型数据库：CouchDB、MongoDB 图形(Graph)数据库：Neo4J、InfoGrid、Infinite Graph Redis特点 Redis速度快的原因： 因为Redis使用C语言开发 C语言可以直接操作内存 Redis 是内存（JVM）操作内存（redis数据库） Redis多路复用的IO Redis是单线程的，避免了并发和锁对性能的消耗 Redis支持的键值数据类型： 字符串类型 string 哈希类型 hash 列表类型 list：linkedlist格式，支持重复元素 集合类型 set：不允许重复元素 有序集合类型 sortedset：不允许重复元素，且元素有顺序 Redis命令操作 字符串类型（String） 存储：set key value 获取：get key 删除：del key 哈希类型（hash） 存储：hset key field value 获取：hget key field：获取指定的field对应的值 ​ hgetall key：获取所有的field和value 删除：hdel key field 列表类型（list） 添加：lpush key value：将元素加入列表左表 ​ rpush key value：将元素加入列表右边 获取：lrange key start end：start为起始位置，end为结束位置（0 -1可获取所有元素） 删除：lpop key：删除列表最左边的元素，并将元素返回 ​ rpop key：删除列表最右边的元素，并将元素返回 集合类型（set）：不允许重复元素 存储：sadd key value：将一个value放入key集合中 获取：smembers key：获取set集合中所有元素 删除：srem key value：删除set集合中的某个元素 有序集合类型（sortedset） ：不允许重复元素，且元素有顺序。 每个元素都会关联一个double类型的分数，redis通过该分数来为集合中的成员进行从小到大的排序。 存储：zadd key score value 获取：zrange key start end [withscores] 删除：zrem key value 通用命令： 获取所有的键：keys * 获取键对应的value类型：type key 删除指定的key-value：del key Redis持久化机制 RDB：在一定的间隔时间中，检测key的变化情况，然后持久化数据。为Redis默认持久化方式，通过编辑redis.windwos.conf文件可以自定义持久化参数： save 900 1：after 900 sec (15 min) if at least 1 key changed save 60 10000：after 60 sec if at least 10000 keys changed AOF：日志记录的方式，可以记录每一条命令的操作。触发设定的动作后，持久化数据，通过编辑redis.windwos.conf文件可以自定义持久化参数： appendonly no（关闭aof） –&gt; appendonly yes（开启aof） appendfsync always：每一次操作都进行持久化 appendfsync everysec：每隔一秒进行一次持久化 appendfsync no：不进行持久化 2. Jedis1一款java操作redis数据库的工具。 Jedis方法： 获取连接：Jedis jedis = new Jedis(&quot;localhost&quot;,6379); 操作：jedis.set(&quot;username&quot;,&quot;zhangsan&quot;); 关闭连接：jedis.close(); 指定过期时间：jedis.setex(&quot;activecode&quot;,20,&quot;hehe&quot;); 1234567891011121314151617181920212223242526272829//jedis连接池public class JedisPoolUtils &#123; private static JedisPool jedisPool; static&#123; //读取配置文件 InputStream is = JedisPoolUtils.class.getClassLoader(). getResourceAsStream("jedis.properties"); //创建Properties对象 Properties pro = new Properties(); //关联文件 try &#123; pro.load(is); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; //获取数据，设置到JedisPoolConfig中 JedisPoolConfig config = new JedisPoolConfig(); // 将字符串转化为int 使用Integer.parseInt("") config.setMaxTotal(Integer.parseInt(pro.getProperty("maxTotal"))); config.setMaxIdle(Integer.parseInt(pro.getProperty("maxIdle"))); //初始化JedisPool jedisPool = new JedisPool(config,pro.getProperty("host"), Integer.parseInt(pro.getProperty("port"))); &#125; //获取连接方法 public static Jedis getJedis()&#123; return jedisPool.getResource(); &#125;&#125; 4. Oracle1. Oracle1ORACLE数据库是目前最流行的C/S或B/S体系结构的关系型数据库，具有完整的数据管理和分布式处理的功能。 数据库：Oracle数据库是一个操作系统只有一个库，可以看做是Oracle就只有一个大数据库。 实例：一个Oracle实例（Oracle Instance）有一系列的后台进程（Backguound Processes)和内存结构 （Memory Structures)组成。一个数据库可以有n个实例。 用户：用户在实例下建立，不同实例可以创建相同名字的用户。 表空间：表空间是Oracle对物理数据库上相关数据文件（ORA或者DBF文件）的逻辑映射。每个表空间由同一磁盘上的一个或多个文件组成，这些文件叫数据文件(datafile)。一个数据文件只能属于一个表空间。 数据文件：数据文件（dbf、ora）是数据库的物理存储单位，一个表空间可以由一个或多个数据文件组成，一个数据文件只能属于一个表空间。一旦数据文件被加入到某个表空间后，就不能删除这个文件，如果要删除某个数据文件，只能删除其所属于的表空间才行。 oracle通过用户和表空间对数据进行管理和存放，但是表不是由表空间去查询的，而是由用户去查询。不同用户可以在同一个表空间建立同一个名字的表，同名的表通过不同用户来区分。 创建表空间12345create tablespace itcast //指定表空间名称datafile &apos;c:\itcast.dbf&apos; //指定表空间对应的数据文件size 100m //指定表空间的初始大小autoextend on //当表空间存储都占满时，自动增长next 10m //指定一次自动增长的大小 创建用户1234create user itcastuser //指定用户名 identified by itcast //指定用户密码 default tablespace itcast //指定表空间名称grant dba to itcastuser //为用户赋予权限 Oracle中三个重要的角色：connect角色（用户），resource角色（开发人员），dba角色（最高权限）。 表的管理1234567891011121314创建person表： create table person( pid number(10), name varchar2(10), gender number(1) default 1, birthday date );表删除：DROP TABLE 表名表的修改：在person表中增加列address：alter table person add(address varchar2(10));把person表的address列的长度修改成20长度：alter table person modify(address varchar2(20)); 数据的管理123456INSERT（增加）：INSERT INTO表名[(列名1，列名2，...)]VALUES(值1，值2，...)UPDATE（修改）：UPDATE 表名 SET 列名1=值1，列名2=值2，....WHERE 修改条件；DELETE（删除）：语法 : DELETE FROM 表名 WHERE 删除条件; 序列1234创建序列：CREATE SEQUENCE 序列名select seqpersonid.nextval from dual 取得序列的下一个内容select seqpersonid.currval from dual 取得序列的当前内容 其他函数空值处理nvl：由于null和任何数值计算都是null，通过nvl处理，可以将null转换为0，nvl(comm,0)。 Rownum与分页查询123456----emp表工资倒叙排列后，每页五条记录，查询第二页。select * from( select rownum rn, tt.* from( select * from emp order by sal desc ) tt where rownum&lt;11) where rn&gt;5 Oracle视图1234视图就是封装了一条复杂查询的语句，提供一个查询的窗口，所有数据来自于原表。语法：CREATE OR REPLACE VIEW 视图名称 AS 子查询 with read only例如：create view v_emp as select ename, job from emp with read only;作用：可以屏蔽掉一些敏感字段，保证总部和分部数据及时统一。 索引1234567索引就是在表的列上构建一个二叉树 B+Tree，达到大幅度提高查询效率的目的，但是索引会影响增删改的效率。单列索引：create index idx_ename on emp(ename); 触发条件：必须是索引列中的原始值复合索引：create index idx_enamejob on emp(ename, job); 触发条件：能优先检索列中的原始值使用原则：1. 在大表上建立索引才有意义2. 在where子句后面或者是连接条件上的字段建立索引3. 表中数据修改频率高时不建议建立索引 2. pl/sql语言1PL/SQL（Procedure Language/SQL）是Oracle对sql语言的过程化扩展，在SQL命令语言中增加了过程处理语句（如分支、循环等），使SQL语言具有过程处理能力，结合了SQL语言的数据操纵能力与过程语言的数据处理能力。 基本语法12345678程序语法： declare 说明部分 （变量说明，游标申明，例外说明） begin 语句序列 （DML语句）… exception 例外处理语句 End; 变量的类型基本类型：char, varchar2, date, number, boolean, long 引用变量：Myname emp.ename%type; 在sql中使用into来赋值 记录型变量：e1 emp%rowtype if分支12345678910111213语法1：IF 条件 THEN 语句1; 语句2; END IF;语法2：IF 条件 THEN 语句序列1； ELSE 语句序列 2； END IF；语法3：IF 条件 THEN 语句; ELSIF 语句 THEN 语句; ELSE 语句; END IF; LOOP循环语句1234567891011121314151617181920212223242526272829--while循环declare i number(2) := 1;begin while i &lt; 11 loop dbms_output.put_line(i); i := i + 1; end loop;end;--exit循环declare i number(2) := 1;begin loop exit when i &gt; 10; dbms_output.put_line(i); i := i + 1; end loop;end;--for循环declare begin for i in 1..10 loop dbms_output.put_line(i); end loop;end; 游标12345678游标可以存储查询返回的多条数据游标的创建： cursor c1 is select ename from emp;游标使用步骤： 打开游标： open c1; (打开游标执行查询) 取一行游标的值：fetch c1 into pjob; (取一行到变量中) 关闭游标： close c1;(关闭游标释放资源) 游标的结束方式 exit when c1%notfound 123456789101112131415161718192021范例：按员工的工种涨工资,总裁1000元，经理涨800元其，他人员涨400元create table myemp as select * from emp;declare cursor pc is select * from myemp; addsal myemp.sal%type; pemp myemp%rowtype; begin open pc; loop fetch pc into pemp; exit when pc%notfound; if pemp.job = &apos;PRESIDENT&apos; then addsal := 1000; elsif pemp.job = &apos;MANAGER&apos; then addsal := 800; else addsal := 400; end if; update myemp t set t.sal = t.sal + addsal where t.empno = pemp.empno; end loop; close pc; end; 3. 存储过程1存储过程（Stored Procedure）是在大型数据库系统中，一组为了完成特定功能的SQL语句集，经编译后存储在数据库中，用户通过指定存储过程的名字并给出参数（如果该存储过程带有参数）来执行它。 123456789101112创建存储过程:create [or replace] PROCEDURE 过程名[(参数名 in/out 数据类型)]ASbegin PLSQL子程序体；End;调用存储过程:begin -- Call the procedure 过程名; end; 12345678910111213141516-- 创建存储过程，通过工号求年薪create or replace procedure p_yearsal(eno emp.empno%type, yearsal out number)is s number(10); c emp.comm%type;begin select sal*12,nvl(comm,0) into s,c from emp where empno = eno; yearsal := s+c;end;-- 调用存储过程declare yearsal number(10);begin p_yearsal(7788,yearsal); dbms_output.put_line(yearsal);end; 4. 存储函数12345create or replace function 函数名(Name in type, Name in type, ...) return 数据类型 is 结果变量 数据类型;begin return(结果变量);end函数名; 1234567891011--使用存储函数来实现提供一个部门编号，输出一个部门名称create table dept as select * from scott.dept;create or replace function fdna(dno dept.deptno%type) return dept.dname%typeis dna dept.dname%type;begin select dname into dna from dept where deptno = dno; return dna;end;-- 调用存储函数select e.ename, fdna(e.deptno) from emp e; 存储过程和存储函数的区别存储过程和函数的区别在于函数可以有一个返回值；而过程没有返回值。但过程和函数都可以通过out指定一个或多个输出参数。利用out参数可以在过程和函数中实现返回多个值。 5. 触发器1数据库触发器是一个与表相关联的、存储的PL/SQL程序。每当一个特定的数据操作语句(Insert,update,delete)在指定的表上发出时，Oracle自动地执行触发器中定义的语句序列。 1234567891011121314151617-- 禁止给员工降薪的触发器create or replace trigger t2beforeupdateon emp for each row declarebegin if :old.sal&gt;:new.sal then raise_application_error(-20001,'不能给员工降薪'); end if;end;select * from emp where empno = 7788;update emp set sal = sal-1 where empno = 7788;commit; 6. Java程序调用存储过程12345678910111213@Testpublic void javaCallProcedure() throws Exception &#123; Class.forName("oracle.jdbc.driver.OracleDriver"); Connection connection = DriverManager.getConnection( "jdbc:oracle:thin:@192.168.44.130:1521:orcl", "itcastuser", "itcast"); CallableStatement call = connection.prepareCall("&#123;call p_yearsal(?,?)&#125;"); call.setObject(1, 7788); call.registerOutParameter(2, OracleTypes.NUMBER); call.execute(); System.out.println(call.getObject(2)); call.close(); connection.close();&#125; 5. Lucene1. 全文检索123结构化数据：指具有固定格式或有限长度的数据，如数据库，元数据等。通常都是使用sql语句进行查询，能很快的得到查询结果。非结构化数据：指不定长或无固定格式的数据，如邮件，word文档等磁盘上的文件。非结构化数据查询方法：（1）顺序扫描法(Serial Scanning)（2）全文检索(Full-text Search)。全文检索技术通过先建立索引，再对索引进行搜索。虽然创建索引的过程也是非常耗时的，但是索引一旦创建就可以多次使用，全文检索主要处理的是查询，所以耗时间创建索引是值得的。Lucene：是apache下的一个开放源代码的全文检索引擎工具包。提供了完整的查询引擎和索引引擎，部分文本分析引擎。Lucene的目的是为软件开发人员提供一个简单易用的工具包，以方便的在目标系统中实现全文检索的功能。 2. 创建索引索引库的结构 关系型数据库 索引库 库/表 index 一行记录 Document 文档 字段 Field 域 每个Document可以有多个Field，每个文档都有一个唯一的编号，就是文档的id。 分析文档1将原始内容创建为包含域（Field）的文档（document），需要再对域中的内容进行分析，分析的过程是经过对原始文档提取单词、将字母转为小写、去除标点符号、去除停用词等过程生成最终的语汇单元，可以将语汇单元理解为一个一个的单词。每个单词叫做一个Term，不同的域中拆分出来的相同的单词是不同的term。 创建索引1创建索引是对语汇单元索引，通过词语找文档，这种索引的结构叫倒排索引结构，最终可实现只搜索被索引的语汇单元从而找到Document（文档）。倒排索引结构也叫反向索引结构，包括索引和文档两部分，索引即词汇表，它的规模较小，而文档集合较大。 代码演示12345678910111213141516171819202122232425262728293031public void createIndex() throws IOException &#123; //创建一个Director对象，指定索引库保存的位置。 Directory directory = FSDirectory.open(new File("C:\\index").toPath()); //基于Directory对象创建一个IndexWriter对象 IndexWriterConfig config = new IndexWriterConfig(); IndexWriter indexWriter = new IndexWriter(directory, config); //读取磁盘上的文件，对应每个文件创建一个文档对象。 File dir = new File(("C:\\searchsource")); for (File f : dir.listFiles()) &#123; //获取文件的各项属性 String fileName = f.getName(); String fileContent = FileUtils.readFileToString(f); String filePath = f.getPath(); long fileSize = FileUtils.sizeOf(f); //将文件的各项属性存入域中 Field fileNameField = new TextField("filename", fileName, Field.Store.YES); Field fileContentField = new TextField("content", fileContent, Field.Store.YES); Field filePathField = new TextField("path", filePath, Field.Store.YES); Field fileSizeField = new TextField("size", fileSize + "", Field.Store.YES); //向文档对象中添加域 Document document = new Document(); document.add(fileNameField); document.add(fileContentField); document.add(filePathField); document.add(fileSizeField); //把文档对象写入索引库 indexWriter.addDocument(document); &#125; //关闭indexWriter对象 indexWriter.close();&#125; 3. 查询索引123456789101112131415161718192021222324@Testpublic void searchIndex() throws IOException &#123; //创建一个Directory对象，也就是索引库存放的位置 Directory directory = FSDirectory.open(new File("C:\\index").toPath()); //创建一个indexReader对象，需要指定Directory对象 IndexReader indexReader = DirectoryReader.open(directory); //创建一个indexSearcher对象，需要指定IndexReader对象 IndexSearcher indexSearcher = new IndexSearcher(indexReader); //创建一个TermQuery对象，指定查询的域和查询的关键词 Query query = new TermQuery(new Term("content", "apache")); //执行查询，查询结果返回的最大值为5 TopDocs topDocs = indexSearcher.search(query, 5); //返回查询结果。遍历查询结果并输出。 System.out.println("查询结果的总条数：" + topDocs.totalHits); for (ScoreDoc scoreDoc : topDocs.scoreDocs) &#123; Document document = indexSearcher.doc(scoreDoc.doc); System.out.println(document.get("filename")); System.out.println(document.get("content")); System.out.println(document.get("size")); System.out.println("-------------------------"); &#125; //关闭IndexReader对象 indexReader.close();&#125; 4. 分词器IKAnalyzer 中文分词器 使用方法： 把jar包添加到工程中 把配置文件和扩展词典和停用词词典添加到classpath下(禁止使用windows记事本编辑扩展词典文件) 使用自定义分词器 123456&gt; public void createIndex() throws IOException &#123;&gt; Directory directory = FSDirectory.open(new File("C:\\index").toPath());&gt; //基于Directory对象创建一个IndexWriter对象&gt; IndexWriterConfig config = new IndexWriterConfig(new IKAnalyzer());&gt; IndexWriter indexWriter = new IndexWriter(directory, config);&#125;&gt; 5. Field域的属性 Field类 数据类型 Analyzed Indexed Stored Case StringField 字符串 N Y Y/N 身份证号 LongPoint Long型 Y Y N StoredField 支持多种类型 N N Y 文件路径 TextField 字符串或流 Y Y Y/N 知网文章 是否分析：是否对域的内容进行分词处理。前提是我们要对域的内容进行查询。 是否索引：将Field分析后的词或整个Field值进行索引，只有索引方可搜索到。 是否存储：将Field值存储在文档中，存储在文档中的Field才可以从Document中获取 6. 索引库维护1234567891011121314151617181920212223242526272829@Testpublic void test() throws Exception &#123; Directory directory = FSDirectory.open(new File("D:\\temp\\index").toPath()); IndexWriterConfig config = new IndexWriterConfig(new IKAnalyzer()); IndexWriter indexWriter = new IndexWriter(directory, config); Document document = new Document(); //索引库的添加 document.add(new TextField("filename", "新添加的文档", Field.Store.YES)); document.add(new TextField("content", "新添加的文档的内容", Field.Store.NO)); document.add(new LongPoint("size", 1000l)); //LongPoint创建索引 document.add(new StoredField("size", 1000l)); //StoreField存储数据 document.add(new StoredField("path", "d:/temp/1.txt")); //不需要创建索引的用StoreField indexWriter.addDocument(document); //添加文档到索引库 //索引库的删除 indexWriter.deleteAll(); //删除全部索引 Query query = new TermQuery(new Term("filename", "apache")); //创建一个查询条件 indexWriter.deleteDocuments(query); //根据查询条件删除 //索引库的修改（原理就是先删除后添加） indexWriter.updateDocument(new Term("content", "java"), document); //索引库的查询 //TermQuery不使用分析器所以建议匹配不分词的Field域查询 Query query = new TermQuery(new Term("content", "lucene")); TopDocs topDocs = indexSearcher.search(query, 10); //newRangeQuery数值范围查询 Query query = LongPoint.newRangeQuery("size", 0l, 10000l); //使用queryparser查询，第一个参数默认搜索的域，第二个参数就是分析器对象 QueryParser queryParser = new QueryParser("content", new IKAnalyzer()); Query query = queryParser.parse("Lucene是java开发的");&#125;]]></content>
  </entry>
</search>
